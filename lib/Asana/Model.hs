{-
   Asana

   This is the interface for interacting with the [Asana Platform](https://developers.asana.com). Our API reference is generated from our [OpenAPI spec] (https://raw.githubusercontent.com/Asana/developer-docs/master/defs/asana_oas.yaml).

   OpenAPI Version: 3.0.0
   Asana API version: 1.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Asana.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Asana.Model where

import Asana.Core
import Asana.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Archived
newtype Archived = Archived { unArchived :: Bool } deriving (P.Eq, P.Show)

-- ** AssignedByAny
newtype AssignedByAny = AssignedByAny { unAssignedByAny :: Text } deriving (P.Eq, P.Show)

-- ** AssignedByNot
newtype AssignedByNot = AssignedByNot { unAssignedByNot :: Text } deriving (P.Eq, P.Show)

-- ** Assignee
newtype Assignee = Assignee { unAssignee :: Text } deriving (P.Eq, P.Show)

-- ** AssigneeAny
newtype AssigneeAny = AssigneeAny { unAssigneeAny :: Text } deriving (P.Eq, P.Show)

-- ** AssigneeNot
newtype AssigneeNot = AssigneeNot { unAssigneeNot :: Text } deriving (P.Eq, P.Show)

-- ** AssigneeStatus
newtype AssigneeStatus = AssigneeStatus { unAssigneeStatus :: E'AssigneeStatus2 } deriving (P.Eq, P.Show)

-- ** AttachmentGid
newtype AttachmentGid = AttachmentGid { unAttachmentGid :: Text } deriving (P.Eq, P.Show)

-- ** CommentedOnByAny
newtype CommentedOnByAny = CommentedOnByAny { unCommentedOnByAny :: Text } deriving (P.Eq, P.Show)

-- ** CommentedOnByNot
newtype CommentedOnByNot = CommentedOnByNot { unCommentedOnByNot :: Text } deriving (P.Eq, P.Show)

-- ** Completed
newtype Completed = Completed { unCompleted :: Bool } deriving (P.Eq, P.Show)

-- ** CompletedAtAfter
newtype CompletedAtAfter = CompletedAtAfter { unCompletedAtAfter :: DateTime } deriving (P.Eq, P.Show)

-- ** CompletedAtBefore
newtype CompletedAtBefore = CompletedAtBefore { unCompletedAtBefore :: DateTime } deriving (P.Eq, P.Show)

-- ** CompletedOn
newtype CompletedOn = CompletedOn { unCompletedOn :: Date } deriving (P.Eq, P.Show)

-- ** CompletedOnAfter
newtype CompletedOnAfter = CompletedOnAfter { unCompletedOnAfter :: Date } deriving (P.Eq, P.Show)

-- ** CompletedOnBefore
newtype CompletedOnBefore = CompletedOnBefore { unCompletedOnBefore :: Date } deriving (P.Eq, P.Show)

-- ** CompletedSince
newtype CompletedSince = CompletedSince { unCompletedSince :: DateTime } deriving (P.Eq, P.Show)

-- ** CompletedSinceText
newtype CompletedSinceText = CompletedSinceText { unCompletedSinceText :: Text } deriving (P.Eq, P.Show)

-- ** Count
newtype Count = Count { unCount :: Int } deriving (P.Eq, P.Show)

-- ** CreatedAtAfter
newtype CreatedAtAfter = CreatedAtAfter { unCreatedAtAfter :: DateTime } deriving (P.Eq, P.Show)

-- ** CreatedAtBefore
newtype CreatedAtBefore = CreatedAtBefore { unCreatedAtBefore :: DateTime } deriving (P.Eq, P.Show)

-- ** CreatedByAny
newtype CreatedByAny = CreatedByAny { unCreatedByAny :: Text } deriving (P.Eq, P.Show)

-- ** CreatedByNot
newtype CreatedByNot = CreatedByNot { unCreatedByNot :: Text } deriving (P.Eq, P.Show)

-- ** CreatedOn
newtype CreatedOn = CreatedOn { unCreatedOn :: Date } deriving (P.Eq, P.Show)

-- ** CreatedOnAfter
newtype CreatedOnAfter = CreatedOnAfter { unCreatedOnAfter :: Date } deriving (P.Eq, P.Show)

-- ** CreatedOnBefore
newtype CreatedOnBefore = CreatedOnBefore { unCreatedOnBefore :: Date } deriving (P.Eq, P.Show)

-- ** CustomFieldGid
newtype CustomFieldGid = CustomFieldGid { unCustomFieldGid :: Text } deriving (P.Eq, P.Show)

-- ** DueAtAfter
newtype DueAtAfter = DueAtAfter { unDueAtAfter :: DateTime } deriving (P.Eq, P.Show)

-- ** DueAtBefore
newtype DueAtBefore = DueAtBefore { unDueAtBefore :: DateTime } deriving (P.Eq, P.Show)

-- ** DueOn
newtype DueOn = DueOn { unDueOn :: Date } deriving (P.Eq, P.Show)

-- ** DueOnAfter
newtype DueOnAfter = DueOnAfter { unDueOnAfter :: Date } deriving (P.Eq, P.Show)

-- ** DueOnBefore
newtype DueOnBefore = DueOnBefore { unDueOnBefore :: Date } deriving (P.Eq, P.Show)

-- ** EnumOptionGid
newtype EnumOptionGid = EnumOptionGid { unEnumOptionGid :: Text } deriving (P.Eq, P.Show)

-- ** File
newtype File = File { unFile :: FilePath } deriving (P.Eq, P.Show)

-- ** FollowersAny
newtype FollowersAny = FollowersAny { unFollowersAny :: Text } deriving (P.Eq, P.Show)

-- ** FollowersNot
newtype FollowersNot = FollowersNot { unFollowersNot :: Text } deriving (P.Eq, P.Show)

-- ** HasAttachment
newtype HasAttachment = HasAttachment { unHasAttachment :: Bool } deriving (P.Eq, P.Show)

-- ** IsBlocked
newtype IsBlocked = IsBlocked { unIsBlocked :: Bool } deriving (P.Eq, P.Show)

-- ** IsBlocking
newtype IsBlocking = IsBlocking { unIsBlocking :: Bool } deriving (P.Eq, P.Show)

-- ** IsSubtask
newtype IsSubtask = IsSubtask { unIsSubtask :: Bool } deriving (P.Eq, P.Show)

-- ** JobGid
newtype JobGid = JobGid { unJobGid :: Text } deriving (P.Eq, P.Show)

-- ** LikedByAny
newtype LikedByAny = LikedByAny { unLikedByAny :: Text } deriving (P.Eq, P.Show)

-- ** LikedByNot
newtype LikedByNot = LikedByNot { unLikedByNot :: Text } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** ModifiedAtAfter
newtype ModifiedAtAfter = ModifiedAtAfter { unModifiedAtAfter :: DateTime } deriving (P.Eq, P.Show)

-- ** ModifiedAtBefore
newtype ModifiedAtBefore = ModifiedAtBefore { unModifiedAtBefore :: DateTime } deriving (P.Eq, P.Show)

-- ** ModifiedOn
newtype ModifiedOn = ModifiedOn { unModifiedOn :: Date } deriving (P.Eq, P.Show)

-- ** ModifiedOnAfter
newtype ModifiedOnAfter = ModifiedOnAfter { unModifiedOnAfter :: Date } deriving (P.Eq, P.Show)

-- ** ModifiedOnBefore
newtype ModifiedOnBefore = ModifiedOnBefore { unModifiedOnBefore :: Date } deriving (P.Eq, P.Show)

-- ** ModifiedSince
newtype ModifiedSince = ModifiedSince { unModifiedSince :: DateTime } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Text } deriving (P.Eq, P.Show)

-- ** OptFields
newtype OptFields = OptFields { unOptFields :: [Text] } deriving (P.Eq, P.Show)

-- ** OptPretty
newtype OptPretty = OptPretty { unOptPretty :: Bool } deriving (P.Eq, P.Show)

-- ** Organization
newtype Organization = Organization { unOrganization :: Text } deriving (P.Eq, P.Show)

-- ** OrganizationExportGid
newtype OrganizationExportGid = OrganizationExportGid { unOrganizationExportGid :: Text } deriving (P.Eq, P.Show)

-- ** Owner
newtype Owner = Owner { unOwner :: Text } deriving (P.Eq, P.Show)

-- ** ParamText
newtype ParamText = ParamText { unParamText :: Text } deriving (P.Eq, P.Show)

-- ** ParamType
newtype ParamType = ParamType { unParamType :: E'ResourceType } deriving (P.Eq, P.Show)

-- ** Portfolio
newtype Portfolio = Portfolio { unPortfolio :: Text } deriving (P.Eq, P.Show)

-- ** PortfolioGid
newtype PortfolioGid = PortfolioGid { unPortfolioGid :: Text } deriving (P.Eq, P.Show)

-- ** PortfolioMembershipGid
newtype PortfolioMembershipGid = PortfolioMembershipGid { unPortfolioMembershipGid :: Text } deriving (P.Eq, P.Show)

-- ** Project
newtype Project = Project { unProject :: Text } deriving (P.Eq, P.Show)

-- ** ProjectGid
newtype ProjectGid = ProjectGid { unProjectGid :: Text } deriving (P.Eq, P.Show)

-- ** ProjectMembershipGid
newtype ProjectMembershipGid = ProjectMembershipGid { unProjectMembershipGid :: Text } deriving (P.Eq, P.Show)

-- ** ProjectStatusGid
newtype ProjectStatusGid = ProjectStatusGid { unProjectStatusGid :: Text } deriving (P.Eq, P.Show)

-- ** ProjectsAll
newtype ProjectsAll = ProjectsAll { unProjectsAll :: Text } deriving (P.Eq, P.Show)

-- ** ProjectsAny
newtype ProjectsAny = ProjectsAny { unProjectsAny :: Text } deriving (P.Eq, P.Show)

-- ** ProjectsNot
newtype ProjectsNot = ProjectsNot { unProjectsNot :: Text } deriving (P.Eq, P.Show)

-- ** Query
newtype Query = Query { unQuery :: Text } deriving (P.Eq, P.Show)

-- ** Resource
newtype Resource = Resource { unResource :: Text } deriving (P.Eq, P.Show)

-- ** ResourceSubtype
newtype ResourceSubtype = ResourceSubtype { unResourceSubtype :: E'ResourceSubtype3 } deriving (P.Eq, P.Show)

-- ** ResourceType
newtype ResourceType = ResourceType { unResourceType :: E'ResourceType } deriving (P.Eq, P.Show)

-- ** ResourceType2
newtype ResourceType2 = ResourceType2 { unResourceType2 :: E'ResourceType2 } deriving (P.Eq, P.Show)

-- ** Section
newtype Section = Section { unSection :: Text } deriving (P.Eq, P.Show)

-- ** SectionGid
newtype SectionGid = SectionGid { unSectionGid :: Text } deriving (P.Eq, P.Show)

-- ** SectionsAll
newtype SectionsAll = SectionsAll { unSectionsAll :: Text } deriving (P.Eq, P.Show)

-- ** SectionsAny
newtype SectionsAny = SectionsAny { unSectionsAny :: Text } deriving (P.Eq, P.Show)

-- ** SectionsNot
newtype SectionsNot = SectionsNot { unSectionsNot :: Text } deriving (P.Eq, P.Show)

-- ** SortAscending
newtype SortAscending = SortAscending { unSortAscending :: Bool } deriving (P.Eq, P.Show)

-- ** SortBy
newtype SortBy = SortBy { unSortBy :: E'SortBy } deriving (P.Eq, P.Show)

-- ** StartOn
newtype StartOn = StartOn { unStartOn :: Date } deriving (P.Eq, P.Show)

-- ** StartOnAfter
newtype StartOnAfter = StartOnAfter { unStartOnAfter :: Date } deriving (P.Eq, P.Show)

-- ** StartOnBefore
newtype StartOnBefore = StartOnBefore { unStartOnBefore :: Date } deriving (P.Eq, P.Show)

-- ** StoryGid
newtype StoryGid = StoryGid { unStoryGid :: Text } deriving (P.Eq, P.Show)

-- ** Sync
newtype Sync = Sync { unSync :: Text } deriving (P.Eq, P.Show)

-- ** TagGid
newtype TagGid = TagGid { unTagGid :: Text } deriving (P.Eq, P.Show)

-- ** TagsAll
newtype TagsAll = TagsAll { unTagsAll :: Text } deriving (P.Eq, P.Show)

-- ** TagsAny
newtype TagsAny = TagsAny { unTagsAny :: Text } deriving (P.Eq, P.Show)

-- ** TagsNot
newtype TagsNot = TagsNot { unTagsNot :: Text } deriving (P.Eq, P.Show)

-- ** TaskGid
newtype TaskGid = TaskGid { unTaskGid :: Text } deriving (P.Eq, P.Show)

-- ** Team
newtype Team = Team { unTeam :: Text } deriving (P.Eq, P.Show)

-- ** TeamGid
newtype TeamGid = TeamGid { unTeamGid :: Text } deriving (P.Eq, P.Show)

-- ** TeamMembershipGid
newtype TeamMembershipGid = TeamMembershipGid { unTeamMembershipGid :: Text } deriving (P.Eq, P.Show)

-- ** TeamsAny
newtype TeamsAny = TeamsAny { unTeamsAny :: Text } deriving (P.Eq, P.Show)

-- ** User
newtype User = User { unUser :: Text } deriving (P.Eq, P.Show)

-- ** UserGid
newtype UserGid = UserGid { unUserGid :: Text } deriving (P.Eq, P.Show)

-- ** UserTaskListGid
newtype UserTaskListGid = UserTaskListGid { unUserTaskListGid :: Text } deriving (P.Eq, P.Show)

-- ** WebhookGid
newtype WebhookGid = WebhookGid { unWebhookGid :: Text } deriving (P.Eq, P.Show)

-- ** Workspace
newtype Workspace = Workspace { unWorkspace :: Text } deriving (P.Eq, P.Show)

-- ** WorkspaceGid
newtype WorkspaceGid = WorkspaceGid { unWorkspaceGid :: Text } deriving (P.Eq, P.Show)

-- ** WorkspaceMembershipGid
newtype WorkspaceMembershipGid = WorkspaceMembershipGid { unWorkspaceMembershipGid :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** AddCustomFieldSettingRequest
-- | AddCustomFieldSettingRequest
data AddCustomFieldSettingRequest = AddCustomFieldSettingRequest
  { addCustomFieldSettingRequestCustomField :: !(Text) -- ^ /Required/ "custom_field" - The custom field to associate with this container.
  , addCustomFieldSettingRequestIsImportant :: !(Maybe Bool) -- ^ "is_important" - Whether this field should be considered important to this container (for instance, to display in the list view of items in the container).
  , addCustomFieldSettingRequestInsertBefore :: !(Maybe Text) -- ^ "insert_before" - A gid of a Custom Field Setting on this container, before which the new Custom Field Setting will be added.  &#x60;insert_before&#x60; and &#x60;insert_after&#x60; parameters cannot both be specified.
  , addCustomFieldSettingRequestInsertAfter :: !(Maybe Text) -- ^ "insert_after" - A gid of a Custom Field Setting on this container, after which the new Custom Field Setting will be added.  &#x60;insert_before&#x60; and &#x60;insert_after&#x60; parameters cannot both be specified.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddCustomFieldSettingRequest
instance A.FromJSON AddCustomFieldSettingRequest where
  parseJSON = A.withObject "AddCustomFieldSettingRequest" $ \o ->
    AddCustomFieldSettingRequest
      <$> (o .:  "custom_field")
      <*> (o .:? "is_important")
      <*> (o .:? "insert_before")
      <*> (o .:? "insert_after")

-- | ToJSON AddCustomFieldSettingRequest
instance A.ToJSON AddCustomFieldSettingRequest where
  toJSON AddCustomFieldSettingRequest {..} =
   _omitNulls
      [ "custom_field" .= addCustomFieldSettingRequestCustomField
      , "is_important" .= addCustomFieldSettingRequestIsImportant
      , "insert_before" .= addCustomFieldSettingRequestInsertBefore
      , "insert_after" .= addCustomFieldSettingRequestInsertAfter
      ]


-- | Construct a value of type 'AddCustomFieldSettingRequest' (by applying it's required fields, if any)
mkAddCustomFieldSettingRequest
  :: Text -- ^ 'addCustomFieldSettingRequestCustomField': The custom field to associate with this container.
  -> AddCustomFieldSettingRequest
mkAddCustomFieldSettingRequest addCustomFieldSettingRequestCustomField =
  AddCustomFieldSettingRequest
  { addCustomFieldSettingRequestCustomField
  , addCustomFieldSettingRequestIsImportant = Nothing
  , addCustomFieldSettingRequestInsertBefore = Nothing
  , addCustomFieldSettingRequestInsertAfter = Nothing
  }

-- ** AddFollowersRequest
-- | AddFollowersRequest
data AddFollowersRequest = AddFollowersRequest
  { addFollowersRequestFollowers :: !(Text) -- ^ /Required/ "followers" - An array of strings identifying users. These can either be the string \&quot;me\&quot;, an email, or the gid of a user.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddFollowersRequest
instance A.FromJSON AddFollowersRequest where
  parseJSON = A.withObject "AddFollowersRequest" $ \o ->
    AddFollowersRequest
      <$> (o .:  "followers")

-- | ToJSON AddFollowersRequest
instance A.ToJSON AddFollowersRequest where
  toJSON AddFollowersRequest {..} =
   _omitNulls
      [ "followers" .= addFollowersRequestFollowers
      ]


-- | Construct a value of type 'AddFollowersRequest' (by applying it's required fields, if any)
mkAddFollowersRequest
  :: Text -- ^ 'addFollowersRequestFollowers': An array of strings identifying users. These can either be the string \"me\", an email, or the gid of a user.
  -> AddFollowersRequest
mkAddFollowersRequest addFollowersRequestFollowers =
  AddFollowersRequest
  { addFollowersRequestFollowers
  }

-- ** AddMembersRequest
-- | AddMembersRequest
data AddMembersRequest = AddMembersRequest
  { addMembersRequestMembers :: !(Text) -- ^ /Required/ "members" - An array of strings identifying users. These can either be the string \&quot;me\&quot;, an email, or the gid of a user.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddMembersRequest
instance A.FromJSON AddMembersRequest where
  parseJSON = A.withObject "AddMembersRequest" $ \o ->
    AddMembersRequest
      <$> (o .:  "members")

-- | ToJSON AddMembersRequest
instance A.ToJSON AddMembersRequest where
  toJSON AddMembersRequest {..} =
   _omitNulls
      [ "members" .= addMembersRequestMembers
      ]


-- | Construct a value of type 'AddMembersRequest' (by applying it's required fields, if any)
mkAddMembersRequest
  :: Text -- ^ 'addMembersRequestMembers': An array of strings identifying users. These can either be the string \"me\", an email, or the gid of a user.
  -> AddMembersRequest
mkAddMembersRequest addMembersRequestMembers =
  AddMembersRequest
  { addMembersRequestMembers
  }

-- ** AsanaNamedResource
-- | AsanaNamedResource
data AsanaNamedResource = AsanaNamedResource
  { asanaNamedResourceGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , asanaNamedResourceResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , asanaNamedResourceName :: !(Maybe Text) -- ^ "name" - The name of the object.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AsanaNamedResource
instance A.FromJSON AsanaNamedResource where
  parseJSON = A.withObject "AsanaNamedResource" $ \o ->
    AsanaNamedResource
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")

-- | ToJSON AsanaNamedResource
instance A.ToJSON AsanaNamedResource where
  toJSON AsanaNamedResource {..} =
   _omitNulls
      [ "gid" .= asanaNamedResourceGid
      , "resource_type" .= asanaNamedResourceResourceType
      , "name" .= asanaNamedResourceName
      ]


-- | Construct a value of type 'AsanaNamedResource' (by applying it's required fields, if any)
mkAsanaNamedResource
  :: AsanaNamedResource
mkAsanaNamedResource =
  AsanaNamedResource
  { asanaNamedResourceGid = Nothing
  , asanaNamedResourceResourceType = Nothing
  , asanaNamedResourceName = Nothing
  }

-- ** AsanaNamedResourceAllOf
-- | AsanaNamedResourceAllOf
data AsanaNamedResourceAllOf = AsanaNamedResourceAllOf
  { asanaNamedResourceAllOfName :: !(Maybe Text) -- ^ "name" - The name of the object.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AsanaNamedResourceAllOf
instance A.FromJSON AsanaNamedResourceAllOf where
  parseJSON = A.withObject "AsanaNamedResourceAllOf" $ \o ->
    AsanaNamedResourceAllOf
      <$> (o .:? "name")

-- | ToJSON AsanaNamedResourceAllOf
instance A.ToJSON AsanaNamedResourceAllOf where
  toJSON AsanaNamedResourceAllOf {..} =
   _omitNulls
      [ "name" .= asanaNamedResourceAllOfName
      ]


-- | Construct a value of type 'AsanaNamedResourceAllOf' (by applying it's required fields, if any)
mkAsanaNamedResourceAllOf
  :: AsanaNamedResourceAllOf
mkAsanaNamedResourceAllOf =
  AsanaNamedResourceAllOf
  { asanaNamedResourceAllOfName = Nothing
  }

-- ** AsanaResource
-- | AsanaResource
-- A generic Asana Resource, containing a globally unique identifier.
data AsanaResource = AsanaResource
  { asanaResourceGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , asanaResourceResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AsanaResource
instance A.FromJSON AsanaResource where
  parseJSON = A.withObject "AsanaResource" $ \o ->
    AsanaResource
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")

-- | ToJSON AsanaResource
instance A.ToJSON AsanaResource where
  toJSON AsanaResource {..} =
   _omitNulls
      [ "gid" .= asanaResourceGid
      , "resource_type" .= asanaResourceResourceType
      ]


-- | Construct a value of type 'AsanaResource' (by applying it's required fields, if any)
mkAsanaResource
  :: AsanaResource
mkAsanaResource =
  AsanaResource
  { asanaResourceGid = Nothing
  , asanaResourceResourceType = Nothing
  }

-- ** AttachmentBase
-- | AttachmentBase
data AttachmentBase = AttachmentBase
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AttachmentBase
instance A.FromJSON AttachmentBase where
  parseJSON = A.withObject "AttachmentBase" $ \o ->
    pure AttachmentBase
      

-- | ToJSON AttachmentBase
instance A.ToJSON AttachmentBase where
  toJSON AttachmentBase  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'AttachmentBase' (by applying it's required fields, if any)
mkAttachmentBase
  :: AttachmentBase
mkAttachmentBase =
  AttachmentBase
  { 
  }

-- ** AttachmentCompact
-- | AttachmentCompact
data AttachmentCompact = AttachmentCompact
  { attachmentCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , attachmentCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , attachmentCompactName :: !(Maybe Text) -- ^ "name" - The name of the file.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AttachmentCompact
instance A.FromJSON AttachmentCompact where
  parseJSON = A.withObject "AttachmentCompact" $ \o ->
    AttachmentCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")

-- | ToJSON AttachmentCompact
instance A.ToJSON AttachmentCompact where
  toJSON AttachmentCompact {..} =
   _omitNulls
      [ "gid" .= attachmentCompactGid
      , "resource_type" .= attachmentCompactResourceType
      , "name" .= attachmentCompactName
      ]


-- | Construct a value of type 'AttachmentCompact' (by applying it's required fields, if any)
mkAttachmentCompact
  :: AttachmentCompact
mkAttachmentCompact =
  AttachmentCompact
  { attachmentCompactGid = Nothing
  , attachmentCompactResourceType = Nothing
  , attachmentCompactName = Nothing
  }

-- ** AttachmentCompactAllOf
-- | AttachmentCompactAllOf
-- An *attachment* object represents any file attached to a task in Asana, whether it’s an uploaded file or one associated via a third-party service such as Dropbox or Google Drive.
data AttachmentCompactAllOf = AttachmentCompactAllOf
  { attachmentCompactAllOfName :: !(Maybe Text) -- ^ "name" - The name of the file.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AttachmentCompactAllOf
instance A.FromJSON AttachmentCompactAllOf where
  parseJSON = A.withObject "AttachmentCompactAllOf" $ \o ->
    AttachmentCompactAllOf
      <$> (o .:? "name")

-- | ToJSON AttachmentCompactAllOf
instance A.ToJSON AttachmentCompactAllOf where
  toJSON AttachmentCompactAllOf {..} =
   _omitNulls
      [ "name" .= attachmentCompactAllOfName
      ]


-- | Construct a value of type 'AttachmentCompactAllOf' (by applying it's required fields, if any)
mkAttachmentCompactAllOf
  :: AttachmentCompactAllOf
mkAttachmentCompactAllOf =
  AttachmentCompactAllOf
  { attachmentCompactAllOfName = Nothing
  }

-- ** AttachmentRequest
-- | AttachmentRequest
data AttachmentRequest = AttachmentRequest
  { attachmentRequestFile :: !(Maybe FilePath) -- ^ "file"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AttachmentRequest
instance A.FromJSON AttachmentRequest where
  parseJSON = A.withObject "AttachmentRequest" $ \o ->
    AttachmentRequest
      <$> (o .:? "file")

-- | ToJSON AttachmentRequest
instance A.ToJSON AttachmentRequest where
  toJSON AttachmentRequest {..} =
   _omitNulls
      [ "file" .= attachmentRequestFile
      ]


-- | Construct a value of type 'AttachmentRequest' (by applying it's required fields, if any)
mkAttachmentRequest
  :: AttachmentRequest
mkAttachmentRequest =
  AttachmentRequest
  { attachmentRequestFile = Nothing
  }

-- ** AttachmentResponse
-- | AttachmentResponse
data AttachmentResponse = AttachmentResponse
  { attachmentResponseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , attachmentResponseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , attachmentResponseName :: !(Maybe Text) -- ^ "name" - The name of the file.
  , attachmentResponseCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , attachmentResponseDownloadUrl :: !(Maybe Text) -- ^ "download_url" - The URL containing the content of the attachment. *Note:* May be null if the attachment is hosted by [Box](https://www.box.com/). If present, this URL may only be valid for 1 hour from the time of retrieval. You should avoid persisting this URL somewhere and just refresh it on demand to ensure you do not keep stale URLs.
  , attachmentResponseHost :: !(Maybe Text) -- ^ "host" - The service hosting the attachment. Valid values are &#x60;asana&#x60;, &#x60;dropbox&#x60;, &#x60;gdrive&#x60; and &#x60;box&#x60;.
  , attachmentResponseParent :: !(Maybe TaskCompact) -- ^ "parent"
  , attachmentResponseViewUrl :: !(Maybe Text) -- ^ "view_url" - The URL where the attachment can be viewed, which may be friendlier to users in a browser than just directing them to a raw file. May be null if no view URL exists for the service.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AttachmentResponse
instance A.FromJSON AttachmentResponse where
  parseJSON = A.withObject "AttachmentResponse" $ \o ->
    AttachmentResponse
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "created_at")
      <*> (o .:? "download_url")
      <*> (o .:? "host")
      <*> (o .:? "parent")
      <*> (o .:? "view_url")

-- | ToJSON AttachmentResponse
instance A.ToJSON AttachmentResponse where
  toJSON AttachmentResponse {..} =
   _omitNulls
      [ "gid" .= attachmentResponseGid
      , "resource_type" .= attachmentResponseResourceType
      , "name" .= attachmentResponseName
      , "created_at" .= attachmentResponseCreatedAt
      , "download_url" .= attachmentResponseDownloadUrl
      , "host" .= attachmentResponseHost
      , "parent" .= attachmentResponseParent
      , "view_url" .= attachmentResponseViewUrl
      ]


-- | Construct a value of type 'AttachmentResponse' (by applying it's required fields, if any)
mkAttachmentResponse
  :: AttachmentResponse
mkAttachmentResponse =
  AttachmentResponse
  { attachmentResponseGid = Nothing
  , attachmentResponseResourceType = Nothing
  , attachmentResponseName = Nothing
  , attachmentResponseCreatedAt = Nothing
  , attachmentResponseDownloadUrl = Nothing
  , attachmentResponseHost = Nothing
  , attachmentResponseParent = Nothing
  , attachmentResponseViewUrl = Nothing
  }

-- ** AttachmentResponseAllOf
-- | AttachmentResponseAllOf
data AttachmentResponseAllOf = AttachmentResponseAllOf
  { attachmentResponseAllOfCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , attachmentResponseAllOfDownloadUrl :: !(Maybe Text) -- ^ "download_url" - The URL containing the content of the attachment. *Note:* May be null if the attachment is hosted by [Box](https://www.box.com/). If present, this URL may only be valid for 1 hour from the time of retrieval. You should avoid persisting this URL somewhere and just refresh it on demand to ensure you do not keep stale URLs.
  , attachmentResponseAllOfHost :: !(Maybe Text) -- ^ "host" - The service hosting the attachment. Valid values are &#x60;asana&#x60;, &#x60;dropbox&#x60;, &#x60;gdrive&#x60; and &#x60;box&#x60;.
  , attachmentResponseAllOfParent :: !(Maybe TaskCompact) -- ^ "parent"
  , attachmentResponseAllOfViewUrl :: !(Maybe Text) -- ^ "view_url" - The URL where the attachment can be viewed, which may be friendlier to users in a browser than just directing them to a raw file. May be null if no view URL exists for the service.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AttachmentResponseAllOf
instance A.FromJSON AttachmentResponseAllOf where
  parseJSON = A.withObject "AttachmentResponseAllOf" $ \o ->
    AttachmentResponseAllOf
      <$> (o .:? "created_at")
      <*> (o .:? "download_url")
      <*> (o .:? "host")
      <*> (o .:? "parent")
      <*> (o .:? "view_url")

-- | ToJSON AttachmentResponseAllOf
instance A.ToJSON AttachmentResponseAllOf where
  toJSON AttachmentResponseAllOf {..} =
   _omitNulls
      [ "created_at" .= attachmentResponseAllOfCreatedAt
      , "download_url" .= attachmentResponseAllOfDownloadUrl
      , "host" .= attachmentResponseAllOfHost
      , "parent" .= attachmentResponseAllOfParent
      , "view_url" .= attachmentResponseAllOfViewUrl
      ]


-- | Construct a value of type 'AttachmentResponseAllOf' (by applying it's required fields, if any)
mkAttachmentResponseAllOf
  :: AttachmentResponseAllOf
mkAttachmentResponseAllOf =
  AttachmentResponseAllOf
  { attachmentResponseAllOfCreatedAt = Nothing
  , attachmentResponseAllOfDownloadUrl = Nothing
  , attachmentResponseAllOfHost = Nothing
  , attachmentResponseAllOfParent = Nothing
  , attachmentResponseAllOfViewUrl = Nothing
  }

-- ** BatchRequest
-- | BatchRequest
-- A request object for use in a batch request.
data BatchRequest = BatchRequest
  { batchRequestActions :: !(Maybe [BatchRequestAction]) -- ^ "actions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BatchRequest
instance A.FromJSON BatchRequest where
  parseJSON = A.withObject "BatchRequest" $ \o ->
    BatchRequest
      <$> (o .:? "actions")

-- | ToJSON BatchRequest
instance A.ToJSON BatchRequest where
  toJSON BatchRequest {..} =
   _omitNulls
      [ "actions" .= batchRequestActions
      ]


-- | Construct a value of type 'BatchRequest' (by applying it's required fields, if any)
mkBatchRequest
  :: BatchRequest
mkBatchRequest =
  BatchRequest
  { batchRequestActions = Nothing
  }

-- ** BatchRequestAction
-- | BatchRequestAction
-- An action object for use in a batch request.
data BatchRequestAction = BatchRequestAction
  { batchRequestActionRelativePath :: !(Text) -- ^ /Required/ "relative_path" - The path of the desired endpoint relative to the API’s base URL. Query parameters are not accepted here; put them in &#x60;data&#x60; instead.
  , batchRequestActionMethod :: !(E'Method) -- ^ /Required/ "method" - The HTTP method you wish to emulate for the action.
  , batchRequestActionData :: !(Maybe A.Value) -- ^ "data" - For &#x60;GET&#x60; requests, this should be a map of query parameters you would have normally passed in the URL. Options and pagination are not accepted here; put them in &#x60;options&#x60; instead. For &#x60;POST&#x60;, &#x60;PATCH&#x60;, and &#x60;PUT&#x60; methods, this should be the content you would have normally put in the data field of the body.
  , batchRequestActionOptions :: !(Maybe BatchRequestActionOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BatchRequestAction
instance A.FromJSON BatchRequestAction where
  parseJSON = A.withObject "BatchRequestAction" $ \o ->
    BatchRequestAction
      <$> (o .:  "relative_path")
      <*> (o .:  "method")
      <*> (o .:? "data")
      <*> (o .:? "options")

-- | ToJSON BatchRequestAction
instance A.ToJSON BatchRequestAction where
  toJSON BatchRequestAction {..} =
   _omitNulls
      [ "relative_path" .= batchRequestActionRelativePath
      , "method" .= batchRequestActionMethod
      , "data" .= batchRequestActionData
      , "options" .= batchRequestActionOptions
      ]


-- | Construct a value of type 'BatchRequestAction' (by applying it's required fields, if any)
mkBatchRequestAction
  :: Text -- ^ 'batchRequestActionRelativePath': The path of the desired endpoint relative to the API’s base URL. Query parameters are not accepted here; put them in `data` instead.
  -> E'Method -- ^ 'batchRequestActionMethod': The HTTP method you wish to emulate for the action.
  -> BatchRequestAction
mkBatchRequestAction batchRequestActionRelativePath batchRequestActionMethod =
  BatchRequestAction
  { batchRequestActionRelativePath
  , batchRequestActionMethod
  , batchRequestActionData = Nothing
  , batchRequestActionOptions = Nothing
  }

-- ** BatchRequestActionOptions
-- | BatchRequestActionOptions
-- Pagination (`limit` and `offset`) and output options (`fields` or `expand`) for the action. “Pretty” JSON output is not an available option on individual actions; if you want pretty output, specify that option on the parent request.
data BatchRequestActionOptions = BatchRequestActionOptions
  { batchRequestActionOptionsLimit :: !(Maybe Int) -- ^ "limit" - Pagination limit for the request.
  , batchRequestActionOptionsOffset :: !(Maybe Int) -- ^ "offset" - Pagination offset for the request.
  , batchRequestActionOptionsFields :: !(Maybe [Text]) -- ^ "fields" - The fields to retrieve in the request.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BatchRequestActionOptions
instance A.FromJSON BatchRequestActionOptions where
  parseJSON = A.withObject "BatchRequestActionOptions" $ \o ->
    BatchRequestActionOptions
      <$> (o .:? "limit")
      <*> (o .:? "offset")
      <*> (o .:? "fields")

-- | ToJSON BatchRequestActionOptions
instance A.ToJSON BatchRequestActionOptions where
  toJSON BatchRequestActionOptions {..} =
   _omitNulls
      [ "limit" .= batchRequestActionOptionsLimit
      , "offset" .= batchRequestActionOptionsOffset
      , "fields" .= batchRequestActionOptionsFields
      ]


-- | Construct a value of type 'BatchRequestActionOptions' (by applying it's required fields, if any)
mkBatchRequestActionOptions
  :: BatchRequestActionOptions
mkBatchRequestActionOptions =
  BatchRequestActionOptions
  { batchRequestActionOptionsLimit = Nothing
  , batchRequestActionOptionsOffset = Nothing
  , batchRequestActionOptionsFields = Nothing
  }

-- ** BatchResponse
-- | BatchResponse
-- A response object returned from a batch request.
data BatchResponse = BatchResponse
  { batchResponseStatusCode :: !(Maybe Int) -- ^ "status_code" - The HTTP status code that the invoked endpoint returned.
  , batchResponseHeaders :: !(Maybe A.Value) -- ^ "headers" - A map of HTTP headers specific to this result. This is primarily used for returning a &#x60;Location&#x60; header to accompany a &#x60;201 Created&#x60; result.  The parent HTTP response will contain all common headers.
  , batchResponseBody :: !(Maybe A.Value) -- ^ "body" - The JSON body that the invoked endpoint returned.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BatchResponse
instance A.FromJSON BatchResponse where
  parseJSON = A.withObject "BatchResponse" $ \o ->
    BatchResponse
      <$> (o .:? "status_code")
      <*> (o .:? "headers")
      <*> (o .:? "body")

-- | ToJSON BatchResponse
instance A.ToJSON BatchResponse where
  toJSON BatchResponse {..} =
   _omitNulls
      [ "status_code" .= batchResponseStatusCode
      , "headers" .= batchResponseHeaders
      , "body" .= batchResponseBody
      ]


-- | Construct a value of type 'BatchResponse' (by applying it's required fields, if any)
mkBatchResponse
  :: BatchResponse
mkBatchResponse =
  BatchResponse
  { batchResponseStatusCode = Nothing
  , batchResponseHeaders = Nothing
  , batchResponseBody = Nothing
  }

-- ** CustomFieldBase
-- | CustomFieldBase
data CustomFieldBase = CustomFieldBase
  { customFieldBaseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , customFieldBaseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , customFieldBaseName :: !(Maybe Text) -- ^ "name" - The name of the custom field.
  , customFieldBaseResourceSubtype :: !(Maybe E'ResourceSubtype) -- ^ "resource_subtype" - The type of the custom field. Must be one of the given values. 
  , customFieldBaseType :: !(Maybe E'ResourceSubtype) -- ^ "type" - *Deprecated: new integrations should prefer the resource_subtype field.* The type of the custom field. Must be one of the given values. 
  , customFieldBaseEnumOptions :: !(Maybe [EnumOption]) -- ^ "enum_options" - *Conditional*. Only relevant for custom fields of type &#x60;enum&#x60;. This array specifies the possible values which an &#x60;enum&#x60; custom field can adopt. To modify the enum options, refer to [working with enum options](#create-an-enum-option).
  , customFieldBaseEnabled :: !(Maybe Bool) -- ^ "enabled" - *Conditional*. Determines if the custom field is enabled or not.
  , customFieldBaseNumberValue :: !(Maybe Double) -- ^ "number_value" - *Conditional*. This number is the value of a number custom field.
  , customFieldBaseTextValue :: !(Maybe Text) -- ^ "text_value" - *Conditional*. This string is the value of a text custom field.
  , customFieldBaseDescription :: !(Maybe Text) -- ^ "description" - [Opt In](#input-output-options). The description of the custom field.
  , customFieldBasePrecision :: !(Maybe Int) -- ^ "precision" - Only relevant for custom fields of type ‘Number’. This field dictates the number of places after the decimal to round to, i.e. 0 is integer values, 1 rounds to the nearest tenth, and so on. Must be between 0 and 6, inclusive. For percentage format, this may be unintuitive, as a value of 0.25 has a precision of 0, while a value of 0.251 has a precision of 1. This is due to 0.25 being displayed as 25%. The identifier format will always have a precision of 0.
  , customFieldBaseFormat :: !(Maybe E'Format) -- ^ "format" - The format of this custom field.
  , customFieldBaseCurrencyCode :: !(Maybe Text) -- ^ "currency_code" - ISO 4217 currency code to format this custom field. This will be null if the &#x60;format&#x60; is not &#x60;currency&#x60;.
  , customFieldBaseCustomLabel :: !(Maybe Text) -- ^ "custom_label" - This is the string that appears next to the custom field value. This will be null if the &#x60;format&#x60; is not &#x60;custom&#x60;.
  , customFieldBaseCustomLabelPosition :: !(Maybe E'CustomLabelPosition) -- ^ "custom_label_position" - Only relevant for custom fields with &#x60;custom&#x60; format. This depicts where to place the custom label. This will be null if the &#x60;format&#x60; is not &#x60;custom&#x60;.
  , customFieldBaseIsGlobalToWorkspace :: !(Maybe Bool) -- ^ "is_global_to_workspace" - This flag describes whether this custom field is available to every container in the workspace. Before project-specific custom fields, this field was always true.
  , customFieldBaseHasNotificationsEnabled :: !(Maybe Bool) -- ^ "has_notifications_enabled" - *Conditional*. This flag describes whether a follower of a task with this field should receive inbox notifications from changes to this field.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CustomFieldBase
instance A.FromJSON CustomFieldBase where
  parseJSON = A.withObject "CustomFieldBase" $ \o ->
    CustomFieldBase
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "resource_subtype")
      <*> (o .:? "type")
      <*> (o .:? "enum_options")
      <*> (o .:? "enabled")
      <*> (o .:? "number_value")
      <*> (o .:? "text_value")
      <*> (o .:? "description")
      <*> (o .:? "precision")
      <*> (o .:? "format")
      <*> (o .:? "currency_code")
      <*> (o .:? "custom_label")
      <*> (o .:? "custom_label_position")
      <*> (o .:? "is_global_to_workspace")
      <*> (o .:? "has_notifications_enabled")

-- | ToJSON CustomFieldBase
instance A.ToJSON CustomFieldBase where
  toJSON CustomFieldBase {..} =
   _omitNulls
      [ "gid" .= customFieldBaseGid
      , "resource_type" .= customFieldBaseResourceType
      , "name" .= customFieldBaseName
      , "resource_subtype" .= customFieldBaseResourceSubtype
      , "type" .= customFieldBaseType
      , "enum_options" .= customFieldBaseEnumOptions
      , "enabled" .= customFieldBaseEnabled
      , "number_value" .= customFieldBaseNumberValue
      , "text_value" .= customFieldBaseTextValue
      , "description" .= customFieldBaseDescription
      , "precision" .= customFieldBasePrecision
      , "format" .= customFieldBaseFormat
      , "currency_code" .= customFieldBaseCurrencyCode
      , "custom_label" .= customFieldBaseCustomLabel
      , "custom_label_position" .= customFieldBaseCustomLabelPosition
      , "is_global_to_workspace" .= customFieldBaseIsGlobalToWorkspace
      , "has_notifications_enabled" .= customFieldBaseHasNotificationsEnabled
      ]


-- | Construct a value of type 'CustomFieldBase' (by applying it's required fields, if any)
mkCustomFieldBase
  :: CustomFieldBase
mkCustomFieldBase =
  CustomFieldBase
  { customFieldBaseGid = Nothing
  , customFieldBaseResourceType = Nothing
  , customFieldBaseName = Nothing
  , customFieldBaseResourceSubtype = Nothing
  , customFieldBaseType = Nothing
  , customFieldBaseEnumOptions = Nothing
  , customFieldBaseEnabled = Nothing
  , customFieldBaseNumberValue = Nothing
  , customFieldBaseTextValue = Nothing
  , customFieldBaseDescription = Nothing
  , customFieldBasePrecision = Nothing
  , customFieldBaseFormat = Nothing
  , customFieldBaseCurrencyCode = Nothing
  , customFieldBaseCustomLabel = Nothing
  , customFieldBaseCustomLabelPosition = Nothing
  , customFieldBaseIsGlobalToWorkspace = Nothing
  , customFieldBaseHasNotificationsEnabled = Nothing
  }

-- ** CustomFieldBaseAllOf
-- | CustomFieldBaseAllOf
data CustomFieldBaseAllOf = CustomFieldBaseAllOf
  { customFieldBaseAllOfDescription :: !(Maybe Text) -- ^ "description" - [Opt In](#input-output-options). The description of the custom field.
  , customFieldBaseAllOfEnumOptions :: !(Maybe [EnumOption]) -- ^ "enum_options" - *Conditional*. Only relevant for custom fields of type &#x60;enum&#x60;. This array specifies the possible values which an &#x60;enum&#x60; custom field can adopt. To modify the enum options, refer to [working with enum options](#create-an-enum-option).
  , customFieldBaseAllOfPrecision :: !(Maybe Int) -- ^ "precision" - Only relevant for custom fields of type ‘Number’. This field dictates the number of places after the decimal to round to, i.e. 0 is integer values, 1 rounds to the nearest tenth, and so on. Must be between 0 and 6, inclusive. For percentage format, this may be unintuitive, as a value of 0.25 has a precision of 0, while a value of 0.251 has a precision of 1. This is due to 0.25 being displayed as 25%. The identifier format will always have a precision of 0.
  , customFieldBaseAllOfFormat :: !(Maybe E'Format) -- ^ "format" - The format of this custom field.
  , customFieldBaseAllOfCurrencyCode :: !(Maybe Text) -- ^ "currency_code" - ISO 4217 currency code to format this custom field. This will be null if the &#x60;format&#x60; is not &#x60;currency&#x60;.
  , customFieldBaseAllOfCustomLabel :: !(Maybe Text) -- ^ "custom_label" - This is the string that appears next to the custom field value. This will be null if the &#x60;format&#x60; is not &#x60;custom&#x60;.
  , customFieldBaseAllOfCustomLabelPosition :: !(Maybe E'CustomLabelPosition) -- ^ "custom_label_position" - Only relevant for custom fields with &#x60;custom&#x60; format. This depicts where to place the custom label. This will be null if the &#x60;format&#x60; is not &#x60;custom&#x60;.
  , customFieldBaseAllOfIsGlobalToWorkspace :: !(Maybe Bool) -- ^ "is_global_to_workspace" - This flag describes whether this custom field is available to every container in the workspace. Before project-specific custom fields, this field was always true.
  , customFieldBaseAllOfHasNotificationsEnabled :: !(Maybe Bool) -- ^ "has_notifications_enabled" - *Conditional*. This flag describes whether a follower of a task with this field should receive inbox notifications from changes to this field.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CustomFieldBaseAllOf
instance A.FromJSON CustomFieldBaseAllOf where
  parseJSON = A.withObject "CustomFieldBaseAllOf" $ \o ->
    CustomFieldBaseAllOf
      <$> (o .:? "description")
      <*> (o .:? "enum_options")
      <*> (o .:? "precision")
      <*> (o .:? "format")
      <*> (o .:? "currency_code")
      <*> (o .:? "custom_label")
      <*> (o .:? "custom_label_position")
      <*> (o .:? "is_global_to_workspace")
      <*> (o .:? "has_notifications_enabled")

-- | ToJSON CustomFieldBaseAllOf
instance A.ToJSON CustomFieldBaseAllOf where
  toJSON CustomFieldBaseAllOf {..} =
   _omitNulls
      [ "description" .= customFieldBaseAllOfDescription
      , "enum_options" .= customFieldBaseAllOfEnumOptions
      , "precision" .= customFieldBaseAllOfPrecision
      , "format" .= customFieldBaseAllOfFormat
      , "currency_code" .= customFieldBaseAllOfCurrencyCode
      , "custom_label" .= customFieldBaseAllOfCustomLabel
      , "custom_label_position" .= customFieldBaseAllOfCustomLabelPosition
      , "is_global_to_workspace" .= customFieldBaseAllOfIsGlobalToWorkspace
      , "has_notifications_enabled" .= customFieldBaseAllOfHasNotificationsEnabled
      ]


-- | Construct a value of type 'CustomFieldBaseAllOf' (by applying it's required fields, if any)
mkCustomFieldBaseAllOf
  :: CustomFieldBaseAllOf
mkCustomFieldBaseAllOf =
  CustomFieldBaseAllOf
  { customFieldBaseAllOfDescription = Nothing
  , customFieldBaseAllOfEnumOptions = Nothing
  , customFieldBaseAllOfPrecision = Nothing
  , customFieldBaseAllOfFormat = Nothing
  , customFieldBaseAllOfCurrencyCode = Nothing
  , customFieldBaseAllOfCustomLabel = Nothing
  , customFieldBaseAllOfCustomLabelPosition = Nothing
  , customFieldBaseAllOfIsGlobalToWorkspace = Nothing
  , customFieldBaseAllOfHasNotificationsEnabled = Nothing
  }

-- ** CustomFieldCompact
-- | CustomFieldCompact
data CustomFieldCompact = CustomFieldCompact
  { customFieldCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , customFieldCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , customFieldCompactName :: !(Maybe Text) -- ^ "name" - The name of the custom field.
  , customFieldCompactResourceSubtype :: !(Maybe E'ResourceSubtype) -- ^ "resource_subtype" - The type of the custom field. Must be one of the given values. 
  , customFieldCompactType :: !(Maybe E'ResourceSubtype) -- ^ "type" - *Deprecated: new integrations should prefer the resource_subtype field.* The type of the custom field. Must be one of the given values. 
  , customFieldCompactEnumOptions :: !(Maybe [EnumOption]) -- ^ "enum_options" - *Conditional*. Only relevant for custom fields of type &#x60;enum&#x60;. This array specifies the possible values which an &#x60;enum&#x60; custom field can adopt. To modify the enum options, refer to [working with enum options](#create-an-enum-option).
  , customFieldCompactEnabled :: !(Maybe Bool) -- ^ "enabled" - *Conditional*. Determines if the custom field is enabled or not.
  , customFieldCompactNumberValue :: !(Maybe Double) -- ^ "number_value" - *Conditional*. This number is the value of a number custom field.
  , customFieldCompactTextValue :: !(Maybe Text) -- ^ "text_value" - *Conditional*. This string is the value of a text custom field.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CustomFieldCompact
instance A.FromJSON CustomFieldCompact where
  parseJSON = A.withObject "CustomFieldCompact" $ \o ->
    CustomFieldCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "resource_subtype")
      <*> (o .:? "type")
      <*> (o .:? "enum_options")
      <*> (o .:? "enabled")
      <*> (o .:? "number_value")
      <*> (o .:? "text_value")

-- | ToJSON CustomFieldCompact
instance A.ToJSON CustomFieldCompact where
  toJSON CustomFieldCompact {..} =
   _omitNulls
      [ "gid" .= customFieldCompactGid
      , "resource_type" .= customFieldCompactResourceType
      , "name" .= customFieldCompactName
      , "resource_subtype" .= customFieldCompactResourceSubtype
      , "type" .= customFieldCompactType
      , "enum_options" .= customFieldCompactEnumOptions
      , "enabled" .= customFieldCompactEnabled
      , "number_value" .= customFieldCompactNumberValue
      , "text_value" .= customFieldCompactTextValue
      ]


-- | Construct a value of type 'CustomFieldCompact' (by applying it's required fields, if any)
mkCustomFieldCompact
  :: CustomFieldCompact
mkCustomFieldCompact =
  CustomFieldCompact
  { customFieldCompactGid = Nothing
  , customFieldCompactResourceType = Nothing
  , customFieldCompactName = Nothing
  , customFieldCompactResourceSubtype = Nothing
  , customFieldCompactType = Nothing
  , customFieldCompactEnumOptions = Nothing
  , customFieldCompactEnabled = Nothing
  , customFieldCompactNumberValue = Nothing
  , customFieldCompactTextValue = Nothing
  }

-- ** CustomFieldCompactAllOf
-- | CustomFieldCompactAllOf
-- Custom Fields store the metadata that is used in order to add user-specified information to tasks in Asana. Be sure to reference the [Custom Fields](#asana-custom-fields) developer documentation for more information about how custom fields relate to various resources in Asana.  Users in Asana can [lock custom fields](https://asana.com/guide/help/premium/custom-fields#gl-lock-fields), which will make them read-only when accessed by other users. Attempting to edit a locked custom field will return HTTP error code `403 Forbidden`.
data CustomFieldCompactAllOf = CustomFieldCompactAllOf
  { customFieldCompactAllOfName :: !(Maybe Text) -- ^ "name" - The name of the custom field.
  , customFieldCompactAllOfResourceSubtype :: !(Maybe E'ResourceSubtype) -- ^ "resource_subtype" - The type of the custom field. Must be one of the given values. 
  , customFieldCompactAllOfType :: !(Maybe E'ResourceSubtype) -- ^ "type" - *Deprecated: new integrations should prefer the resource_subtype field.* The type of the custom field. Must be one of the given values. 
  , customFieldCompactAllOfEnumOptions :: !(Maybe [EnumOption]) -- ^ "enum_options" - *Conditional*. Only relevant for custom fields of type &#x60;enum&#x60;. This array specifies the possible values which an &#x60;enum&#x60; custom field can adopt. To modify the enum options, refer to [working with enum options](#create-an-enum-option).
  , customFieldCompactAllOfEnabled :: !(Maybe Bool) -- ^ "enabled" - *Conditional*. Determines if the custom field is enabled or not.
  , customFieldCompactAllOfNumberValue :: !(Maybe Double) -- ^ "number_value" - *Conditional*. This number is the value of a number custom field.
  , customFieldCompactAllOfTextValue :: !(Maybe Text) -- ^ "text_value" - *Conditional*. This string is the value of a text custom field.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CustomFieldCompactAllOf
instance A.FromJSON CustomFieldCompactAllOf where
  parseJSON = A.withObject "CustomFieldCompactAllOf" $ \o ->
    CustomFieldCompactAllOf
      <$> (o .:? "name")
      <*> (o .:? "resource_subtype")
      <*> (o .:? "type")
      <*> (o .:? "enum_options")
      <*> (o .:? "enabled")
      <*> (o .:? "number_value")
      <*> (o .:? "text_value")

-- | ToJSON CustomFieldCompactAllOf
instance A.ToJSON CustomFieldCompactAllOf where
  toJSON CustomFieldCompactAllOf {..} =
   _omitNulls
      [ "name" .= customFieldCompactAllOfName
      , "resource_subtype" .= customFieldCompactAllOfResourceSubtype
      , "type" .= customFieldCompactAllOfType
      , "enum_options" .= customFieldCompactAllOfEnumOptions
      , "enabled" .= customFieldCompactAllOfEnabled
      , "number_value" .= customFieldCompactAllOfNumberValue
      , "text_value" .= customFieldCompactAllOfTextValue
      ]


-- | Construct a value of type 'CustomFieldCompactAllOf' (by applying it's required fields, if any)
mkCustomFieldCompactAllOf
  :: CustomFieldCompactAllOf
mkCustomFieldCompactAllOf =
  CustomFieldCompactAllOf
  { customFieldCompactAllOfName = Nothing
  , customFieldCompactAllOfResourceSubtype = Nothing
  , customFieldCompactAllOfType = Nothing
  , customFieldCompactAllOfEnumOptions = Nothing
  , customFieldCompactAllOfEnabled = Nothing
  , customFieldCompactAllOfNumberValue = Nothing
  , customFieldCompactAllOfTextValue = Nothing
  }

-- ** CustomFieldRequest
-- | CustomFieldRequest
data CustomFieldRequest = CustomFieldRequest
  { customFieldRequestGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , customFieldRequestResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , customFieldRequestName :: !(Maybe Text) -- ^ "name" - The name of the custom field.
  , customFieldRequestResourceSubtype :: !(Maybe E'ResourceSubtype) -- ^ "resource_subtype" - The type of the custom field. Must be one of the given values. 
  , customFieldRequestType :: !(Maybe E'ResourceSubtype) -- ^ "type" - *Deprecated: new integrations should prefer the resource_subtype field.* The type of the custom field. Must be one of the given values. 
  , customFieldRequestEnumOptions :: !(Maybe [EnumOption]) -- ^ "enum_options" - *Conditional*. Only relevant for custom fields of type &#x60;enum&#x60;. This array specifies the possible values which an &#x60;enum&#x60; custom field can adopt. To modify the enum options, refer to [working with enum options](#create-an-enum-option).
  , customFieldRequestEnabled :: !(Maybe Bool) -- ^ "enabled" - *Conditional*. Determines if the custom field is enabled or not.
  , customFieldRequestNumberValue :: !(Maybe Double) -- ^ "number_value" - *Conditional*. This number is the value of a number custom field.
  , customFieldRequestTextValue :: !(Maybe Text) -- ^ "text_value" - *Conditional*. This string is the value of a text custom field.
  , customFieldRequestDescription :: !(Maybe Text) -- ^ "description" - [Opt In](#input-output-options). The description of the custom field.
  , customFieldRequestPrecision :: !(Maybe Int) -- ^ "precision" - Only relevant for custom fields of type ‘Number’. This field dictates the number of places after the decimal to round to, i.e. 0 is integer values, 1 rounds to the nearest tenth, and so on. Must be between 0 and 6, inclusive. For percentage format, this may be unintuitive, as a value of 0.25 has a precision of 0, while a value of 0.251 has a precision of 1. This is due to 0.25 being displayed as 25%. The identifier format will always have a precision of 0.
  , customFieldRequestFormat :: !(Maybe E'Format) -- ^ "format" - The format of this custom field.
  , customFieldRequestCurrencyCode :: !(Maybe Text) -- ^ "currency_code" - ISO 4217 currency code to format this custom field. This will be null if the &#x60;format&#x60; is not &#x60;currency&#x60;.
  , customFieldRequestCustomLabel :: !(Maybe Text) -- ^ "custom_label" - This is the string that appears next to the custom field value. This will be null if the &#x60;format&#x60; is not &#x60;custom&#x60;.
  , customFieldRequestCustomLabelPosition :: !(Maybe E'CustomLabelPosition) -- ^ "custom_label_position" - Only relevant for custom fields with &#x60;custom&#x60; format. This depicts where to place the custom label. This will be null if the &#x60;format&#x60; is not &#x60;custom&#x60;.
  , customFieldRequestIsGlobalToWorkspace :: !(Maybe Bool) -- ^ "is_global_to_workspace" - This flag describes whether this custom field is available to every container in the workspace. Before project-specific custom fields, this field was always true.
  , customFieldRequestHasNotificationsEnabled :: !(Maybe Bool) -- ^ "has_notifications_enabled" - *Conditional*. This flag describes whether a follower of a task with this field should receive inbox notifications from changes to this field.
  , customFieldRequestWorkspace :: !(Text) -- ^ /Required/ "workspace" - *Create-Only* The workspace to create a custom field in.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CustomFieldRequest
instance A.FromJSON CustomFieldRequest where
  parseJSON = A.withObject "CustomFieldRequest" $ \o ->
    CustomFieldRequest
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "resource_subtype")
      <*> (o .:? "type")
      <*> (o .:? "enum_options")
      <*> (o .:? "enabled")
      <*> (o .:? "number_value")
      <*> (o .:? "text_value")
      <*> (o .:? "description")
      <*> (o .:? "precision")
      <*> (o .:? "format")
      <*> (o .:? "currency_code")
      <*> (o .:? "custom_label")
      <*> (o .:? "custom_label_position")
      <*> (o .:? "is_global_to_workspace")
      <*> (o .:? "has_notifications_enabled")
      <*> (o .:  "workspace")

-- | ToJSON CustomFieldRequest
instance A.ToJSON CustomFieldRequest where
  toJSON CustomFieldRequest {..} =
   _omitNulls
      [ "gid" .= customFieldRequestGid
      , "resource_type" .= customFieldRequestResourceType
      , "name" .= customFieldRequestName
      , "resource_subtype" .= customFieldRequestResourceSubtype
      , "type" .= customFieldRequestType
      , "enum_options" .= customFieldRequestEnumOptions
      , "enabled" .= customFieldRequestEnabled
      , "number_value" .= customFieldRequestNumberValue
      , "text_value" .= customFieldRequestTextValue
      , "description" .= customFieldRequestDescription
      , "precision" .= customFieldRequestPrecision
      , "format" .= customFieldRequestFormat
      , "currency_code" .= customFieldRequestCurrencyCode
      , "custom_label" .= customFieldRequestCustomLabel
      , "custom_label_position" .= customFieldRequestCustomLabelPosition
      , "is_global_to_workspace" .= customFieldRequestIsGlobalToWorkspace
      , "has_notifications_enabled" .= customFieldRequestHasNotificationsEnabled
      , "workspace" .= customFieldRequestWorkspace
      ]


-- | Construct a value of type 'CustomFieldRequest' (by applying it's required fields, if any)
mkCustomFieldRequest
  :: Text -- ^ 'customFieldRequestWorkspace': *Create-Only* The workspace to create a custom field in.
  -> CustomFieldRequest
mkCustomFieldRequest customFieldRequestWorkspace =
  CustomFieldRequest
  { customFieldRequestGid = Nothing
  , customFieldRequestResourceType = Nothing
  , customFieldRequestName = Nothing
  , customFieldRequestResourceSubtype = Nothing
  , customFieldRequestType = Nothing
  , customFieldRequestEnumOptions = Nothing
  , customFieldRequestEnabled = Nothing
  , customFieldRequestNumberValue = Nothing
  , customFieldRequestTextValue = Nothing
  , customFieldRequestDescription = Nothing
  , customFieldRequestPrecision = Nothing
  , customFieldRequestFormat = Nothing
  , customFieldRequestCurrencyCode = Nothing
  , customFieldRequestCustomLabel = Nothing
  , customFieldRequestCustomLabelPosition = Nothing
  , customFieldRequestIsGlobalToWorkspace = Nothing
  , customFieldRequestHasNotificationsEnabled = Nothing
  , customFieldRequestWorkspace
  }

-- ** CustomFieldRequestAllOf
-- | CustomFieldRequestAllOf
data CustomFieldRequestAllOf = CustomFieldRequestAllOf
  { customFieldRequestAllOfWorkspace :: !(Text) -- ^ /Required/ "workspace" - *Create-Only* The workspace to create a custom field in.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CustomFieldRequestAllOf
instance A.FromJSON CustomFieldRequestAllOf where
  parseJSON = A.withObject "CustomFieldRequestAllOf" $ \o ->
    CustomFieldRequestAllOf
      <$> (o .:  "workspace")

-- | ToJSON CustomFieldRequestAllOf
instance A.ToJSON CustomFieldRequestAllOf where
  toJSON CustomFieldRequestAllOf {..} =
   _omitNulls
      [ "workspace" .= customFieldRequestAllOfWorkspace
      ]


-- | Construct a value of type 'CustomFieldRequestAllOf' (by applying it's required fields, if any)
mkCustomFieldRequestAllOf
  :: Text -- ^ 'customFieldRequestAllOfWorkspace': *Create-Only* The workspace to create a custom field in.
  -> CustomFieldRequestAllOf
mkCustomFieldRequestAllOf customFieldRequestAllOfWorkspace =
  CustomFieldRequestAllOf
  { customFieldRequestAllOfWorkspace
  }

-- ** CustomFieldResponse
-- | CustomFieldResponse
data CustomFieldResponse = CustomFieldResponse
  { customFieldResponseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , customFieldResponseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , customFieldResponseName :: !(Maybe Text) -- ^ "name" - The name of the custom field.
  , customFieldResponseResourceSubtype :: !(Maybe E'ResourceSubtype) -- ^ "resource_subtype" - The type of the custom field. Must be one of the given values. 
  , customFieldResponseType :: !(Maybe E'ResourceSubtype) -- ^ "type" - *Deprecated: new integrations should prefer the resource_subtype field.* The type of the custom field. Must be one of the given values. 
  , customFieldResponseEnumOptions :: !(Maybe [EnumOption]) -- ^ "enum_options" - *Conditional*. Only relevant for custom fields of type &#x60;enum&#x60;. This array specifies the possible values which an &#x60;enum&#x60; custom field can adopt. To modify the enum options, refer to [working with enum options](#create-an-enum-option).
  , customFieldResponseEnabled :: !(Maybe Bool) -- ^ "enabled" - *Conditional*. Determines if the custom field is enabled or not.
  , customFieldResponseNumberValue :: !(Maybe Double) -- ^ "number_value" - *Conditional*. This number is the value of a number custom field.
  , customFieldResponseTextValue :: !(Maybe Text) -- ^ "text_value" - *Conditional*. This string is the value of a text custom field.
  , customFieldResponseDescription :: !(Maybe Text) -- ^ "description" - [Opt In](#input-output-options). The description of the custom field.
  , customFieldResponsePrecision :: !(Maybe Int) -- ^ "precision" - Only relevant for custom fields of type ‘Number’. This field dictates the number of places after the decimal to round to, i.e. 0 is integer values, 1 rounds to the nearest tenth, and so on. Must be between 0 and 6, inclusive. For percentage format, this may be unintuitive, as a value of 0.25 has a precision of 0, while a value of 0.251 has a precision of 1. This is due to 0.25 being displayed as 25%. The identifier format will always have a precision of 0.
  , customFieldResponseFormat :: !(Maybe E'Format) -- ^ "format" - The format of this custom field.
  , customFieldResponseCurrencyCode :: !(Maybe Text) -- ^ "currency_code" - ISO 4217 currency code to format this custom field. This will be null if the &#x60;format&#x60; is not &#x60;currency&#x60;.
  , customFieldResponseCustomLabel :: !(Maybe Text) -- ^ "custom_label" - This is the string that appears next to the custom field value. This will be null if the &#x60;format&#x60; is not &#x60;custom&#x60;.
  , customFieldResponseCustomLabelPosition :: !(Maybe E'CustomLabelPosition) -- ^ "custom_label_position" - Only relevant for custom fields with &#x60;custom&#x60; format. This depicts where to place the custom label. This will be null if the &#x60;format&#x60; is not &#x60;custom&#x60;.
  , customFieldResponseIsGlobalToWorkspace :: !(Maybe Bool) -- ^ "is_global_to_workspace" - This flag describes whether this custom field is available to every container in the workspace. Before project-specific custom fields, this field was always true.
  , customFieldResponseHasNotificationsEnabled :: !(Maybe Bool) -- ^ "has_notifications_enabled" - *Conditional*. This flag describes whether a follower of a task with this field should receive inbox notifications from changes to this field.
  , customFieldResponseEnumValue :: !(Maybe EnumOption) -- ^ "enum_value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CustomFieldResponse
instance A.FromJSON CustomFieldResponse where
  parseJSON = A.withObject "CustomFieldResponse" $ \o ->
    CustomFieldResponse
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "resource_subtype")
      <*> (o .:? "type")
      <*> (o .:? "enum_options")
      <*> (o .:? "enabled")
      <*> (o .:? "number_value")
      <*> (o .:? "text_value")
      <*> (o .:? "description")
      <*> (o .:? "precision")
      <*> (o .:? "format")
      <*> (o .:? "currency_code")
      <*> (o .:? "custom_label")
      <*> (o .:? "custom_label_position")
      <*> (o .:? "is_global_to_workspace")
      <*> (o .:? "has_notifications_enabled")
      <*> (o .:? "enum_value")

-- | ToJSON CustomFieldResponse
instance A.ToJSON CustomFieldResponse where
  toJSON CustomFieldResponse {..} =
   _omitNulls
      [ "gid" .= customFieldResponseGid
      , "resource_type" .= customFieldResponseResourceType
      , "name" .= customFieldResponseName
      , "resource_subtype" .= customFieldResponseResourceSubtype
      , "type" .= customFieldResponseType
      , "enum_options" .= customFieldResponseEnumOptions
      , "enabled" .= customFieldResponseEnabled
      , "number_value" .= customFieldResponseNumberValue
      , "text_value" .= customFieldResponseTextValue
      , "description" .= customFieldResponseDescription
      , "precision" .= customFieldResponsePrecision
      , "format" .= customFieldResponseFormat
      , "currency_code" .= customFieldResponseCurrencyCode
      , "custom_label" .= customFieldResponseCustomLabel
      , "custom_label_position" .= customFieldResponseCustomLabelPosition
      , "is_global_to_workspace" .= customFieldResponseIsGlobalToWorkspace
      , "has_notifications_enabled" .= customFieldResponseHasNotificationsEnabled
      , "enum_value" .= customFieldResponseEnumValue
      ]


-- | Construct a value of type 'CustomFieldResponse' (by applying it's required fields, if any)
mkCustomFieldResponse
  :: CustomFieldResponse
mkCustomFieldResponse =
  CustomFieldResponse
  { customFieldResponseGid = Nothing
  , customFieldResponseResourceType = Nothing
  , customFieldResponseName = Nothing
  , customFieldResponseResourceSubtype = Nothing
  , customFieldResponseType = Nothing
  , customFieldResponseEnumOptions = Nothing
  , customFieldResponseEnabled = Nothing
  , customFieldResponseNumberValue = Nothing
  , customFieldResponseTextValue = Nothing
  , customFieldResponseDescription = Nothing
  , customFieldResponsePrecision = Nothing
  , customFieldResponseFormat = Nothing
  , customFieldResponseCurrencyCode = Nothing
  , customFieldResponseCustomLabel = Nothing
  , customFieldResponseCustomLabelPosition = Nothing
  , customFieldResponseIsGlobalToWorkspace = Nothing
  , customFieldResponseHasNotificationsEnabled = Nothing
  , customFieldResponseEnumValue = Nothing
  }

-- ** CustomFieldResponseAllOf
-- | CustomFieldResponseAllOf
data CustomFieldResponseAllOf = CustomFieldResponseAllOf
  { customFieldResponseAllOfEnumValue :: !(Maybe EnumOption) -- ^ "enum_value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CustomFieldResponseAllOf
instance A.FromJSON CustomFieldResponseAllOf where
  parseJSON = A.withObject "CustomFieldResponseAllOf" $ \o ->
    CustomFieldResponseAllOf
      <$> (o .:? "enum_value")

-- | ToJSON CustomFieldResponseAllOf
instance A.ToJSON CustomFieldResponseAllOf where
  toJSON CustomFieldResponseAllOf {..} =
   _omitNulls
      [ "enum_value" .= customFieldResponseAllOfEnumValue
      ]


-- | Construct a value of type 'CustomFieldResponseAllOf' (by applying it's required fields, if any)
mkCustomFieldResponseAllOf
  :: CustomFieldResponseAllOf
mkCustomFieldResponseAllOf =
  CustomFieldResponseAllOf
  { customFieldResponseAllOfEnumValue = Nothing
  }

-- ** CustomFieldSettingBase
-- | CustomFieldSettingBase
data CustomFieldSettingBase = CustomFieldSettingBase
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CustomFieldSettingBase
instance A.FromJSON CustomFieldSettingBase where
  parseJSON = A.withObject "CustomFieldSettingBase" $ \o ->
    pure CustomFieldSettingBase
      

-- | ToJSON CustomFieldSettingBase
instance A.ToJSON CustomFieldSettingBase where
  toJSON CustomFieldSettingBase  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CustomFieldSettingBase' (by applying it's required fields, if any)
mkCustomFieldSettingBase
  :: CustomFieldSettingBase
mkCustomFieldSettingBase =
  CustomFieldSettingBase
  { 
  }

-- ** CustomFieldSettingCompact
-- | CustomFieldSettingCompact
data CustomFieldSettingCompact = CustomFieldSettingCompact
  { customFieldSettingCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , customFieldSettingCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CustomFieldSettingCompact
instance A.FromJSON CustomFieldSettingCompact where
  parseJSON = A.withObject "CustomFieldSettingCompact" $ \o ->
    CustomFieldSettingCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")

-- | ToJSON CustomFieldSettingCompact
instance A.ToJSON CustomFieldSettingCompact where
  toJSON CustomFieldSettingCompact {..} =
   _omitNulls
      [ "gid" .= customFieldSettingCompactGid
      , "resource_type" .= customFieldSettingCompactResourceType
      ]


-- | Construct a value of type 'CustomFieldSettingCompact' (by applying it's required fields, if any)
mkCustomFieldSettingCompact
  :: CustomFieldSettingCompact
mkCustomFieldSettingCompact =
  CustomFieldSettingCompact
  { customFieldSettingCompactGid = Nothing
  , customFieldSettingCompactResourceType = Nothing
  }

-- ** CustomFieldSettingResponse
-- | CustomFieldSettingResponse
data CustomFieldSettingResponse = CustomFieldSettingResponse
  { customFieldSettingResponseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , customFieldSettingResponseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , customFieldSettingResponseProject :: !(Maybe ProjectCompact) -- ^ "project"
  , customFieldSettingResponseIsImportant :: !(Maybe Bool) -- ^ "is_important" - &#x60;is_important&#x60; is used in the Asana web application to determine if this custom field is displayed in the list/grid view of a project or portfolio.
  , customFieldSettingResponseParent :: !(Maybe ProjectCompact) -- ^ "parent"
  , customFieldSettingResponseCustomField :: !(Maybe CustomFieldResponse) -- ^ "custom_field"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CustomFieldSettingResponse
instance A.FromJSON CustomFieldSettingResponse where
  parseJSON = A.withObject "CustomFieldSettingResponse" $ \o ->
    CustomFieldSettingResponse
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "project")
      <*> (o .:? "is_important")
      <*> (o .:? "parent")
      <*> (o .:? "custom_field")

-- | ToJSON CustomFieldSettingResponse
instance A.ToJSON CustomFieldSettingResponse where
  toJSON CustomFieldSettingResponse {..} =
   _omitNulls
      [ "gid" .= customFieldSettingResponseGid
      , "resource_type" .= customFieldSettingResponseResourceType
      , "project" .= customFieldSettingResponseProject
      , "is_important" .= customFieldSettingResponseIsImportant
      , "parent" .= customFieldSettingResponseParent
      , "custom_field" .= customFieldSettingResponseCustomField
      ]


-- | Construct a value of type 'CustomFieldSettingResponse' (by applying it's required fields, if any)
mkCustomFieldSettingResponse
  :: CustomFieldSettingResponse
mkCustomFieldSettingResponse =
  CustomFieldSettingResponse
  { customFieldSettingResponseGid = Nothing
  , customFieldSettingResponseResourceType = Nothing
  , customFieldSettingResponseProject = Nothing
  , customFieldSettingResponseIsImportant = Nothing
  , customFieldSettingResponseParent = Nothing
  , customFieldSettingResponseCustomField = Nothing
  }

-- ** CustomFieldSettingResponseAllOf
-- | CustomFieldSettingResponseAllOf
data CustomFieldSettingResponseAllOf = CustomFieldSettingResponseAllOf
  { customFieldSettingResponseAllOfProject :: !(Maybe ProjectCompact) -- ^ "project"
  , customFieldSettingResponseAllOfIsImportant :: !(Maybe Bool) -- ^ "is_important" - &#x60;is_important&#x60; is used in the Asana web application to determine if this custom field is displayed in the list/grid view of a project or portfolio.
  , customFieldSettingResponseAllOfParent :: !(Maybe ProjectCompact) -- ^ "parent"
  , customFieldSettingResponseAllOfCustomField :: !(Maybe CustomFieldResponse) -- ^ "custom_field"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CustomFieldSettingResponseAllOf
instance A.FromJSON CustomFieldSettingResponseAllOf where
  parseJSON = A.withObject "CustomFieldSettingResponseAllOf" $ \o ->
    CustomFieldSettingResponseAllOf
      <$> (o .:? "project")
      <*> (o .:? "is_important")
      <*> (o .:? "parent")
      <*> (o .:? "custom_field")

-- | ToJSON CustomFieldSettingResponseAllOf
instance A.ToJSON CustomFieldSettingResponseAllOf where
  toJSON CustomFieldSettingResponseAllOf {..} =
   _omitNulls
      [ "project" .= customFieldSettingResponseAllOfProject
      , "is_important" .= customFieldSettingResponseAllOfIsImportant
      , "parent" .= customFieldSettingResponseAllOfParent
      , "custom_field" .= customFieldSettingResponseAllOfCustomField
      ]


-- | Construct a value of type 'CustomFieldSettingResponseAllOf' (by applying it's required fields, if any)
mkCustomFieldSettingResponseAllOf
  :: CustomFieldSettingResponseAllOf
mkCustomFieldSettingResponseAllOf =
  CustomFieldSettingResponseAllOf
  { customFieldSettingResponseAllOfProject = Nothing
  , customFieldSettingResponseAllOfIsImportant = Nothing
  , customFieldSettingResponseAllOfParent = Nothing
  , customFieldSettingResponseAllOfCustomField = Nothing
  }

-- ** EnumOption
-- | EnumOption
data EnumOption = EnumOption
  { enumOptionGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , enumOptionResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , enumOptionName :: !(Maybe Text) -- ^ "name" - The name of the enum option.
  , enumOptionEnabled :: !(Maybe Bool) -- ^ "enabled" - The color of the enum option. Defaults to ‘none’.
  , enumOptionColor :: !(Maybe Text) -- ^ "color" - Whether or not the enum option is a selectable value for the custom field.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnumOption
instance A.FromJSON EnumOption where
  parseJSON = A.withObject "EnumOption" $ \o ->
    EnumOption
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "enabled")
      <*> (o .:? "color")

-- | ToJSON EnumOption
instance A.ToJSON EnumOption where
  toJSON EnumOption {..} =
   _omitNulls
      [ "gid" .= enumOptionGid
      , "resource_type" .= enumOptionResourceType
      , "name" .= enumOptionName
      , "enabled" .= enumOptionEnabled
      , "color" .= enumOptionColor
      ]


-- | Construct a value of type 'EnumOption' (by applying it's required fields, if any)
mkEnumOption
  :: EnumOption
mkEnumOption =
  EnumOption
  { enumOptionGid = Nothing
  , enumOptionResourceType = Nothing
  , enumOptionName = Nothing
  , enumOptionEnabled = Nothing
  , enumOptionColor = Nothing
  }

-- ** EnumOptionAllOf
-- | EnumOptionAllOf
-- Enum options are the possible values which an enum custom field can adopt. An enum custom field must contain at least 1 enum option but no more than 50.  You can add enum options to a custom field by using the `POST /custom_fields/custom_field_gid/enum_options` endpoint.  **It is not possible to remove or delete an enum option**. Instead, enum options can be disabled by updating the `enabled` field to false with the `PUT /enum_options/enum_option_gid` endpoint. Other attributes can be updated similarly.  On creation of an enum option, `enabled` is always set to `true`, meaning the enum option is a selectable value for the custom field. Setting `enabled=false` is equivalent to “trashing” the enum option in the Asana web app within the “Edit Fields” dialog. The enum option will no longer be selectable but, if the enum option value was previously set within a task, the task will retain the value.  Enum options are an ordered list and by default new enum options are inserted at the end. Ordering in relation to existing enum options can be specified on creation by using `insert_before` or `insert_after` to reference an existing enum option. Only one of `insert_before` and `insert_after` can be provided when creating a new enum option.  An enum options list can be reordered with the `POST /custom_fields/custom_field_gid/enum_options/insert` endpoint.
data EnumOptionAllOf = EnumOptionAllOf
  { enumOptionAllOfName :: !(Maybe Text) -- ^ "name" - The name of the enum option.
  , enumOptionAllOfEnabled :: !(Maybe Bool) -- ^ "enabled" - The color of the enum option. Defaults to ‘none’.
  , enumOptionAllOfColor :: !(Maybe Text) -- ^ "color" - Whether or not the enum option is a selectable value for the custom field.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnumOptionAllOf
instance A.FromJSON EnumOptionAllOf where
  parseJSON = A.withObject "EnumOptionAllOf" $ \o ->
    EnumOptionAllOf
      <$> (o .:? "name")
      <*> (o .:? "enabled")
      <*> (o .:? "color")

-- | ToJSON EnumOptionAllOf
instance A.ToJSON EnumOptionAllOf where
  toJSON EnumOptionAllOf {..} =
   _omitNulls
      [ "name" .= enumOptionAllOfName
      , "enabled" .= enumOptionAllOfEnabled
      , "color" .= enumOptionAllOfColor
      ]


-- | Construct a value of type 'EnumOptionAllOf' (by applying it's required fields, if any)
mkEnumOptionAllOf
  :: EnumOptionAllOf
mkEnumOptionAllOf =
  EnumOptionAllOf
  { enumOptionAllOfName = Nothing
  , enumOptionAllOfEnabled = Nothing
  , enumOptionAllOfColor = Nothing
  }

-- ** EnumOptionBase
-- | EnumOptionBase
data EnumOptionBase = EnumOptionBase
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnumOptionBase
instance A.FromJSON EnumOptionBase where
  parseJSON = A.withObject "EnumOptionBase" $ \o ->
    pure EnumOptionBase
      

-- | ToJSON EnumOptionBase
instance A.ToJSON EnumOptionBase where
  toJSON EnumOptionBase  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'EnumOptionBase' (by applying it's required fields, if any)
mkEnumOptionBase
  :: EnumOptionBase
mkEnumOptionBase =
  EnumOptionBase
  { 
  }

-- ** EnumOptionInsertRequest
-- | EnumOptionInsertRequest
data EnumOptionInsertRequest = EnumOptionInsertRequest
  { enumOptionInsertRequestEnumOption :: !(Text) -- ^ /Required/ "enum_option" - The gid of the enum option to relocate.
  , enumOptionInsertRequestBeforeEnumOption :: !(Maybe Text) -- ^ "before_enum_option" - An existing enum option within this custom field before which the new enum option should be inserted. Cannot be provided together with after_enum_option.
  , enumOptionInsertRequestAfterEnumOption :: !(Maybe Text) -- ^ "after_enum_option" - An existing enum option within this custom field after which the new enum option should be inserted. Cannot be provided together with before_enum_option.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnumOptionInsertRequest
instance A.FromJSON EnumOptionInsertRequest where
  parseJSON = A.withObject "EnumOptionInsertRequest" $ \o ->
    EnumOptionInsertRequest
      <$> (o .:  "enum_option")
      <*> (o .:? "before_enum_option")
      <*> (o .:? "after_enum_option")

-- | ToJSON EnumOptionInsertRequest
instance A.ToJSON EnumOptionInsertRequest where
  toJSON EnumOptionInsertRequest {..} =
   _omitNulls
      [ "enum_option" .= enumOptionInsertRequestEnumOption
      , "before_enum_option" .= enumOptionInsertRequestBeforeEnumOption
      , "after_enum_option" .= enumOptionInsertRequestAfterEnumOption
      ]


-- | Construct a value of type 'EnumOptionInsertRequest' (by applying it's required fields, if any)
mkEnumOptionInsertRequest
  :: Text -- ^ 'enumOptionInsertRequestEnumOption': The gid of the enum option to relocate.
  -> EnumOptionInsertRequest
mkEnumOptionInsertRequest enumOptionInsertRequestEnumOption =
  EnumOptionInsertRequest
  { enumOptionInsertRequestEnumOption
  , enumOptionInsertRequestBeforeEnumOption = Nothing
  , enumOptionInsertRequestAfterEnumOption = Nothing
  }

-- ** EnumOptionRequest
-- | EnumOptionRequest
data EnumOptionRequest = EnumOptionRequest
  { enumOptionRequestGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , enumOptionRequestResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , enumOptionRequestName :: !(Maybe Text) -- ^ "name" - The name of the enum option.
  , enumOptionRequestEnabled :: !(Maybe Bool) -- ^ "enabled" - The color of the enum option. Defaults to ‘none’.
  , enumOptionRequestColor :: !(Maybe Text) -- ^ "color" - Whether or not the enum option is a selectable value for the custom field.
  , enumOptionRequestInsertBefore :: !(Maybe Text) -- ^ "insert_before" - An existing enum option within this custom field before which the new enum option should be inserted. Cannot be provided together with after_enum_option.
  , enumOptionRequestInsertAfter :: !(Maybe Text) -- ^ "insert_after" - An existing enum option within this custom field after which the new enum option should be inserted. Cannot be provided together with before_enum_option.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnumOptionRequest
instance A.FromJSON EnumOptionRequest where
  parseJSON = A.withObject "EnumOptionRequest" $ \o ->
    EnumOptionRequest
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "enabled")
      <*> (o .:? "color")
      <*> (o .:? "insert_before")
      <*> (o .:? "insert_after")

-- | ToJSON EnumOptionRequest
instance A.ToJSON EnumOptionRequest where
  toJSON EnumOptionRequest {..} =
   _omitNulls
      [ "gid" .= enumOptionRequestGid
      , "resource_type" .= enumOptionRequestResourceType
      , "name" .= enumOptionRequestName
      , "enabled" .= enumOptionRequestEnabled
      , "color" .= enumOptionRequestColor
      , "insert_before" .= enumOptionRequestInsertBefore
      , "insert_after" .= enumOptionRequestInsertAfter
      ]


-- | Construct a value of type 'EnumOptionRequest' (by applying it's required fields, if any)
mkEnumOptionRequest
  :: EnumOptionRequest
mkEnumOptionRequest =
  EnumOptionRequest
  { enumOptionRequestGid = Nothing
  , enumOptionRequestResourceType = Nothing
  , enumOptionRequestName = Nothing
  , enumOptionRequestEnabled = Nothing
  , enumOptionRequestColor = Nothing
  , enumOptionRequestInsertBefore = Nothing
  , enumOptionRequestInsertAfter = Nothing
  }

-- ** EnumOptionRequestAllOf
-- | EnumOptionRequestAllOf
data EnumOptionRequestAllOf = EnumOptionRequestAllOf
  { enumOptionRequestAllOfInsertBefore :: !(Maybe Text) -- ^ "insert_before" - An existing enum option within this custom field before which the new enum option should be inserted. Cannot be provided together with after_enum_option.
  , enumOptionRequestAllOfInsertAfter :: !(Maybe Text) -- ^ "insert_after" - An existing enum option within this custom field after which the new enum option should be inserted. Cannot be provided together with before_enum_option.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnumOptionRequestAllOf
instance A.FromJSON EnumOptionRequestAllOf where
  parseJSON = A.withObject "EnumOptionRequestAllOf" $ \o ->
    EnumOptionRequestAllOf
      <$> (o .:? "insert_before")
      <*> (o .:? "insert_after")

-- | ToJSON EnumOptionRequestAllOf
instance A.ToJSON EnumOptionRequestAllOf where
  toJSON EnumOptionRequestAllOf {..} =
   _omitNulls
      [ "insert_before" .= enumOptionRequestAllOfInsertBefore
      , "insert_after" .= enumOptionRequestAllOfInsertAfter
      ]


-- | Construct a value of type 'EnumOptionRequestAllOf' (by applying it's required fields, if any)
mkEnumOptionRequestAllOf
  :: EnumOptionRequestAllOf
mkEnumOptionRequestAllOf =
  EnumOptionRequestAllOf
  { enumOptionRequestAllOfInsertBefore = Nothing
  , enumOptionRequestAllOfInsertAfter = Nothing
  }

-- ** Error
-- | Error
data Error = Error
  { errorMessage :: !(Maybe Text) -- ^ "message" - Message providing more detail about the error that occurred, if available.
  , errorHelp :: !(Maybe Text) -- ^ "help" - Additional information directing developers to resources on how to address and fix the problem, if available.
  , errorPhrase :: !(Maybe Text) -- ^ "phrase" - *500 errors only*. A unique error phrase which can be used when contacting developer support to help identify the exact occurrence of the problem in Asana’s logs.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Error
instance A.FromJSON Error where
  parseJSON = A.withObject "Error" $ \o ->
    Error
      <$> (o .:? "message")
      <*> (o .:? "help")
      <*> (o .:? "phrase")

-- | ToJSON Error
instance A.ToJSON Error where
  toJSON Error {..} =
   _omitNulls
      [ "message" .= errorMessage
      , "help" .= errorHelp
      , "phrase" .= errorPhrase
      ]


-- | Construct a value of type 'Error' (by applying it's required fields, if any)
mkError
  :: Error
mkError =
  Error
  { errorMessage = Nothing
  , errorHelp = Nothing
  , errorPhrase = Nothing
  }

-- ** ErrorResponse
-- | ErrorResponse
-- Sadly, sometimes requests to the API are not successful. Failures can occur for a wide range of reasons. In all cases, the API should return an HTTP Status Code that indicates the nature of the failure, with a response body in JSON format containing additional information.   In the event of a server error the response body will contain an error phrase. These phrases are automatically generated using the [node-asana-phrase library](https://github.com/Asana/node-asana-phrase) and can be used by Asana support to quickly look up the incident that caused the server error.
data ErrorResponse = ErrorResponse
  { errorResponseErrors :: !(Maybe [Error]) -- ^ "errors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorResponse
instance A.FromJSON ErrorResponse where
  parseJSON = A.withObject "ErrorResponse" $ \o ->
    ErrorResponse
      <$> (o .:? "errors")

-- | ToJSON ErrorResponse
instance A.ToJSON ErrorResponse where
  toJSON ErrorResponse {..} =
   _omitNulls
      [ "errors" .= errorResponseErrors
      ]


-- | Construct a value of type 'ErrorResponse' (by applying it's required fields, if any)
mkErrorResponse
  :: ErrorResponse
mkErrorResponse =
  ErrorResponse
  { errorResponseErrors = Nothing
  }

-- ** EventResponse
-- | EventResponse
-- An *event* is an object representing a change to a resource that was observed by an event subscription or delivered asynchronously to the target location of an active webhook.  The event may be triggered by a different `user` than the subscriber. For example, if user A subscribes to a task and user B modified it, the event’s user will be user B. Note: Some events are generated by the system, and will have `null` as the user. API consumers should make sure to handle this case.  The `resource` that triggered the event may be different from the one that the events were requested for or the webhook is subscribed to. For example, a subscription to a project will contain events for tasks contained within the project.  **Note:** pay close attention to the relationship between the fields `Event.action` and `Event.change.action`. `Event.action` represents the action taken on the resource itself, and `Event.change.action` represents how the information within the resource's fields have been modified.  For instance, consider these scenarios:   * When at task is added to a project, `Event.action` will be `added`, `Event.parent` will be on object with the `id` and `type` of the project, and there will be no `change` field.   * When an assignee is set on the task, `Event.parent` will be `null`, `Event.action` will be `changed`, `Event.change.action` will be `changed`, and `changed_value` will be an object with the user's `id` and `type`.   * When a collaborator is added to the task, `Event.parent` will be `null`, `Event.action` will be `changed`, `Event.change.action` will be `added`, and `added_value` will be an object with the user's `id` and `type`.
data EventResponse = EventResponse
  { eventResponseUser :: !(Maybe UserCompact) -- ^ "user"
  , eventResponseResource :: !(Maybe AsanaNamedResource) -- ^ "resource"
  , eventResponseType :: !(Maybe Text) -- ^ "type" - *Deprecated: Refer to the resource_type of the resource.* The type of the resource that generated the event.
  , eventResponseAction :: !(Maybe Text) -- ^ "action" - The type of action taken on the **resource** that triggered the event.  This can be one of &#x60;changed&#x60;, &#x60;added&#x60;, &#x60;removed&#x60;, &#x60;deleted&#x60;, or &#x60;undeleted&#x60; depending on the nature of the event.
  , eventResponseParent :: !(Maybe AsanaNamedResource) -- ^ "parent"
  , eventResponseCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The timestamp when the event occurred.
  , eventResponseChange :: !(Maybe EventResponseChange) -- ^ "change"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EventResponse
instance A.FromJSON EventResponse where
  parseJSON = A.withObject "EventResponse" $ \o ->
    EventResponse
      <$> (o .:? "user")
      <*> (o .:? "resource")
      <*> (o .:? "type")
      <*> (o .:? "action")
      <*> (o .:? "parent")
      <*> (o .:? "created_at")
      <*> (o .:? "change")

-- | ToJSON EventResponse
instance A.ToJSON EventResponse where
  toJSON EventResponse {..} =
   _omitNulls
      [ "user" .= eventResponseUser
      , "resource" .= eventResponseResource
      , "type" .= eventResponseType
      , "action" .= eventResponseAction
      , "parent" .= eventResponseParent
      , "created_at" .= eventResponseCreatedAt
      , "change" .= eventResponseChange
      ]


-- | Construct a value of type 'EventResponse' (by applying it's required fields, if any)
mkEventResponse
  :: EventResponse
mkEventResponse =
  EventResponse
  { eventResponseUser = Nothing
  , eventResponseResource = Nothing
  , eventResponseType = Nothing
  , eventResponseAction = Nothing
  , eventResponseParent = Nothing
  , eventResponseCreatedAt = Nothing
  , eventResponseChange = Nothing
  }

-- ** EventResponseChange
-- | EventResponseChange
-- Information about the type of change that has occurred. This field is only present when the value of the property `action`, describing the action taken on the **resource**, is `changed`.
data EventResponseChange = EventResponseChange
  { eventResponseChangeField :: !(Maybe Text) -- ^ "field" - The name of the field that has changed in the resource.
  , eventResponseChangeAction :: !(Maybe Text) -- ^ "action" - The type of action taken on the **field** which has been changed.  This can be one of &#x60;changed&#x60;, &#x60;added&#x60;, or &#x60;removed&#x60; depending on the nature of the change.
  , eventResponseChangeNewValue :: !(Maybe A.Value) -- ^ "new_value" - *Conditional.* This property is only present when the **field&#39;s** &#x60;action&#x60; is &#x60;changed&#x60; and the &#x60;new_value&#x60; is an Asana resource. This will be only the &#x60;gid&#x60; and &#x60;resource_type&#x60; of the resource when the events come from webhooks; this will be the compact representation (and can have fields expanded with [opt_fields](#input-output-options)) when using the [Events](#asana-events) resource.
  , eventResponseChangeAddedValue :: !(Maybe A.Value) -- ^ "added_value" - *Conditional.* This property is only present when the **field&#39;s** &#x60;action&#x60; is &#x60;added&#x60; and the &#x60;added_value&#x60; is an Asana resource. This will be only the &#x60;gid&#x60; and &#x60;resource_type&#x60; of the resource when the events come from webhooks; this will be the compact representation (and can have fields expanded with [opt_fields](#input-output-options)) when using the [Events](#asana-events) resource.
  , eventResponseChangeRemovedValue :: !(Maybe A.Value) -- ^ "removed_value" - *Conditional.* This property is only present when the **field&#39;s** &#x60;action&#x60; is &#x60;removed&#x60; and the &#x60;removed_value&#x60; is an Asana resource. This will be only the &#x60;gid&#x60; and &#x60;resource_type&#x60; of the resource when the events come from webhooks; this will be the compact representation (and can have fields expanded with [opt_fields](#input-output-options)) when using the [Events](#asana-events) resource. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EventResponseChange
instance A.FromJSON EventResponseChange where
  parseJSON = A.withObject "EventResponseChange" $ \o ->
    EventResponseChange
      <$> (o .:? "field")
      <*> (o .:? "action")
      <*> (o .:? "new_value")
      <*> (o .:? "added_value")
      <*> (o .:? "removed_value")

-- | ToJSON EventResponseChange
instance A.ToJSON EventResponseChange where
  toJSON EventResponseChange {..} =
   _omitNulls
      [ "field" .= eventResponseChangeField
      , "action" .= eventResponseChangeAction
      , "new_value" .= eventResponseChangeNewValue
      , "added_value" .= eventResponseChangeAddedValue
      , "removed_value" .= eventResponseChangeRemovedValue
      ]


-- | Construct a value of type 'EventResponseChange' (by applying it's required fields, if any)
mkEventResponseChange
  :: EventResponseChange
mkEventResponseChange =
  EventResponseChange
  { eventResponseChangeField = Nothing
  , eventResponseChangeAction = Nothing
  , eventResponseChangeNewValue = Nothing
  , eventResponseChangeAddedValue = Nothing
  , eventResponseChangeRemovedValue = Nothing
  }

-- ** InlineObject
-- | InlineObject
data InlineObject = InlineObject
  { inlineObjectData :: !(Maybe BatchRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject
instance A.FromJSON InlineObject where
  parseJSON = A.withObject "InlineObject" $ \o ->
    InlineObject
      <$> (o .:? "data")

-- | ToJSON InlineObject
instance A.ToJSON InlineObject where
  toJSON InlineObject {..} =
   _omitNulls
      [ "data" .= inlineObjectData
      ]


-- | Construct a value of type 'InlineObject' (by applying it's required fields, if any)
mkInlineObject
  :: InlineObject
mkInlineObject =
  InlineObject
  { inlineObjectData = Nothing
  }

-- ** InlineObject1
-- | InlineObject1
data InlineObject1 = InlineObject1
  { inlineObject1Data :: !(Maybe CustomFieldRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject1
instance A.FromJSON InlineObject1 where
  parseJSON = A.withObject "InlineObject1" $ \o ->
    InlineObject1
      <$> (o .:? "data")

-- | ToJSON InlineObject1
instance A.ToJSON InlineObject1 where
  toJSON InlineObject1 {..} =
   _omitNulls
      [ "data" .= inlineObject1Data
      ]


-- | Construct a value of type 'InlineObject1' (by applying it's required fields, if any)
mkInlineObject1
  :: InlineObject1
mkInlineObject1 =
  InlineObject1
  { inlineObject1Data = Nothing
  }

-- ** InlineObject10
-- | InlineObject10
data InlineObject10 = InlineObject10
  { inlineObject10Data :: !(Maybe PortfolioRemoveItemRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject10
instance A.FromJSON InlineObject10 where
  parseJSON = A.withObject "InlineObject10" $ \o ->
    InlineObject10
      <$> (o .:? "data")

-- | ToJSON InlineObject10
instance A.ToJSON InlineObject10 where
  toJSON InlineObject10 {..} =
   _omitNulls
      [ "data" .= inlineObject10Data
      ]


-- | Construct a value of type 'InlineObject10' (by applying it's required fields, if any)
mkInlineObject10
  :: InlineObject10
mkInlineObject10 =
  InlineObject10
  { inlineObject10Data = Nothing
  }

-- ** InlineObject11
-- | InlineObject11
data InlineObject11 = InlineObject11
  { inlineObject11Data :: !(Maybe AddCustomFieldSettingRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject11
instance A.FromJSON InlineObject11 where
  parseJSON = A.withObject "InlineObject11" $ \o ->
    InlineObject11
      <$> (o .:? "data")

-- | ToJSON InlineObject11
instance A.ToJSON InlineObject11 where
  toJSON InlineObject11 {..} =
   _omitNulls
      [ "data" .= inlineObject11Data
      ]


-- | Construct a value of type 'InlineObject11' (by applying it's required fields, if any)
mkInlineObject11
  :: InlineObject11
mkInlineObject11 =
  InlineObject11
  { inlineObject11Data = Nothing
  }

-- ** InlineObject12
-- | InlineObject12
data InlineObject12 = InlineObject12
  { inlineObject12Data :: !(Maybe RemoveCustomFieldSettingRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject12
instance A.FromJSON InlineObject12 where
  parseJSON = A.withObject "InlineObject12" $ \o ->
    InlineObject12
      <$> (o .:? "data")

-- | ToJSON InlineObject12
instance A.ToJSON InlineObject12 where
  toJSON InlineObject12 {..} =
   _omitNulls
      [ "data" .= inlineObject12Data
      ]


-- | Construct a value of type 'InlineObject12' (by applying it's required fields, if any)
mkInlineObject12
  :: InlineObject12
mkInlineObject12 =
  InlineObject12
  { inlineObject12Data = Nothing
  }

-- ** InlineObject13
-- | InlineObject13
data InlineObject13 = InlineObject13
  { inlineObject13Data :: !(Maybe AddMembersRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject13
instance A.FromJSON InlineObject13 where
  parseJSON = A.withObject "InlineObject13" $ \o ->
    InlineObject13
      <$> (o .:? "data")

-- | ToJSON InlineObject13
instance A.ToJSON InlineObject13 where
  toJSON InlineObject13 {..} =
   _omitNulls
      [ "data" .= inlineObject13Data
      ]


-- | Construct a value of type 'InlineObject13' (by applying it's required fields, if any)
mkInlineObject13
  :: InlineObject13
mkInlineObject13 =
  InlineObject13
  { inlineObject13Data = Nothing
  }

-- ** InlineObject14
-- | InlineObject14
data InlineObject14 = InlineObject14
  { inlineObject14Data :: !(Maybe RemoveMembersRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject14
instance A.FromJSON InlineObject14 where
  parseJSON = A.withObject "InlineObject14" $ \o ->
    InlineObject14
      <$> (o .:? "data")

-- | ToJSON InlineObject14
instance A.ToJSON InlineObject14 where
  toJSON InlineObject14 {..} =
   _omitNulls
      [ "data" .= inlineObject14Data
      ]


-- | Construct a value of type 'InlineObject14' (by applying it's required fields, if any)
mkInlineObject14
  :: InlineObject14
mkInlineObject14 =
  InlineObject14
  { inlineObject14Data = Nothing
  }

-- ** InlineObject15
-- | InlineObject15
data InlineObject15 = InlineObject15
  { inlineObject15Data :: !(Maybe ProjectStatusBase) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject15
instance A.FromJSON InlineObject15 where
  parseJSON = A.withObject "InlineObject15" $ \o ->
    InlineObject15
      <$> (o .:? "data")

-- | ToJSON InlineObject15
instance A.ToJSON InlineObject15 where
  toJSON InlineObject15 {..} =
   _omitNulls
      [ "data" .= inlineObject15Data
      ]


-- | Construct a value of type 'InlineObject15' (by applying it's required fields, if any)
mkInlineObject15
  :: InlineObject15
mkInlineObject15 =
  InlineObject15
  { inlineObject15Data = Nothing
  }

-- ** InlineObject16
-- | InlineObject16
data InlineObject16 = InlineObject16
  { inlineObject16Data :: !(Maybe ProjectRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject16
instance A.FromJSON InlineObject16 where
  parseJSON = A.withObject "InlineObject16" $ \o ->
    InlineObject16
      <$> (o .:? "data")

-- | ToJSON InlineObject16
instance A.ToJSON InlineObject16 where
  toJSON InlineObject16 {..} =
   _omitNulls
      [ "data" .= inlineObject16Data
      ]


-- | Construct a value of type 'InlineObject16' (by applying it's required fields, if any)
mkInlineObject16
  :: InlineObject16
mkInlineObject16 =
  InlineObject16
  { inlineObject16Data = Nothing
  }

-- ** InlineObject17
-- | InlineObject17
data InlineObject17 = InlineObject17
  { inlineObject17Data :: !(Maybe ProjectRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject17
instance A.FromJSON InlineObject17 where
  parseJSON = A.withObject "InlineObject17" $ \o ->
    InlineObject17
      <$> (o .:? "data")

-- | ToJSON InlineObject17
instance A.ToJSON InlineObject17 where
  toJSON InlineObject17 {..} =
   _omitNulls
      [ "data" .= inlineObject17Data
      ]


-- | Construct a value of type 'InlineObject17' (by applying it's required fields, if any)
mkInlineObject17
  :: InlineObject17
mkInlineObject17 =
  InlineObject17
  { inlineObject17Data = Nothing
  }

-- ** InlineObject18
-- | InlineObject18
data InlineObject18 = InlineObject18
  { inlineObject18Data :: !(Maybe ProjectDuplicateRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject18
instance A.FromJSON InlineObject18 where
  parseJSON = A.withObject "InlineObject18" $ \o ->
    InlineObject18
      <$> (o .:? "data")

-- | ToJSON InlineObject18
instance A.ToJSON InlineObject18 where
  toJSON InlineObject18 {..} =
   _omitNulls
      [ "data" .= inlineObject18Data
      ]


-- | Construct a value of type 'InlineObject18' (by applying it's required fields, if any)
mkInlineObject18
  :: InlineObject18
mkInlineObject18 =
  InlineObject18
  { inlineObject18Data = Nothing
  }

-- ** InlineObject19
-- | InlineObject19
data InlineObject19 = InlineObject19
  { inlineObject19Data :: !(Maybe ProjectRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject19
instance A.FromJSON InlineObject19 where
  parseJSON = A.withObject "InlineObject19" $ \o ->
    InlineObject19
      <$> (o .:? "data")

-- | ToJSON InlineObject19
instance A.ToJSON InlineObject19 where
  toJSON InlineObject19 {..} =
   _omitNulls
      [ "data" .= inlineObject19Data
      ]


-- | Construct a value of type 'InlineObject19' (by applying it's required fields, if any)
mkInlineObject19
  :: InlineObject19
mkInlineObject19 =
  InlineObject19
  { inlineObject19Data = Nothing
  }

-- ** InlineObject2
-- | InlineObject2
data InlineObject2 = InlineObject2
  { inlineObject2Data :: !(Maybe CustomFieldRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject2
instance A.FromJSON InlineObject2 where
  parseJSON = A.withObject "InlineObject2" $ \o ->
    InlineObject2
      <$> (o .:? "data")

-- | ToJSON InlineObject2
instance A.ToJSON InlineObject2 where
  toJSON InlineObject2 {..} =
   _omitNulls
      [ "data" .= inlineObject2Data
      ]


-- | Construct a value of type 'InlineObject2' (by applying it's required fields, if any)
mkInlineObject2
  :: InlineObject2
mkInlineObject2 =
  InlineObject2
  { inlineObject2Data = Nothing
  }

-- ** InlineObject20
-- | InlineObject20
data InlineObject20 = InlineObject20
  { inlineObject20Data :: !(Maybe ProjectRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject20
instance A.FromJSON InlineObject20 where
  parseJSON = A.withObject "InlineObject20" $ \o ->
    InlineObject20
      <$> (o .:? "data")

-- | ToJSON InlineObject20
instance A.ToJSON InlineObject20 where
  toJSON InlineObject20 {..} =
   _omitNulls
      [ "data" .= inlineObject20Data
      ]


-- | Construct a value of type 'InlineObject20' (by applying it's required fields, if any)
mkInlineObject20
  :: InlineObject20
mkInlineObject20 =
  InlineObject20
  { inlineObject20Data = Nothing
  }

-- ** InlineObject21
-- | InlineObject21
data InlineObject21 = InlineObject21
  { inlineObject21Data :: !(Maybe AddCustomFieldSettingRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject21
instance A.FromJSON InlineObject21 where
  parseJSON = A.withObject "InlineObject21" $ \o ->
    InlineObject21
      <$> (o .:? "data")

-- | ToJSON InlineObject21
instance A.ToJSON InlineObject21 where
  toJSON InlineObject21 {..} =
   _omitNulls
      [ "data" .= inlineObject21Data
      ]


-- | Construct a value of type 'InlineObject21' (by applying it's required fields, if any)
mkInlineObject21
  :: InlineObject21
mkInlineObject21 =
  InlineObject21
  { inlineObject21Data = Nothing
  }

-- ** InlineObject22
-- | InlineObject22
data InlineObject22 = InlineObject22
  { inlineObject22Data :: !(Maybe RemoveCustomFieldSettingRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject22
instance A.FromJSON InlineObject22 where
  parseJSON = A.withObject "InlineObject22" $ \o ->
    InlineObject22
      <$> (o .:? "data")

-- | ToJSON InlineObject22
instance A.ToJSON InlineObject22 where
  toJSON InlineObject22 {..} =
   _omitNulls
      [ "data" .= inlineObject22Data
      ]


-- | Construct a value of type 'InlineObject22' (by applying it's required fields, if any)
mkInlineObject22
  :: InlineObject22
mkInlineObject22 =
  InlineObject22
  { inlineObject22Data = Nothing
  }

-- ** InlineObject23
-- | InlineObject23
data InlineObject23 = InlineObject23
  { inlineObject23Data :: !(Maybe AddMembersRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject23
instance A.FromJSON InlineObject23 where
  parseJSON = A.withObject "InlineObject23" $ \o ->
    InlineObject23
      <$> (o .:? "data")

-- | ToJSON InlineObject23
instance A.ToJSON InlineObject23 where
  toJSON InlineObject23 {..} =
   _omitNulls
      [ "data" .= inlineObject23Data
      ]


-- | Construct a value of type 'InlineObject23' (by applying it's required fields, if any)
mkInlineObject23
  :: InlineObject23
mkInlineObject23 =
  InlineObject23
  { inlineObject23Data = Nothing
  }

-- ** InlineObject24
-- | InlineObject24
data InlineObject24 = InlineObject24
  { inlineObject24Data :: !(Maybe RemoveMembersRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject24
instance A.FromJSON InlineObject24 where
  parseJSON = A.withObject "InlineObject24" $ \o ->
    InlineObject24
      <$> (o .:? "data")

-- | ToJSON InlineObject24
instance A.ToJSON InlineObject24 where
  toJSON InlineObject24 {..} =
   _omitNulls
      [ "data" .= inlineObject24Data
      ]


-- | Construct a value of type 'InlineObject24' (by applying it's required fields, if any)
mkInlineObject24
  :: InlineObject24
mkInlineObject24 =
  InlineObject24
  { inlineObject24Data = Nothing
  }

-- ** InlineObject25
-- | InlineObject25
data InlineObject25 = InlineObject25
  { inlineObject25Data :: !(Maybe AddFollowersRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject25
instance A.FromJSON InlineObject25 where
  parseJSON = A.withObject "InlineObject25" $ \o ->
    InlineObject25
      <$> (o .:? "data")

-- | ToJSON InlineObject25
instance A.ToJSON InlineObject25 where
  toJSON InlineObject25 {..} =
   _omitNulls
      [ "data" .= inlineObject25Data
      ]


-- | Construct a value of type 'InlineObject25' (by applying it's required fields, if any)
mkInlineObject25
  :: InlineObject25
mkInlineObject25 =
  InlineObject25
  { inlineObject25Data = Nothing
  }

-- ** InlineObject26
-- | InlineObject26
data InlineObject26 = InlineObject26
  { inlineObject26Data :: !(Maybe RemoveFollowersRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject26
instance A.FromJSON InlineObject26 where
  parseJSON = A.withObject "InlineObject26" $ \o ->
    InlineObject26
      <$> (o .:? "data")

-- | ToJSON InlineObject26
instance A.ToJSON InlineObject26 where
  toJSON InlineObject26 {..} =
   _omitNulls
      [ "data" .= inlineObject26Data
      ]


-- | Construct a value of type 'InlineObject26' (by applying it's required fields, if any)
mkInlineObject26
  :: InlineObject26
mkInlineObject26 =
  InlineObject26
  { inlineObject26Data = Nothing
  }

-- ** InlineObject27
-- | InlineObject27
data InlineObject27 = InlineObject27
  { inlineObject27Data :: !(Maybe SectionRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject27
instance A.FromJSON InlineObject27 where
  parseJSON = A.withObject "InlineObject27" $ \o ->
    InlineObject27
      <$> (o .:? "data")

-- | ToJSON InlineObject27
instance A.ToJSON InlineObject27 where
  toJSON InlineObject27 {..} =
   _omitNulls
      [ "data" .= inlineObject27Data
      ]


-- | Construct a value of type 'InlineObject27' (by applying it's required fields, if any)
mkInlineObject27
  :: InlineObject27
mkInlineObject27 =
  InlineObject27
  { inlineObject27Data = Nothing
  }

-- ** InlineObject28
-- | InlineObject28
data InlineObject28 = InlineObject28
  { inlineObject28Data :: !(Maybe SectionRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject28
instance A.FromJSON InlineObject28 where
  parseJSON = A.withObject "InlineObject28" $ \o ->
    InlineObject28
      <$> (o .:? "data")

-- | ToJSON InlineObject28
instance A.ToJSON InlineObject28 where
  toJSON InlineObject28 {..} =
   _omitNulls
      [ "data" .= inlineObject28Data
      ]


-- | Construct a value of type 'InlineObject28' (by applying it's required fields, if any)
mkInlineObject28
  :: InlineObject28
mkInlineObject28 =
  InlineObject28
  { inlineObject28Data = Nothing
  }

-- ** InlineObject29
-- | InlineObject29
data InlineObject29 = InlineObject29
  { inlineObject29Data :: !(Maybe SectionTaskInsertRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject29
instance A.FromJSON InlineObject29 where
  parseJSON = A.withObject "InlineObject29" $ \o ->
    InlineObject29
      <$> (o .:? "data")

-- | ToJSON InlineObject29
instance A.ToJSON InlineObject29 where
  toJSON InlineObject29 {..} =
   _omitNulls
      [ "data" .= inlineObject29Data
      ]


-- | Construct a value of type 'InlineObject29' (by applying it's required fields, if any)
mkInlineObject29
  :: InlineObject29
mkInlineObject29 =
  InlineObject29
  { inlineObject29Data = Nothing
  }

-- ** InlineObject3
-- | InlineObject3
data InlineObject3 = InlineObject3
  { inlineObject3Data :: !(Maybe EnumOptionRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject3
instance A.FromJSON InlineObject3 where
  parseJSON = A.withObject "InlineObject3" $ \o ->
    InlineObject3
      <$> (o .:? "data")

-- | ToJSON InlineObject3
instance A.ToJSON InlineObject3 where
  toJSON InlineObject3 {..} =
   _omitNulls
      [ "data" .= inlineObject3Data
      ]


-- | Construct a value of type 'InlineObject3' (by applying it's required fields, if any)
mkInlineObject3
  :: InlineObject3
mkInlineObject3 =
  InlineObject3
  { inlineObject3Data = Nothing
  }

-- ** InlineObject30
-- | InlineObject30
data InlineObject30 = InlineObject30
  { inlineObject30Data :: !(Maybe ProjectSectionInsertRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject30
instance A.FromJSON InlineObject30 where
  parseJSON = A.withObject "InlineObject30" $ \o ->
    InlineObject30
      <$> (o .:? "data")

-- | ToJSON InlineObject30
instance A.ToJSON InlineObject30 where
  toJSON InlineObject30 {..} =
   _omitNulls
      [ "data" .= inlineObject30Data
      ]


-- | Construct a value of type 'InlineObject30' (by applying it's required fields, if any)
mkInlineObject30
  :: InlineObject30
mkInlineObject30 =
  InlineObject30
  { inlineObject30Data = Nothing
  }

-- ** InlineObject31
-- | InlineObject31
data InlineObject31 = InlineObject31
  { inlineObject31Data :: !(Maybe StoryBase) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject31
instance A.FromJSON InlineObject31 where
  parseJSON = A.withObject "InlineObject31" $ \o ->
    InlineObject31
      <$> (o .:? "data")

-- | ToJSON InlineObject31
instance A.ToJSON InlineObject31 where
  toJSON InlineObject31 {..} =
   _omitNulls
      [ "data" .= inlineObject31Data
      ]


-- | Construct a value of type 'InlineObject31' (by applying it's required fields, if any)
mkInlineObject31
  :: InlineObject31
mkInlineObject31 =
  InlineObject31
  { inlineObject31Data = Nothing
  }

-- ** InlineObject32
-- | InlineObject32
data InlineObject32 = InlineObject32
  { inlineObject32Data :: !(Maybe StoryBase) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject32
instance A.FromJSON InlineObject32 where
  parseJSON = A.withObject "InlineObject32" $ \o ->
    InlineObject32
      <$> (o .:? "data")

-- | ToJSON InlineObject32
instance A.ToJSON InlineObject32 where
  toJSON InlineObject32 {..} =
   _omitNulls
      [ "data" .= inlineObject32Data
      ]


-- | Construct a value of type 'InlineObject32' (by applying it's required fields, if any)
mkInlineObject32
  :: InlineObject32
mkInlineObject32 =
  InlineObject32
  { inlineObject32Data = Nothing
  }

-- ** InlineObject33
-- | InlineObject33
data InlineObject33 = InlineObject33
  { inlineObject33Data :: !(Maybe TagRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject33
instance A.FromJSON InlineObject33 where
  parseJSON = A.withObject "InlineObject33" $ \o ->
    InlineObject33
      <$> (o .:? "data")

-- | ToJSON InlineObject33
instance A.ToJSON InlineObject33 where
  toJSON InlineObject33 {..} =
   _omitNulls
      [ "data" .= inlineObject33Data
      ]


-- | Construct a value of type 'InlineObject33' (by applying it's required fields, if any)
mkInlineObject33
  :: InlineObject33
mkInlineObject33 =
  InlineObject33
  { inlineObject33Data = Nothing
  }

-- ** InlineObject34
-- | InlineObject34
data InlineObject34 = InlineObject34
  { inlineObject34Data :: !(Maybe TagResponse) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject34
instance A.FromJSON InlineObject34 where
  parseJSON = A.withObject "InlineObject34" $ \o ->
    InlineObject34
      <$> (o .:? "data")

-- | ToJSON InlineObject34
instance A.ToJSON InlineObject34 where
  toJSON InlineObject34 {..} =
   _omitNulls
      [ "data" .= inlineObject34Data
      ]


-- | Construct a value of type 'InlineObject34' (by applying it's required fields, if any)
mkInlineObject34
  :: InlineObject34
mkInlineObject34 =
  InlineObject34
  { inlineObject34Data = Nothing
  }

-- ** InlineObject35
-- | InlineObject35
data InlineObject35 = InlineObject35
  { inlineObject35Data :: !(Maybe TaskRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject35
instance A.FromJSON InlineObject35 where
  parseJSON = A.withObject "InlineObject35" $ \o ->
    InlineObject35
      <$> (o .:? "data")

-- | ToJSON InlineObject35
instance A.ToJSON InlineObject35 where
  toJSON InlineObject35 {..} =
   _omitNulls
      [ "data" .= inlineObject35Data
      ]


-- | Construct a value of type 'InlineObject35' (by applying it's required fields, if any)
mkInlineObject35
  :: InlineObject35
mkInlineObject35 =
  InlineObject35
  { inlineObject35Data = Nothing
  }

-- ** InlineObject36
-- | InlineObject36
data InlineObject36 = InlineObject36
  { inlineObject36Data :: !(Maybe TaskRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject36
instance A.FromJSON InlineObject36 where
  parseJSON = A.withObject "InlineObject36" $ \o ->
    InlineObject36
      <$> (o .:? "data")

-- | ToJSON InlineObject36
instance A.ToJSON InlineObject36 where
  toJSON InlineObject36 {..} =
   _omitNulls
      [ "data" .= inlineObject36Data
      ]


-- | Construct a value of type 'InlineObject36' (by applying it's required fields, if any)
mkInlineObject36
  :: InlineObject36
mkInlineObject36 =
  InlineObject36
  { inlineObject36Data = Nothing
  }

-- ** InlineObject37
-- | InlineObject37
data InlineObject37 = InlineObject37
  { inlineObject37Data :: !(Maybe TaskDuplicateRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject37
instance A.FromJSON InlineObject37 where
  parseJSON = A.withObject "InlineObject37" $ \o ->
    InlineObject37
      <$> (o .:? "data")

-- | ToJSON InlineObject37
instance A.ToJSON InlineObject37 where
  toJSON InlineObject37 {..} =
   _omitNulls
      [ "data" .= inlineObject37Data
      ]


-- | Construct a value of type 'InlineObject37' (by applying it's required fields, if any)
mkInlineObject37
  :: InlineObject37
mkInlineObject37 =
  InlineObject37
  { inlineObject37Data = Nothing
  }

-- ** InlineObject38
-- | InlineObject38
data InlineObject38 = InlineObject38
  { inlineObject38Data :: !(Maybe TaskRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject38
instance A.FromJSON InlineObject38 where
  parseJSON = A.withObject "InlineObject38" $ \o ->
    InlineObject38
      <$> (o .:? "data")

-- | ToJSON InlineObject38
instance A.ToJSON InlineObject38 where
  toJSON InlineObject38 {..} =
   _omitNulls
      [ "data" .= inlineObject38Data
      ]


-- | Construct a value of type 'InlineObject38' (by applying it's required fields, if any)
mkInlineObject38
  :: InlineObject38
mkInlineObject38 =
  InlineObject38
  { inlineObject38Data = Nothing
  }

-- ** InlineObject39
-- | InlineObject39
data InlineObject39 = InlineObject39
  { inlineObject39Data :: !(Maybe TaskSetParentRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject39
instance A.FromJSON InlineObject39 where
  parseJSON = A.withObject "InlineObject39" $ \o ->
    InlineObject39
      <$> (o .:? "data")

-- | ToJSON InlineObject39
instance A.ToJSON InlineObject39 where
  toJSON InlineObject39 {..} =
   _omitNulls
      [ "data" .= inlineObject39Data
      ]


-- | Construct a value of type 'InlineObject39' (by applying it's required fields, if any)
mkInlineObject39
  :: InlineObject39
mkInlineObject39 =
  InlineObject39
  { inlineObject39Data = Nothing
  }

-- ** InlineObject4
-- | InlineObject4
data InlineObject4 = InlineObject4
  { inlineObject4Data :: !(Maybe EnumOptionInsertRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject4
instance A.FromJSON InlineObject4 where
  parseJSON = A.withObject "InlineObject4" $ \o ->
    InlineObject4
      <$> (o .:? "data")

-- | ToJSON InlineObject4
instance A.ToJSON InlineObject4 where
  toJSON InlineObject4 {..} =
   _omitNulls
      [ "data" .= inlineObject4Data
      ]


-- | Construct a value of type 'InlineObject4' (by applying it's required fields, if any)
mkInlineObject4
  :: InlineObject4
mkInlineObject4 =
  InlineObject4
  { inlineObject4Data = Nothing
  }

-- ** InlineObject40
-- | InlineObject40
data InlineObject40 = InlineObject40
  { inlineObject40Data :: !(Maybe ModifyDependenciesRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject40
instance A.FromJSON InlineObject40 where
  parseJSON = A.withObject "InlineObject40" $ \o ->
    InlineObject40
      <$> (o .:? "data")

-- | ToJSON InlineObject40
instance A.ToJSON InlineObject40 where
  toJSON InlineObject40 {..} =
   _omitNulls
      [ "data" .= inlineObject40Data
      ]


-- | Construct a value of type 'InlineObject40' (by applying it's required fields, if any)
mkInlineObject40
  :: InlineObject40
mkInlineObject40 =
  InlineObject40
  { inlineObject40Data = Nothing
  }

-- ** InlineObject41
-- | InlineObject41
data InlineObject41 = InlineObject41
  { inlineObject41Data :: !(Maybe ModifyDependenciesRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject41
instance A.FromJSON InlineObject41 where
  parseJSON = A.withObject "InlineObject41" $ \o ->
    InlineObject41
      <$> (o .:? "data")

-- | ToJSON InlineObject41
instance A.ToJSON InlineObject41 where
  toJSON InlineObject41 {..} =
   _omitNulls
      [ "data" .= inlineObject41Data
      ]


-- | Construct a value of type 'InlineObject41' (by applying it's required fields, if any)
mkInlineObject41
  :: InlineObject41
mkInlineObject41 =
  InlineObject41
  { inlineObject41Data = Nothing
  }

-- ** InlineObject42
-- | InlineObject42
data InlineObject42 = InlineObject42
  { inlineObject42Data :: !(Maybe ModifyDependentsRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject42
instance A.FromJSON InlineObject42 where
  parseJSON = A.withObject "InlineObject42" $ \o ->
    InlineObject42
      <$> (o .:? "data")

-- | ToJSON InlineObject42
instance A.ToJSON InlineObject42 where
  toJSON InlineObject42 {..} =
   _omitNulls
      [ "data" .= inlineObject42Data
      ]


-- | Construct a value of type 'InlineObject42' (by applying it's required fields, if any)
mkInlineObject42
  :: InlineObject42
mkInlineObject42 =
  InlineObject42
  { inlineObject42Data = Nothing
  }

-- ** InlineObject43
-- | InlineObject43
data InlineObject43 = InlineObject43
  { inlineObject43Data :: !(Maybe ModifyDependentsRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject43
instance A.FromJSON InlineObject43 where
  parseJSON = A.withObject "InlineObject43" $ \o ->
    InlineObject43
      <$> (o .:? "data")

-- | ToJSON InlineObject43
instance A.ToJSON InlineObject43 where
  toJSON InlineObject43 {..} =
   _omitNulls
      [ "data" .= inlineObject43Data
      ]


-- | Construct a value of type 'InlineObject43' (by applying it's required fields, if any)
mkInlineObject43
  :: InlineObject43
mkInlineObject43 =
  InlineObject43
  { inlineObject43Data = Nothing
  }

-- ** InlineObject44
-- | InlineObject44
data InlineObject44 = InlineObject44
  { inlineObject44Data :: !(Maybe TaskAddProjectRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject44
instance A.FromJSON InlineObject44 where
  parseJSON = A.withObject "InlineObject44" $ \o ->
    InlineObject44
      <$> (o .:? "data")

-- | ToJSON InlineObject44
instance A.ToJSON InlineObject44 where
  toJSON InlineObject44 {..} =
   _omitNulls
      [ "data" .= inlineObject44Data
      ]


-- | Construct a value of type 'InlineObject44' (by applying it's required fields, if any)
mkInlineObject44
  :: InlineObject44
mkInlineObject44 =
  InlineObject44
  { inlineObject44Data = Nothing
  }

-- ** InlineObject45
-- | InlineObject45
data InlineObject45 = InlineObject45
  { inlineObject45Data :: !(Maybe TaskRemoveProjectRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject45
instance A.FromJSON InlineObject45 where
  parseJSON = A.withObject "InlineObject45" $ \o ->
    InlineObject45
      <$> (o .:? "data")

-- | ToJSON InlineObject45
instance A.ToJSON InlineObject45 where
  toJSON InlineObject45 {..} =
   _omitNulls
      [ "data" .= inlineObject45Data
      ]


-- | Construct a value of type 'InlineObject45' (by applying it's required fields, if any)
mkInlineObject45
  :: InlineObject45
mkInlineObject45 =
  InlineObject45
  { inlineObject45Data = Nothing
  }

-- ** InlineObject46
-- | InlineObject46
data InlineObject46 = InlineObject46
  { inlineObject46Data :: !(Maybe TaskAddTagRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject46
instance A.FromJSON InlineObject46 where
  parseJSON = A.withObject "InlineObject46" $ \o ->
    InlineObject46
      <$> (o .:? "data")

-- | ToJSON InlineObject46
instance A.ToJSON InlineObject46 where
  toJSON InlineObject46 {..} =
   _omitNulls
      [ "data" .= inlineObject46Data
      ]


-- | Construct a value of type 'InlineObject46' (by applying it's required fields, if any)
mkInlineObject46
  :: InlineObject46
mkInlineObject46 =
  InlineObject46
  { inlineObject46Data = Nothing
  }

-- ** InlineObject47
-- | InlineObject47
data InlineObject47 = InlineObject47
  { inlineObject47Data :: !(Maybe TaskRemoveTagRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject47
instance A.FromJSON InlineObject47 where
  parseJSON = A.withObject "InlineObject47" $ \o ->
    InlineObject47
      <$> (o .:? "data")

-- | ToJSON InlineObject47
instance A.ToJSON InlineObject47 where
  toJSON InlineObject47 {..} =
   _omitNulls
      [ "data" .= inlineObject47Data
      ]


-- | Construct a value of type 'InlineObject47' (by applying it's required fields, if any)
mkInlineObject47
  :: InlineObject47
mkInlineObject47 =
  InlineObject47
  { inlineObject47Data = Nothing
  }

-- ** InlineObject48
-- | InlineObject48
data InlineObject48 = InlineObject48
  { inlineObject48Data :: !(Maybe TaskAddFollowersRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject48
instance A.FromJSON InlineObject48 where
  parseJSON = A.withObject "InlineObject48" $ \o ->
    InlineObject48
      <$> (o .:? "data")

-- | ToJSON InlineObject48
instance A.ToJSON InlineObject48 where
  toJSON InlineObject48 {..} =
   _omitNulls
      [ "data" .= inlineObject48Data
      ]


-- | Construct a value of type 'InlineObject48' (by applying it's required fields, if any)
mkInlineObject48
  :: InlineObject48
mkInlineObject48 =
  InlineObject48
  { inlineObject48Data = Nothing
  }

-- ** InlineObject49
-- | InlineObject49
data InlineObject49 = InlineObject49
  { inlineObject49Data :: !(Maybe TaskRemoveFollowersRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject49
instance A.FromJSON InlineObject49 where
  parseJSON = A.withObject "InlineObject49" $ \o ->
    InlineObject49
      <$> (o .:? "data")

-- | ToJSON InlineObject49
instance A.ToJSON InlineObject49 where
  toJSON InlineObject49 {..} =
   _omitNulls
      [ "data" .= inlineObject49Data
      ]


-- | Construct a value of type 'InlineObject49' (by applying it's required fields, if any)
mkInlineObject49
  :: InlineObject49
mkInlineObject49 =
  InlineObject49
  { inlineObject49Data = Nothing
  }

-- ** InlineObject5
-- | InlineObject5
data InlineObject5 = InlineObject5
  { inlineObject5Data :: !(Maybe EnumOptionRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject5
instance A.FromJSON InlineObject5 where
  parseJSON = A.withObject "InlineObject5" $ \o ->
    InlineObject5
      <$> (o .:? "data")

-- | ToJSON InlineObject5
instance A.ToJSON InlineObject5 where
  toJSON InlineObject5 {..} =
   _omitNulls
      [ "data" .= inlineObject5Data
      ]


-- | Construct a value of type 'InlineObject5' (by applying it's required fields, if any)
mkInlineObject5
  :: InlineObject5
mkInlineObject5 =
  InlineObject5
  { inlineObject5Data = Nothing
  }

-- ** InlineObject50
-- | InlineObject50
data InlineObject50 = InlineObject50
  { inlineObject50Data :: !(Maybe TeamAddUserRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject50
instance A.FromJSON InlineObject50 where
  parseJSON = A.withObject "InlineObject50" $ \o ->
    InlineObject50
      <$> (o .:? "data")

-- | ToJSON InlineObject50
instance A.ToJSON InlineObject50 where
  toJSON InlineObject50 {..} =
   _omitNulls
      [ "data" .= inlineObject50Data
      ]


-- | Construct a value of type 'InlineObject50' (by applying it's required fields, if any)
mkInlineObject50
  :: InlineObject50
mkInlineObject50 =
  InlineObject50
  { inlineObject50Data = Nothing
  }

-- ** InlineObject51
-- | InlineObject51
data InlineObject51 = InlineObject51
  { inlineObject51Data :: !(Maybe TeamRemoveUserRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject51
instance A.FromJSON InlineObject51 where
  parseJSON = A.withObject "InlineObject51" $ \o ->
    InlineObject51
      <$> (o .:? "data")

-- | ToJSON InlineObject51
instance A.ToJSON InlineObject51 where
  toJSON InlineObject51 {..} =
   _omitNulls
      [ "data" .= inlineObject51Data
      ]


-- | Construct a value of type 'InlineObject51' (by applying it's required fields, if any)
mkInlineObject51
  :: InlineObject51
mkInlineObject51 =
  InlineObject51
  { inlineObject51Data = Nothing
  }

-- ** InlineObject52
-- | InlineObject52
data InlineObject52 = InlineObject52
  { inlineObject52Data :: !(Maybe WebhookRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject52
instance A.FromJSON InlineObject52 where
  parseJSON = A.withObject "InlineObject52" $ \o ->
    InlineObject52
      <$> (o .:? "data")

-- | ToJSON InlineObject52
instance A.ToJSON InlineObject52 where
  toJSON InlineObject52 {..} =
   _omitNulls
      [ "data" .= inlineObject52Data
      ]


-- | Construct a value of type 'InlineObject52' (by applying it's required fields, if any)
mkInlineObject52
  :: InlineObject52
mkInlineObject52 =
  InlineObject52
  { inlineObject52Data = Nothing
  }

-- ** InlineObject53
-- | InlineObject53
data InlineObject53 = InlineObject53
  { inlineObject53Data :: !(Maybe WorkspaceCompact) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject53
instance A.FromJSON InlineObject53 where
  parseJSON = A.withObject "InlineObject53" $ \o ->
    InlineObject53
      <$> (o .:? "data")

-- | ToJSON InlineObject53
instance A.ToJSON InlineObject53 where
  toJSON InlineObject53 {..} =
   _omitNulls
      [ "data" .= inlineObject53Data
      ]


-- | Construct a value of type 'InlineObject53' (by applying it's required fields, if any)
mkInlineObject53
  :: InlineObject53
mkInlineObject53 =
  InlineObject53
  { inlineObject53Data = Nothing
  }

-- ** InlineObject54
-- | InlineObject54
data InlineObject54 = InlineObject54
  { inlineObject54Data :: !(Maybe WorkspaceAddUserRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject54
instance A.FromJSON InlineObject54 where
  parseJSON = A.withObject "InlineObject54" $ \o ->
    InlineObject54
      <$> (o .:? "data")

-- | ToJSON InlineObject54
instance A.ToJSON InlineObject54 where
  toJSON InlineObject54 {..} =
   _omitNulls
      [ "data" .= inlineObject54Data
      ]


-- | Construct a value of type 'InlineObject54' (by applying it's required fields, if any)
mkInlineObject54
  :: InlineObject54
mkInlineObject54 =
  InlineObject54
  { inlineObject54Data = Nothing
  }

-- ** InlineObject55
-- | InlineObject55
data InlineObject55 = InlineObject55
  { inlineObject55Data :: !(Maybe WorkspaceRemoveUserRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject55
instance A.FromJSON InlineObject55 where
  parseJSON = A.withObject "InlineObject55" $ \o ->
    InlineObject55
      <$> (o .:? "data")

-- | ToJSON InlineObject55
instance A.ToJSON InlineObject55 where
  toJSON InlineObject55 {..} =
   _omitNulls
      [ "data" .= inlineObject55Data
      ]


-- | Construct a value of type 'InlineObject55' (by applying it's required fields, if any)
mkInlineObject55
  :: InlineObject55
mkInlineObject55 =
  InlineObject55
  { inlineObject55Data = Nothing
  }

-- ** InlineObject6
-- | InlineObject6
data InlineObject6 = InlineObject6
  { inlineObject6Data :: !(Maybe OrganizationExportRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject6
instance A.FromJSON InlineObject6 where
  parseJSON = A.withObject "InlineObject6" $ \o ->
    InlineObject6
      <$> (o .:? "data")

-- | ToJSON InlineObject6
instance A.ToJSON InlineObject6 where
  toJSON InlineObject6 {..} =
   _omitNulls
      [ "data" .= inlineObject6Data
      ]


-- | Construct a value of type 'InlineObject6' (by applying it's required fields, if any)
mkInlineObject6
  :: InlineObject6
mkInlineObject6 =
  InlineObject6
  { inlineObject6Data = Nothing
  }

-- ** InlineObject7
-- | InlineObject7
data InlineObject7 = InlineObject7
  { inlineObject7Data :: !(Maybe PortfolioRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject7
instance A.FromJSON InlineObject7 where
  parseJSON = A.withObject "InlineObject7" $ \o ->
    InlineObject7
      <$> (o .:? "data")

-- | ToJSON InlineObject7
instance A.ToJSON InlineObject7 where
  toJSON InlineObject7 {..} =
   _omitNulls
      [ "data" .= inlineObject7Data
      ]


-- | Construct a value of type 'InlineObject7' (by applying it's required fields, if any)
mkInlineObject7
  :: InlineObject7
mkInlineObject7 =
  InlineObject7
  { inlineObject7Data = Nothing
  }

-- ** InlineObject8
-- | InlineObject8
data InlineObject8 = InlineObject8
  { inlineObject8Data :: !(Maybe PortfolioRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject8
instance A.FromJSON InlineObject8 where
  parseJSON = A.withObject "InlineObject8" $ \o ->
    InlineObject8
      <$> (o .:? "data")

-- | ToJSON InlineObject8
instance A.ToJSON InlineObject8 where
  toJSON InlineObject8 {..} =
   _omitNulls
      [ "data" .= inlineObject8Data
      ]


-- | Construct a value of type 'InlineObject8' (by applying it's required fields, if any)
mkInlineObject8
  :: InlineObject8
mkInlineObject8 =
  InlineObject8
  { inlineObject8Data = Nothing
  }

-- ** InlineObject9
-- | InlineObject9
data InlineObject9 = InlineObject9
  { inlineObject9Data :: !(Maybe PortfolioAddItemRequest) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject9
instance A.FromJSON InlineObject9 where
  parseJSON = A.withObject "InlineObject9" $ \o ->
    InlineObject9
      <$> (o .:? "data")

-- | ToJSON InlineObject9
instance A.ToJSON InlineObject9 where
  toJSON InlineObject9 {..} =
   _omitNulls
      [ "data" .= inlineObject9Data
      ]


-- | Construct a value of type 'InlineObject9' (by applying it's required fields, if any)
mkInlineObject9
  :: InlineObject9
mkInlineObject9 =
  InlineObject9
  { inlineObject9Data = Nothing
  }

-- ** InlineResponse200
-- | InlineResponse200
data InlineResponse200 = InlineResponse200
  { inlineResponse200Data :: !(Maybe AttachmentResponse) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse200
instance A.FromJSON InlineResponse200 where
  parseJSON = A.withObject "InlineResponse200" $ \o ->
    InlineResponse200
      <$> (o .:? "data")

-- | ToJSON InlineResponse200
instance A.ToJSON InlineResponse200 where
  toJSON InlineResponse200 {..} =
   _omitNulls
      [ "data" .= inlineResponse200Data
      ]


-- | Construct a value of type 'InlineResponse200' (by applying it's required fields, if any)
mkInlineResponse200
  :: InlineResponse200
mkInlineResponse200 =
  InlineResponse200
  { inlineResponse200Data = Nothing
  }

-- ** InlineResponse2001
-- | InlineResponse2001
data InlineResponse2001 = InlineResponse2001
  { inlineResponse2001Data :: !(Maybe A.Value) -- ^ "data" - An empty object. Some endpoints do not return an object on success. The success is conveyed through a 2-- status code and returning an empty object.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2001
instance A.FromJSON InlineResponse2001 where
  parseJSON = A.withObject "InlineResponse2001" $ \o ->
    InlineResponse2001
      <$> (o .:? "data")

-- | ToJSON InlineResponse2001
instance A.ToJSON InlineResponse2001 where
  toJSON InlineResponse2001 {..} =
   _omitNulls
      [ "data" .= inlineResponse2001Data
      ]


-- | Construct a value of type 'InlineResponse2001' (by applying it's required fields, if any)
mkInlineResponse2001
  :: InlineResponse2001
mkInlineResponse2001 =
  InlineResponse2001
  { inlineResponse2001Data = Nothing
  }

-- ** InlineResponse20010
-- | InlineResponse20010
data InlineResponse20010 = InlineResponse20010
  { inlineResponse20010Data :: !(Maybe [PortfolioCompact]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20010
instance A.FromJSON InlineResponse20010 where
  parseJSON = A.withObject "InlineResponse20010" $ \o ->
    InlineResponse20010
      <$> (o .:? "data")

-- | ToJSON InlineResponse20010
instance A.ToJSON InlineResponse20010 where
  toJSON InlineResponse20010 {..} =
   _omitNulls
      [ "data" .= inlineResponse20010Data
      ]


-- | Construct a value of type 'InlineResponse20010' (by applying it's required fields, if any)
mkInlineResponse20010
  :: InlineResponse20010
mkInlineResponse20010 =
  InlineResponse20010
  { inlineResponse20010Data = Nothing
  }

-- ** InlineResponse20011
-- | InlineResponse20011
data InlineResponse20011 = InlineResponse20011
  { inlineResponse20011Data :: !(Maybe [ProjectCompact]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20011
instance A.FromJSON InlineResponse20011 where
  parseJSON = A.withObject "InlineResponse20011" $ \o ->
    InlineResponse20011
      <$> (o .:? "data")

-- | ToJSON InlineResponse20011
instance A.ToJSON InlineResponse20011 where
  toJSON InlineResponse20011 {..} =
   _omitNulls
      [ "data" .= inlineResponse20011Data
      ]


-- | Construct a value of type 'InlineResponse20011' (by applying it's required fields, if any)
mkInlineResponse20011
  :: InlineResponse20011
mkInlineResponse20011 =
  InlineResponse20011
  { inlineResponse20011Data = Nothing
  }

-- ** InlineResponse20012
-- | InlineResponse20012
data InlineResponse20012 = InlineResponse20012
  { inlineResponse20012Data :: !(Maybe ProjectMembershipResponse) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20012
instance A.FromJSON InlineResponse20012 where
  parseJSON = A.withObject "InlineResponse20012" $ \o ->
    InlineResponse20012
      <$> (o .:? "data")

-- | ToJSON InlineResponse20012
instance A.ToJSON InlineResponse20012 where
  toJSON InlineResponse20012 {..} =
   _omitNulls
      [ "data" .= inlineResponse20012Data
      ]


-- | Construct a value of type 'InlineResponse20012' (by applying it's required fields, if any)
mkInlineResponse20012
  :: InlineResponse20012
mkInlineResponse20012 =
  InlineResponse20012
  { inlineResponse20012Data = Nothing
  }

-- ** InlineResponse20013
-- | InlineResponse20013
data InlineResponse20013 = InlineResponse20013
  { inlineResponse20013Data :: !(Maybe [ProjectMembershipCompact]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20013
instance A.FromJSON InlineResponse20013 where
  parseJSON = A.withObject "InlineResponse20013" $ \o ->
    InlineResponse20013
      <$> (o .:? "data")

-- | ToJSON InlineResponse20013
instance A.ToJSON InlineResponse20013 where
  toJSON InlineResponse20013 {..} =
   _omitNulls
      [ "data" .= inlineResponse20013Data
      ]


-- | Construct a value of type 'InlineResponse20013' (by applying it's required fields, if any)
mkInlineResponse20013
  :: InlineResponse20013
mkInlineResponse20013 =
  InlineResponse20013
  { inlineResponse20013Data = Nothing
  }

-- ** InlineResponse20014
-- | InlineResponse20014
data InlineResponse20014 = InlineResponse20014
  { inlineResponse20014Data :: !(Maybe ProjectStatusResponse) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20014
instance A.FromJSON InlineResponse20014 where
  parseJSON = A.withObject "InlineResponse20014" $ \o ->
    InlineResponse20014
      <$> (o .:? "data")

-- | ToJSON InlineResponse20014
instance A.ToJSON InlineResponse20014 where
  toJSON InlineResponse20014 {..} =
   _omitNulls
      [ "data" .= inlineResponse20014Data
      ]


-- | Construct a value of type 'InlineResponse20014' (by applying it's required fields, if any)
mkInlineResponse20014
  :: InlineResponse20014
mkInlineResponse20014 =
  InlineResponse20014
  { inlineResponse20014Data = Nothing
  }

-- ** InlineResponse20015
-- | InlineResponse20015
data InlineResponse20015 = InlineResponse20015
  { inlineResponse20015Data :: !(Maybe [ProjectStatusCompact]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20015
instance A.FromJSON InlineResponse20015 where
  parseJSON = A.withObject "InlineResponse20015" $ \o ->
    InlineResponse20015
      <$> (o .:? "data")

-- | ToJSON InlineResponse20015
instance A.ToJSON InlineResponse20015 where
  toJSON InlineResponse20015 {..} =
   _omitNulls
      [ "data" .= inlineResponse20015Data
      ]


-- | Construct a value of type 'InlineResponse20015' (by applying it's required fields, if any)
mkInlineResponse20015
  :: InlineResponse20015
mkInlineResponse20015 =
  InlineResponse20015
  { inlineResponse20015Data = Nothing
  }

-- ** InlineResponse20016
-- | InlineResponse20016
data InlineResponse20016 = InlineResponse20016
  { inlineResponse20016Data :: !(Maybe TaskCountResponse) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20016
instance A.FromJSON InlineResponse20016 where
  parseJSON = A.withObject "InlineResponse20016" $ \o ->
    InlineResponse20016
      <$> (o .:? "data")

-- | ToJSON InlineResponse20016
instance A.ToJSON InlineResponse20016 where
  toJSON InlineResponse20016 {..} =
   _omitNulls
      [ "data" .= inlineResponse20016Data
      ]


-- | Construct a value of type 'InlineResponse20016' (by applying it's required fields, if any)
mkInlineResponse20016
  :: InlineResponse20016
mkInlineResponse20016 =
  InlineResponse20016
  { inlineResponse20016Data = Nothing
  }

-- ** InlineResponse20017
-- | InlineResponse20017
data InlineResponse20017 = InlineResponse20017
  { inlineResponse20017Data :: !(Maybe SectionResponse) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20017
instance A.FromJSON InlineResponse20017 where
  parseJSON = A.withObject "InlineResponse20017" $ \o ->
    InlineResponse20017
      <$> (o .:? "data")

-- | ToJSON InlineResponse20017
instance A.ToJSON InlineResponse20017 where
  toJSON InlineResponse20017 {..} =
   _omitNulls
      [ "data" .= inlineResponse20017Data
      ]


-- | Construct a value of type 'InlineResponse20017' (by applying it's required fields, if any)
mkInlineResponse20017
  :: InlineResponse20017
mkInlineResponse20017 =
  InlineResponse20017
  { inlineResponse20017Data = Nothing
  }

-- ** InlineResponse20018
-- | InlineResponse20018
data InlineResponse20018 = InlineResponse20018
  { inlineResponse20018Data :: !(Maybe [SectionCompact]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20018
instance A.FromJSON InlineResponse20018 where
  parseJSON = A.withObject "InlineResponse20018" $ \o ->
    InlineResponse20018
      <$> (o .:? "data")

-- | ToJSON InlineResponse20018
instance A.ToJSON InlineResponse20018 where
  toJSON InlineResponse20018 {..} =
   _omitNulls
      [ "data" .= inlineResponse20018Data
      ]


-- | Construct a value of type 'InlineResponse20018' (by applying it's required fields, if any)
mkInlineResponse20018
  :: InlineResponse20018
mkInlineResponse20018 =
  InlineResponse20018
  { inlineResponse20018Data = Nothing
  }

-- ** InlineResponse20019
-- | InlineResponse20019
data InlineResponse20019 = InlineResponse20019
  { inlineResponse20019Data :: !(Maybe StoryResponse) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20019
instance A.FromJSON InlineResponse20019 where
  parseJSON = A.withObject "InlineResponse20019" $ \o ->
    InlineResponse20019
      <$> (o .:? "data")

-- | ToJSON InlineResponse20019
instance A.ToJSON InlineResponse20019 where
  toJSON InlineResponse20019 {..} =
   _omitNulls
      [ "data" .= inlineResponse20019Data
      ]


-- | Construct a value of type 'InlineResponse20019' (by applying it's required fields, if any)
mkInlineResponse20019
  :: InlineResponse20019
mkInlineResponse20019 =
  InlineResponse20019
  { inlineResponse20019Data = Nothing
  }

-- ** InlineResponse2002
-- | InlineResponse2002
data InlineResponse2002 = InlineResponse2002
  { inlineResponse2002Data :: !(Maybe [AttachmentCompact]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2002
instance A.FromJSON InlineResponse2002 where
  parseJSON = A.withObject "InlineResponse2002" $ \o ->
    InlineResponse2002
      <$> (o .:? "data")

-- | ToJSON InlineResponse2002
instance A.ToJSON InlineResponse2002 where
  toJSON InlineResponse2002 {..} =
   _omitNulls
      [ "data" .= inlineResponse2002Data
      ]


-- | Construct a value of type 'InlineResponse2002' (by applying it's required fields, if any)
mkInlineResponse2002
  :: InlineResponse2002
mkInlineResponse2002 =
  InlineResponse2002
  { inlineResponse2002Data = Nothing
  }

-- ** InlineResponse20020
-- | InlineResponse20020
data InlineResponse20020 = InlineResponse20020
  { inlineResponse20020Data :: !(Maybe [StoryCompact]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20020
instance A.FromJSON InlineResponse20020 where
  parseJSON = A.withObject "InlineResponse20020" $ \o ->
    InlineResponse20020
      <$> (o .:? "data")

-- | ToJSON InlineResponse20020
instance A.ToJSON InlineResponse20020 where
  toJSON InlineResponse20020 {..} =
   _omitNulls
      [ "data" .= inlineResponse20020Data
      ]


-- | Construct a value of type 'InlineResponse20020' (by applying it's required fields, if any)
mkInlineResponse20020
  :: InlineResponse20020
mkInlineResponse20020 =
  InlineResponse20020
  { inlineResponse20020Data = Nothing
  }

-- ** InlineResponse20021
-- | InlineResponse20021
data InlineResponse20021 = InlineResponse20021
  { inlineResponse20021Data :: !(Maybe [TagCompact]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20021
instance A.FromJSON InlineResponse20021 where
  parseJSON = A.withObject "InlineResponse20021" $ \o ->
    InlineResponse20021
      <$> (o .:? "data")

-- | ToJSON InlineResponse20021
instance A.ToJSON InlineResponse20021 where
  toJSON InlineResponse20021 {..} =
   _omitNulls
      [ "data" .= inlineResponse20021Data
      ]


-- | Construct a value of type 'InlineResponse20021' (by applying it's required fields, if any)
mkInlineResponse20021
  :: InlineResponse20021
mkInlineResponse20021 =
  InlineResponse20021
  { inlineResponse20021Data = Nothing
  }

-- ** InlineResponse20022
-- | InlineResponse20022
data InlineResponse20022 = InlineResponse20022
  { inlineResponse20022Data :: !(Maybe [TaskCompact]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20022
instance A.FromJSON InlineResponse20022 where
  parseJSON = A.withObject "InlineResponse20022" $ \o ->
    InlineResponse20022
      <$> (o .:? "data")

-- | ToJSON InlineResponse20022
instance A.ToJSON InlineResponse20022 where
  toJSON InlineResponse20022 {..} =
   _omitNulls
      [ "data" .= inlineResponse20022Data
      ]


-- | Construct a value of type 'InlineResponse20022' (by applying it's required fields, if any)
mkInlineResponse20022
  :: InlineResponse20022
mkInlineResponse20022 =
  InlineResponse20022
  { inlineResponse20022Data = Nothing
  }

-- ** InlineResponse20023
-- | InlineResponse20023
data InlineResponse20023 = InlineResponse20023
  { inlineResponse20023Data :: !(Maybe [A.Value]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20023
instance A.FromJSON InlineResponse20023 where
  parseJSON = A.withObject "InlineResponse20023" $ \o ->
    InlineResponse20023
      <$> (o .:? "data")

-- | ToJSON InlineResponse20023
instance A.ToJSON InlineResponse20023 where
  toJSON InlineResponse20023 {..} =
   _omitNulls
      [ "data" .= inlineResponse20023Data
      ]


-- | Construct a value of type 'InlineResponse20023' (by applying it's required fields, if any)
mkInlineResponse20023
  :: InlineResponse20023
mkInlineResponse20023 =
  InlineResponse20023
  { inlineResponse20023Data = Nothing
  }

-- ** InlineResponse20024
-- | InlineResponse20024
data InlineResponse20024 = InlineResponse20024
  { inlineResponse20024Data :: !(Maybe TeamMembershipCompact) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20024
instance A.FromJSON InlineResponse20024 where
  parseJSON = A.withObject "InlineResponse20024" $ \o ->
    InlineResponse20024
      <$> (o .:? "data")

-- | ToJSON InlineResponse20024
instance A.ToJSON InlineResponse20024 where
  toJSON InlineResponse20024 {..} =
   _omitNulls
      [ "data" .= inlineResponse20024Data
      ]


-- | Construct a value of type 'InlineResponse20024' (by applying it's required fields, if any)
mkInlineResponse20024
  :: InlineResponse20024
mkInlineResponse20024 =
  InlineResponse20024
  { inlineResponse20024Data = Nothing
  }

-- ** InlineResponse20025
-- | InlineResponse20025
data InlineResponse20025 = InlineResponse20025
  { inlineResponse20025Data :: !(Maybe [TeamMembershipCompact]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20025
instance A.FromJSON InlineResponse20025 where
  parseJSON = A.withObject "InlineResponse20025" $ \o ->
    InlineResponse20025
      <$> (o .:? "data")

-- | ToJSON InlineResponse20025
instance A.ToJSON InlineResponse20025 where
  toJSON InlineResponse20025 {..} =
   _omitNulls
      [ "data" .= inlineResponse20025Data
      ]


-- | Construct a value of type 'InlineResponse20025' (by applying it's required fields, if any)
mkInlineResponse20025
  :: InlineResponse20025
mkInlineResponse20025 =
  InlineResponse20025
  { inlineResponse20025Data = Nothing
  }

-- ** InlineResponse20026
-- | InlineResponse20026
data InlineResponse20026 = InlineResponse20026
  { inlineResponse20026Data :: !(Maybe TeamResponse) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20026
instance A.FromJSON InlineResponse20026 where
  parseJSON = A.withObject "InlineResponse20026" $ \o ->
    InlineResponse20026
      <$> (o .:? "data")

-- | ToJSON InlineResponse20026
instance A.ToJSON InlineResponse20026 where
  toJSON InlineResponse20026 {..} =
   _omitNulls
      [ "data" .= inlineResponse20026Data
      ]


-- | Construct a value of type 'InlineResponse20026' (by applying it's required fields, if any)
mkInlineResponse20026
  :: InlineResponse20026
mkInlineResponse20026 =
  InlineResponse20026
  { inlineResponse20026Data = Nothing
  }

-- ** InlineResponse20027
-- | InlineResponse20027
data InlineResponse20027 = InlineResponse20027
  { inlineResponse20027Data :: !(Maybe [TeamCompact]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20027
instance A.FromJSON InlineResponse20027 where
  parseJSON = A.withObject "InlineResponse20027" $ \o ->
    InlineResponse20027
      <$> (o .:? "data")

-- | ToJSON InlineResponse20027
instance A.ToJSON InlineResponse20027 where
  toJSON InlineResponse20027 {..} =
   _omitNulls
      [ "data" .= inlineResponse20027Data
      ]


-- | Construct a value of type 'InlineResponse20027' (by applying it's required fields, if any)
mkInlineResponse20027
  :: InlineResponse20027
mkInlineResponse20027 =
  InlineResponse20027
  { inlineResponse20027Data = Nothing
  }

-- ** InlineResponse20028
-- | InlineResponse20028
data InlineResponse20028 = InlineResponse20028
  { inlineResponse20028Data :: !(Maybe UserResponse) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20028
instance A.FromJSON InlineResponse20028 where
  parseJSON = A.withObject "InlineResponse20028" $ \o ->
    InlineResponse20028
      <$> (o .:? "data")

-- | ToJSON InlineResponse20028
instance A.ToJSON InlineResponse20028 where
  toJSON InlineResponse20028 {..} =
   _omitNulls
      [ "data" .= inlineResponse20028Data
      ]


-- | Construct a value of type 'InlineResponse20028' (by applying it's required fields, if any)
mkInlineResponse20028
  :: InlineResponse20028
mkInlineResponse20028 =
  InlineResponse20028
  { inlineResponse20028Data = Nothing
  }

-- ** InlineResponse20029
-- | InlineResponse20029
-- A generic list of objects, such as those returned by the typeahead search endpoint.
data InlineResponse20029 = InlineResponse20029
  { inlineResponse20029Data :: !(Maybe [AsanaNamedResource]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20029
instance A.FromJSON InlineResponse20029 where
  parseJSON = A.withObject "InlineResponse20029" $ \o ->
    InlineResponse20029
      <$> (o .:? "data")

-- | ToJSON InlineResponse20029
instance A.ToJSON InlineResponse20029 where
  toJSON InlineResponse20029 {..} =
   _omitNulls
      [ "data" .= inlineResponse20029Data
      ]


-- | Construct a value of type 'InlineResponse20029' (by applying it's required fields, if any)
mkInlineResponse20029
  :: InlineResponse20029
mkInlineResponse20029 =
  InlineResponse20029
  { inlineResponse20029Data = Nothing
  }

-- ** InlineResponse2003
-- | InlineResponse2003
data InlineResponse2003 = InlineResponse2003
  { inlineResponse2003Data :: !(Maybe [BatchResponse]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2003
instance A.FromJSON InlineResponse2003 where
  parseJSON = A.withObject "InlineResponse2003" $ \o ->
    InlineResponse2003
      <$> (o .:? "data")

-- | ToJSON InlineResponse2003
instance A.ToJSON InlineResponse2003 where
  toJSON InlineResponse2003 {..} =
   _omitNulls
      [ "data" .= inlineResponse2003Data
      ]


-- | Construct a value of type 'InlineResponse2003' (by applying it's required fields, if any)
mkInlineResponse2003
  :: InlineResponse2003
mkInlineResponse2003 =
  InlineResponse2003
  { inlineResponse2003Data = Nothing
  }

-- ** InlineResponse20030
-- | InlineResponse20030
data InlineResponse20030 = InlineResponse20030
  { inlineResponse20030Data :: !(Maybe UserTaskListCompact) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20030
instance A.FromJSON InlineResponse20030 where
  parseJSON = A.withObject "InlineResponse20030" $ \o ->
    InlineResponse20030
      <$> (o .:? "data")

-- | ToJSON InlineResponse20030
instance A.ToJSON InlineResponse20030 where
  toJSON InlineResponse20030 {..} =
   _omitNulls
      [ "data" .= inlineResponse20030Data
      ]


-- | Construct a value of type 'InlineResponse20030' (by applying it's required fields, if any)
mkInlineResponse20030
  :: InlineResponse20030
mkInlineResponse20030 =
  InlineResponse20030
  { inlineResponse20030Data = Nothing
  }

-- ** InlineResponse20031
-- | InlineResponse20031
data InlineResponse20031 = InlineResponse20031
  { inlineResponse20031Data :: !(Maybe [UserCompact]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20031
instance A.FromJSON InlineResponse20031 where
  parseJSON = A.withObject "InlineResponse20031" $ \o ->
    InlineResponse20031
      <$> (o .:? "data")

-- | ToJSON InlineResponse20031
instance A.ToJSON InlineResponse20031 where
  toJSON InlineResponse20031 {..} =
   _omitNulls
      [ "data" .= inlineResponse20031Data
      ]


-- | Construct a value of type 'InlineResponse20031' (by applying it's required fields, if any)
mkInlineResponse20031
  :: InlineResponse20031
mkInlineResponse20031 =
  InlineResponse20031
  { inlineResponse20031Data = Nothing
  }

-- ** InlineResponse20032
-- | InlineResponse20032
data InlineResponse20032 = InlineResponse20032
  { inlineResponse20032Data :: !(Maybe [AsanaNamedResource]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20032
instance A.FromJSON InlineResponse20032 where
  parseJSON = A.withObject "InlineResponse20032" $ \o ->
    InlineResponse20032
      <$> (o .:? "data")

-- | ToJSON InlineResponse20032
instance A.ToJSON InlineResponse20032 where
  toJSON InlineResponse20032 {..} =
   _omitNulls
      [ "data" .= inlineResponse20032Data
      ]


-- | Construct a value of type 'InlineResponse20032' (by applying it's required fields, if any)
mkInlineResponse20032
  :: InlineResponse20032
mkInlineResponse20032 =
  InlineResponse20032
  { inlineResponse20032Data = Nothing
  }

-- ** InlineResponse20033
-- | InlineResponse20033
data InlineResponse20033 = InlineResponse20033
  { inlineResponse20033Data :: !(Maybe [WebhookResponse]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20033
instance A.FromJSON InlineResponse20033 where
  parseJSON = A.withObject "InlineResponse20033" $ \o ->
    InlineResponse20033
      <$> (o .:? "data")

-- | ToJSON InlineResponse20033
instance A.ToJSON InlineResponse20033 where
  toJSON InlineResponse20033 {..} =
   _omitNulls
      [ "data" .= inlineResponse20033Data
      ]


-- | Construct a value of type 'InlineResponse20033' (by applying it's required fields, if any)
mkInlineResponse20033
  :: InlineResponse20033
mkInlineResponse20033 =
  InlineResponse20033
  { inlineResponse20033Data = Nothing
  }

-- ** InlineResponse20034
-- | InlineResponse20034
data InlineResponse20034 = InlineResponse20034
  { inlineResponse20034Data :: !(Maybe WorkspaceMembershipResponse) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20034
instance A.FromJSON InlineResponse20034 where
  parseJSON = A.withObject "InlineResponse20034" $ \o ->
    InlineResponse20034
      <$> (o .:? "data")

-- | ToJSON InlineResponse20034
instance A.ToJSON InlineResponse20034 where
  toJSON InlineResponse20034 {..} =
   _omitNulls
      [ "data" .= inlineResponse20034Data
      ]


-- | Construct a value of type 'InlineResponse20034' (by applying it's required fields, if any)
mkInlineResponse20034
  :: InlineResponse20034
mkInlineResponse20034 =
  InlineResponse20034
  { inlineResponse20034Data = Nothing
  }

-- ** InlineResponse20035
-- | InlineResponse20035
data InlineResponse20035 = InlineResponse20035
  { inlineResponse20035Data :: !(Maybe [WorkspaceMembershipCompact]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20035
instance A.FromJSON InlineResponse20035 where
  parseJSON = A.withObject "InlineResponse20035" $ \o ->
    InlineResponse20035
      <$> (o .:? "data")

-- | ToJSON InlineResponse20035
instance A.ToJSON InlineResponse20035 where
  toJSON InlineResponse20035 {..} =
   _omitNulls
      [ "data" .= inlineResponse20035Data
      ]


-- | Construct a value of type 'InlineResponse20035' (by applying it's required fields, if any)
mkInlineResponse20035
  :: InlineResponse20035
mkInlineResponse20035 =
  InlineResponse20035
  { inlineResponse20035Data = Nothing
  }

-- ** InlineResponse20036
-- | InlineResponse20036
data InlineResponse20036 = InlineResponse20036
  { inlineResponse20036Data :: !(Maybe [WorkspaceCompact]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20036
instance A.FromJSON InlineResponse20036 where
  parseJSON = A.withObject "InlineResponse20036" $ \o ->
    InlineResponse20036
      <$> (o .:? "data")

-- | ToJSON InlineResponse20036
instance A.ToJSON InlineResponse20036 where
  toJSON InlineResponse20036 {..} =
   _omitNulls
      [ "data" .= inlineResponse20036Data
      ]


-- | Construct a value of type 'InlineResponse20036' (by applying it's required fields, if any)
mkInlineResponse20036
  :: InlineResponse20036
mkInlineResponse20036 =
  InlineResponse20036
  { inlineResponse20036Data = Nothing
  }

-- ** InlineResponse20037
-- | InlineResponse20037
data InlineResponse20037 = InlineResponse20037
  { inlineResponse20037Data :: !(Maybe WorkspaceResponse) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20037
instance A.FromJSON InlineResponse20037 where
  parseJSON = A.withObject "InlineResponse20037" $ \o ->
    InlineResponse20037
      <$> (o .:? "data")

-- | ToJSON InlineResponse20037
instance A.ToJSON InlineResponse20037 where
  toJSON InlineResponse20037 {..} =
   _omitNulls
      [ "data" .= inlineResponse20037Data
      ]


-- | Construct a value of type 'InlineResponse20037' (by applying it's required fields, if any)
mkInlineResponse20037
  :: InlineResponse20037
mkInlineResponse20037 =
  InlineResponse20037
  { inlineResponse20037Data = Nothing
  }

-- ** InlineResponse2004
-- | InlineResponse2004
data InlineResponse2004 = InlineResponse2004
  { inlineResponse2004Data :: !(Maybe [CustomFieldSettingResponse]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2004
instance A.FromJSON InlineResponse2004 where
  parseJSON = A.withObject "InlineResponse2004" $ \o ->
    InlineResponse2004
      <$> (o .:? "data")

-- | ToJSON InlineResponse2004
instance A.ToJSON InlineResponse2004 where
  toJSON InlineResponse2004 {..} =
   _omitNulls
      [ "data" .= inlineResponse2004Data
      ]


-- | Construct a value of type 'InlineResponse2004' (by applying it's required fields, if any)
mkInlineResponse2004
  :: InlineResponse2004
mkInlineResponse2004 =
  InlineResponse2004
  { inlineResponse2004Data = Nothing
  }

-- ** InlineResponse2005
-- | InlineResponse2005
data InlineResponse2005 = InlineResponse2005
  { inlineResponse2005Data :: !(Maybe [CustomFieldResponse]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2005
instance A.FromJSON InlineResponse2005 where
  parseJSON = A.withObject "InlineResponse2005" $ \o ->
    InlineResponse2005
      <$> (o .:? "data")

-- | ToJSON InlineResponse2005
instance A.ToJSON InlineResponse2005 where
  toJSON InlineResponse2005 {..} =
   _omitNulls
      [ "data" .= inlineResponse2005Data
      ]


-- | Construct a value of type 'InlineResponse2005' (by applying it's required fields, if any)
mkInlineResponse2005
  :: InlineResponse2005
mkInlineResponse2005 =
  InlineResponse2005
  { inlineResponse2005Data = Nothing
  }

-- ** InlineResponse2006
-- | InlineResponse2006
-- The full record for all events that have occurred since the sync token was created.
data InlineResponse2006 = InlineResponse2006
  { inlineResponse2006Data :: !(Maybe [EventResponse]) -- ^ "data"
  , inlineResponse2006Sync :: !(Maybe Text) -- ^ "sync" - A sync token to be used with the next call to the events endpoint.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2006
instance A.FromJSON InlineResponse2006 where
  parseJSON = A.withObject "InlineResponse2006" $ \o ->
    InlineResponse2006
      <$> (o .:? "data")
      <*> (o .:? "sync")

-- | ToJSON InlineResponse2006
instance A.ToJSON InlineResponse2006 where
  toJSON InlineResponse2006 {..} =
   _omitNulls
      [ "data" .= inlineResponse2006Data
      , "sync" .= inlineResponse2006Sync
      ]


-- | Construct a value of type 'InlineResponse2006' (by applying it's required fields, if any)
mkInlineResponse2006
  :: InlineResponse2006
mkInlineResponse2006 =
  InlineResponse2006
  { inlineResponse2006Data = Nothing
  , inlineResponse2006Sync = Nothing
  }

-- ** InlineResponse2007
-- | InlineResponse2007
data InlineResponse2007 = InlineResponse2007
  { inlineResponse2007Data :: !(Maybe JobCompact) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2007
instance A.FromJSON InlineResponse2007 where
  parseJSON = A.withObject "InlineResponse2007" $ \o ->
    InlineResponse2007
      <$> (o .:? "data")

-- | ToJSON InlineResponse2007
instance A.ToJSON InlineResponse2007 where
  toJSON InlineResponse2007 {..} =
   _omitNulls
      [ "data" .= inlineResponse2007Data
      ]


-- | Construct a value of type 'InlineResponse2007' (by applying it's required fields, if any)
mkInlineResponse2007
  :: InlineResponse2007
mkInlineResponse2007 =
  InlineResponse2007
  { inlineResponse2007Data = Nothing
  }

-- ** InlineResponse2008
-- | InlineResponse2008
data InlineResponse2008 = InlineResponse2008
  { inlineResponse2008Data :: !(Maybe [PortfolioMembershipCompact]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2008
instance A.FromJSON InlineResponse2008 where
  parseJSON = A.withObject "InlineResponse2008" $ \o ->
    InlineResponse2008
      <$> (o .:? "data")

-- | ToJSON InlineResponse2008
instance A.ToJSON InlineResponse2008 where
  toJSON InlineResponse2008 {..} =
   _omitNulls
      [ "data" .= inlineResponse2008Data
      ]


-- | Construct a value of type 'InlineResponse2008' (by applying it's required fields, if any)
mkInlineResponse2008
  :: InlineResponse2008
mkInlineResponse2008 =
  InlineResponse2008
  { inlineResponse2008Data = Nothing
  }

-- ** InlineResponse2009
-- | InlineResponse2009
data InlineResponse2009 = InlineResponse2009
  { inlineResponse2009Data :: !(Maybe PortfolioMembershipCompact) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2009
instance A.FromJSON InlineResponse2009 where
  parseJSON = A.withObject "InlineResponse2009" $ \o ->
    InlineResponse2009
      <$> (o .:? "data")

-- | ToJSON InlineResponse2009
instance A.ToJSON InlineResponse2009 where
  toJSON InlineResponse2009 {..} =
   _omitNulls
      [ "data" .= inlineResponse2009Data
      ]


-- | Construct a value of type 'InlineResponse2009' (by applying it's required fields, if any)
mkInlineResponse2009
  :: InlineResponse2009
mkInlineResponse2009 =
  InlineResponse2009
  { inlineResponse2009Data = Nothing
  }

-- ** InlineResponse201
-- | InlineResponse201
data InlineResponse201 = InlineResponse201
  { inlineResponse201Data :: !(Maybe CustomFieldResponse) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse201
instance A.FromJSON InlineResponse201 where
  parseJSON = A.withObject "InlineResponse201" $ \o ->
    InlineResponse201
      <$> (o .:? "data")

-- | ToJSON InlineResponse201
instance A.ToJSON InlineResponse201 where
  toJSON InlineResponse201 {..} =
   _omitNulls
      [ "data" .= inlineResponse201Data
      ]


-- | Construct a value of type 'InlineResponse201' (by applying it's required fields, if any)
mkInlineResponse201
  :: InlineResponse201
mkInlineResponse201 =
  InlineResponse201
  { inlineResponse201Data = Nothing
  }

-- ** InlineResponse2011
-- | InlineResponse2011
data InlineResponse2011 = InlineResponse2011
  { inlineResponse2011Data :: !(Maybe EnumOption) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2011
instance A.FromJSON InlineResponse2011 where
  parseJSON = A.withObject "InlineResponse2011" $ \o ->
    InlineResponse2011
      <$> (o .:? "data")

-- | ToJSON InlineResponse2011
instance A.ToJSON InlineResponse2011 where
  toJSON InlineResponse2011 {..} =
   _omitNulls
      [ "data" .= inlineResponse2011Data
      ]


-- | Construct a value of type 'InlineResponse2011' (by applying it's required fields, if any)
mkInlineResponse2011
  :: InlineResponse2011
mkInlineResponse2011 =
  InlineResponse2011
  { inlineResponse2011Data = Nothing
  }

-- ** InlineResponse2012
-- | InlineResponse2012
data InlineResponse2012 = InlineResponse2012
  { inlineResponse2012Data :: !(Maybe OrganizationExportCompact) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2012
instance A.FromJSON InlineResponse2012 where
  parseJSON = A.withObject "InlineResponse2012" $ \o ->
    InlineResponse2012
      <$> (o .:? "data")

-- | ToJSON InlineResponse2012
instance A.ToJSON InlineResponse2012 where
  toJSON InlineResponse2012 {..} =
   _omitNulls
      [ "data" .= inlineResponse2012Data
      ]


-- | Construct a value of type 'InlineResponse2012' (by applying it's required fields, if any)
mkInlineResponse2012
  :: InlineResponse2012
mkInlineResponse2012 =
  InlineResponse2012
  { inlineResponse2012Data = Nothing
  }

-- ** InlineResponse2013
-- | InlineResponse2013
data InlineResponse2013 = InlineResponse2013
  { inlineResponse2013Data :: !(Maybe PortfolioResponse) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2013
instance A.FromJSON InlineResponse2013 where
  parseJSON = A.withObject "InlineResponse2013" $ \o ->
    InlineResponse2013
      <$> (o .:? "data")

-- | ToJSON InlineResponse2013
instance A.ToJSON InlineResponse2013 where
  toJSON InlineResponse2013 {..} =
   _omitNulls
      [ "data" .= inlineResponse2013Data
      ]


-- | Construct a value of type 'InlineResponse2013' (by applying it's required fields, if any)
mkInlineResponse2013
  :: InlineResponse2013
mkInlineResponse2013 =
  InlineResponse2013
  { inlineResponse2013Data = Nothing
  }

-- ** InlineResponse2014
-- | InlineResponse2014
data InlineResponse2014 = InlineResponse2014
  { inlineResponse2014Data :: !(Maybe ProjectResponse) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2014
instance A.FromJSON InlineResponse2014 where
  parseJSON = A.withObject "InlineResponse2014" $ \o ->
    InlineResponse2014
      <$> (o .:? "data")

-- | ToJSON InlineResponse2014
instance A.ToJSON InlineResponse2014 where
  toJSON InlineResponse2014 {..} =
   _omitNulls
      [ "data" .= inlineResponse2014Data
      ]


-- | Construct a value of type 'InlineResponse2014' (by applying it's required fields, if any)
mkInlineResponse2014
  :: InlineResponse2014
mkInlineResponse2014 =
  InlineResponse2014
  { inlineResponse2014Data = Nothing
  }

-- ** InlineResponse2015
-- | InlineResponse2015
data InlineResponse2015 = InlineResponse2015
  { inlineResponse2015Data :: !(Maybe TagResponse) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2015
instance A.FromJSON InlineResponse2015 where
  parseJSON = A.withObject "InlineResponse2015" $ \o ->
    InlineResponse2015
      <$> (o .:? "data")

-- | ToJSON InlineResponse2015
instance A.ToJSON InlineResponse2015 where
  toJSON InlineResponse2015 {..} =
   _omitNulls
      [ "data" .= inlineResponse2015Data
      ]


-- | Construct a value of type 'InlineResponse2015' (by applying it's required fields, if any)
mkInlineResponse2015
  :: InlineResponse2015
mkInlineResponse2015 =
  InlineResponse2015
  { inlineResponse2015Data = Nothing
  }

-- ** InlineResponse2016
-- | InlineResponse2016
data InlineResponse2016 = InlineResponse2016
  { inlineResponse2016Data :: !(Maybe TaskResponse) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2016
instance A.FromJSON InlineResponse2016 where
  parseJSON = A.withObject "InlineResponse2016" $ \o ->
    InlineResponse2016
      <$> (o .:? "data")

-- | ToJSON InlineResponse2016
instance A.ToJSON InlineResponse2016 where
  toJSON InlineResponse2016 {..} =
   _omitNulls
      [ "data" .= inlineResponse2016Data
      ]


-- | Construct a value of type 'InlineResponse2016' (by applying it's required fields, if any)
mkInlineResponse2016
  :: InlineResponse2016
mkInlineResponse2016 =
  InlineResponse2016
  { inlineResponse2016Data = Nothing
  }

-- ** InlineResponse2017
-- | InlineResponse2017
data InlineResponse2017 = InlineResponse2017
  { inlineResponse2017Data :: !(Maybe WebhookResponse) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2017
instance A.FromJSON InlineResponse2017 where
  parseJSON = A.withObject "InlineResponse2017" $ \o ->
    InlineResponse2017
      <$> (o .:? "data")

-- | ToJSON InlineResponse2017
instance A.ToJSON InlineResponse2017 where
  toJSON InlineResponse2017 {..} =
   _omitNulls
      [ "data" .= inlineResponse2017Data
      ]


-- | Construct a value of type 'InlineResponse2017' (by applying it's required fields, if any)
mkInlineResponse2017
  :: InlineResponse2017
mkInlineResponse2017 =
  InlineResponse2017
  { inlineResponse2017Data = Nothing
  }

-- ** JobBase
-- | JobBase
data JobBase = JobBase
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JobBase
instance A.FromJSON JobBase where
  parseJSON = A.withObject "JobBase" $ \o ->
    pure JobBase
      

-- | ToJSON JobBase
instance A.ToJSON JobBase where
  toJSON JobBase  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'JobBase' (by applying it's required fields, if any)
mkJobBase
  :: JobBase
mkJobBase =
  JobBase
  { 
  }

-- ** JobCompact
-- | JobCompact
data JobCompact = JobCompact
  { jobCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , jobCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , jobCompactResourceSubtype :: !(Maybe Text) -- ^ "resource_subtype" - The subtype of this resource. Different subtypes retain many of the same fields and behavior, but may render differently in Asana or represent resources with different semantic meaning.
  , jobCompactStatus :: !(Maybe E'Status) -- ^ "status"
  , jobCompactNewProject :: !(Maybe ProjectCompact) -- ^ "new_project"
  , jobCompactNewTask :: !(Maybe TaskCompact) -- ^ "new_task"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JobCompact
instance A.FromJSON JobCompact where
  parseJSON = A.withObject "JobCompact" $ \o ->
    JobCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "resource_subtype")
      <*> (o .:? "status")
      <*> (o .:? "new_project")
      <*> (o .:? "new_task")

-- | ToJSON JobCompact
instance A.ToJSON JobCompact where
  toJSON JobCompact {..} =
   _omitNulls
      [ "gid" .= jobCompactGid
      , "resource_type" .= jobCompactResourceType
      , "resource_subtype" .= jobCompactResourceSubtype
      , "status" .= jobCompactStatus
      , "new_project" .= jobCompactNewProject
      , "new_task" .= jobCompactNewTask
      ]


-- | Construct a value of type 'JobCompact' (by applying it's required fields, if any)
mkJobCompact
  :: JobCompact
mkJobCompact =
  JobCompact
  { jobCompactGid = Nothing
  , jobCompactResourceType = Nothing
  , jobCompactResourceSubtype = Nothing
  , jobCompactStatus = Nothing
  , jobCompactNewProject = Nothing
  , jobCompactNewTask = Nothing
  }

-- ** JobCompactAllOf
-- | JobCompactAllOf
-- A *job* is an object representing a process that handles asynchronous work.
data JobCompactAllOf = JobCompactAllOf
  { jobCompactAllOfResourceSubtype :: !(Maybe Text) -- ^ "resource_subtype" - The subtype of this resource. Different subtypes retain many of the same fields and behavior, but may render differently in Asana or represent resources with different semantic meaning.
  , jobCompactAllOfStatus :: !(Maybe E'Status) -- ^ "status"
  , jobCompactAllOfNewProject :: !(Maybe ProjectCompact) -- ^ "new_project"
  , jobCompactAllOfNewTask :: !(Maybe TaskCompact) -- ^ "new_task"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JobCompactAllOf
instance A.FromJSON JobCompactAllOf where
  parseJSON = A.withObject "JobCompactAllOf" $ \o ->
    JobCompactAllOf
      <$> (o .:? "resource_subtype")
      <*> (o .:? "status")
      <*> (o .:? "new_project")
      <*> (o .:? "new_task")

-- | ToJSON JobCompactAllOf
instance A.ToJSON JobCompactAllOf where
  toJSON JobCompactAllOf {..} =
   _omitNulls
      [ "resource_subtype" .= jobCompactAllOfResourceSubtype
      , "status" .= jobCompactAllOfStatus
      , "new_project" .= jobCompactAllOfNewProject
      , "new_task" .= jobCompactAllOfNewTask
      ]


-- | Construct a value of type 'JobCompactAllOf' (by applying it's required fields, if any)
mkJobCompactAllOf
  :: JobCompactAllOf
mkJobCompactAllOf =
  JobCompactAllOf
  { jobCompactAllOfResourceSubtype = Nothing
  , jobCompactAllOfStatus = Nothing
  , jobCompactAllOfNewProject = Nothing
  , jobCompactAllOfNewTask = Nothing
  }

-- ** JobResponse
-- | JobResponse
data JobResponse = JobResponse
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JobResponse
instance A.FromJSON JobResponse where
  parseJSON = A.withObject "JobResponse" $ \o ->
    pure JobResponse
      

-- | ToJSON JobResponse
instance A.ToJSON JobResponse where
  toJSON JobResponse  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'JobResponse' (by applying it's required fields, if any)
mkJobResponse
  :: JobResponse
mkJobResponse =
  JobResponse
  { 
  }

-- ** Like
-- | Like
-- An object to represent a user's like.
data Like = Like
  { likeGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the object, as a string.
  , likeUser :: !(Maybe UserCompact) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Like
instance A.FromJSON Like where
  parseJSON = A.withObject "Like" $ \o ->
    Like
      <$> (o .:? "gid")
      <*> (o .:? "user")

-- | ToJSON Like
instance A.ToJSON Like where
  toJSON Like {..} =
   _omitNulls
      [ "gid" .= likeGid
      , "user" .= likeUser
      ]


-- | Construct a value of type 'Like' (by applying it's required fields, if any)
mkLike
  :: Like
mkLike =
  Like
  { likeGid = Nothing
  , likeUser = Nothing
  }

-- ** ModifyDependenciesRequest
-- | ModifyDependenciesRequest
data ModifyDependenciesRequest = ModifyDependenciesRequest
  { modifyDependenciesRequestDependencies :: !(Maybe [Text]) -- ^ "dependencies" - An array of task gids that a task depends on.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModifyDependenciesRequest
instance A.FromJSON ModifyDependenciesRequest where
  parseJSON = A.withObject "ModifyDependenciesRequest" $ \o ->
    ModifyDependenciesRequest
      <$> (o .:? "dependencies")

-- | ToJSON ModifyDependenciesRequest
instance A.ToJSON ModifyDependenciesRequest where
  toJSON ModifyDependenciesRequest {..} =
   _omitNulls
      [ "dependencies" .= modifyDependenciesRequestDependencies
      ]


-- | Construct a value of type 'ModifyDependenciesRequest' (by applying it's required fields, if any)
mkModifyDependenciesRequest
  :: ModifyDependenciesRequest
mkModifyDependenciesRequest =
  ModifyDependenciesRequest
  { modifyDependenciesRequestDependencies = Nothing
  }

-- ** ModifyDependentsRequest
-- | ModifyDependentsRequest
-- A set of dependent tasks.
data ModifyDependentsRequest = ModifyDependentsRequest
  { modifyDependentsRequestDependents :: !(Maybe [Text]) -- ^ "dependents" - An array of task gids that are dependents of the given task.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModifyDependentsRequest
instance A.FromJSON ModifyDependentsRequest where
  parseJSON = A.withObject "ModifyDependentsRequest" $ \o ->
    ModifyDependentsRequest
      <$> (o .:? "dependents")

-- | ToJSON ModifyDependentsRequest
instance A.ToJSON ModifyDependentsRequest where
  toJSON ModifyDependentsRequest {..} =
   _omitNulls
      [ "dependents" .= modifyDependentsRequestDependents
      ]


-- | Construct a value of type 'ModifyDependentsRequest' (by applying it's required fields, if any)
mkModifyDependentsRequest
  :: ModifyDependentsRequest
mkModifyDependentsRequest =
  ModifyDependentsRequest
  { modifyDependentsRequestDependents = Nothing
  }

-- ** OrganizationExportBase
-- | OrganizationExportBase
data OrganizationExportBase = OrganizationExportBase
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationExportBase
instance A.FromJSON OrganizationExportBase where
  parseJSON = A.withObject "OrganizationExportBase" $ \o ->
    pure OrganizationExportBase
      

-- | ToJSON OrganizationExportBase
instance A.ToJSON OrganizationExportBase where
  toJSON OrganizationExportBase  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'OrganizationExportBase' (by applying it's required fields, if any)
mkOrganizationExportBase
  :: OrganizationExportBase
mkOrganizationExportBase =
  OrganizationExportBase
  { 
  }

-- ** OrganizationExportCompact
-- | OrganizationExportCompact
data OrganizationExportCompact = OrganizationExportCompact
  { organizationExportCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , organizationExportCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , organizationExportCompactCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , organizationExportCompactDownloadUrl :: !(Maybe Text) -- ^ "download_url" - Download this URL to retreive the full export of the organization in JSON format. It will be compressed in a gzip (.gz) container.  *Note: May be null if the export is still in progress or failed.  If present, this URL may only be valid for 1 hour from the time of retrieval. You should avoid persisting this URL somewhere and rather refresh on demand to ensure you do not keep stale URLs.*
  , organizationExportCompactState :: !(Maybe E'State) -- ^ "state" - The current state of the export.
  , organizationExportCompactOrganization :: !(Maybe WorkspaceCompact) -- ^ "organization"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationExportCompact
instance A.FromJSON OrganizationExportCompact where
  parseJSON = A.withObject "OrganizationExportCompact" $ \o ->
    OrganizationExportCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "created_at")
      <*> (o .:? "download_url")
      <*> (o .:? "state")
      <*> (o .:? "organization")

-- | ToJSON OrganizationExportCompact
instance A.ToJSON OrganizationExportCompact where
  toJSON OrganizationExportCompact {..} =
   _omitNulls
      [ "gid" .= organizationExportCompactGid
      , "resource_type" .= organizationExportCompactResourceType
      , "created_at" .= organizationExportCompactCreatedAt
      , "download_url" .= organizationExportCompactDownloadUrl
      , "state" .= organizationExportCompactState
      , "organization" .= organizationExportCompactOrganization
      ]


-- | Construct a value of type 'OrganizationExportCompact' (by applying it's required fields, if any)
mkOrganizationExportCompact
  :: OrganizationExportCompact
mkOrganizationExportCompact =
  OrganizationExportCompact
  { organizationExportCompactGid = Nothing
  , organizationExportCompactResourceType = Nothing
  , organizationExportCompactCreatedAt = Nothing
  , organizationExportCompactDownloadUrl = Nothing
  , organizationExportCompactState = Nothing
  , organizationExportCompactOrganization = Nothing
  }

-- ** OrganizationExportCompactAllOf
-- | OrganizationExportCompactAllOf
-- An *organization_export* object represents a request to export the complete data of an Organization in JSON format.
data OrganizationExportCompactAllOf = OrganizationExportCompactAllOf
  { organizationExportCompactAllOfCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , organizationExportCompactAllOfDownloadUrl :: !(Maybe Text) -- ^ "download_url" - Download this URL to retreive the full export of the organization in JSON format. It will be compressed in a gzip (.gz) container.  *Note: May be null if the export is still in progress or failed.  If present, this URL may only be valid for 1 hour from the time of retrieval. You should avoid persisting this URL somewhere and rather refresh on demand to ensure you do not keep stale URLs.*
  , organizationExportCompactAllOfState :: !(Maybe E'State) -- ^ "state" - The current state of the export.
  , organizationExportCompactAllOfOrganization :: !(Maybe WorkspaceCompact) -- ^ "organization"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationExportCompactAllOf
instance A.FromJSON OrganizationExportCompactAllOf where
  parseJSON = A.withObject "OrganizationExportCompactAllOf" $ \o ->
    OrganizationExportCompactAllOf
      <$> (o .:? "created_at")
      <*> (o .:? "download_url")
      <*> (o .:? "state")
      <*> (o .:? "organization")

-- | ToJSON OrganizationExportCompactAllOf
instance A.ToJSON OrganizationExportCompactAllOf where
  toJSON OrganizationExportCompactAllOf {..} =
   _omitNulls
      [ "created_at" .= organizationExportCompactAllOfCreatedAt
      , "download_url" .= organizationExportCompactAllOfDownloadUrl
      , "state" .= organizationExportCompactAllOfState
      , "organization" .= organizationExportCompactAllOfOrganization
      ]


-- | Construct a value of type 'OrganizationExportCompactAllOf' (by applying it's required fields, if any)
mkOrganizationExportCompactAllOf
  :: OrganizationExportCompactAllOf
mkOrganizationExportCompactAllOf =
  OrganizationExportCompactAllOf
  { organizationExportCompactAllOfCreatedAt = Nothing
  , organizationExportCompactAllOfDownloadUrl = Nothing
  , organizationExportCompactAllOfState = Nothing
  , organizationExportCompactAllOfOrganization = Nothing
  }

-- ** OrganizationExportRequest
-- | OrganizationExportRequest
-- An *organization_export* request starts a job to export the complete data of the given Organization.
data OrganizationExportRequest = OrganizationExportRequest
  { organizationExportRequestOrganization :: !(Maybe Text) -- ^ "organization" - Globally unique identifier for the workspace or organization.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationExportRequest
instance A.FromJSON OrganizationExportRequest where
  parseJSON = A.withObject "OrganizationExportRequest" $ \o ->
    OrganizationExportRequest
      <$> (o .:? "organization")

-- | ToJSON OrganizationExportRequest
instance A.ToJSON OrganizationExportRequest where
  toJSON OrganizationExportRequest {..} =
   _omitNulls
      [ "organization" .= organizationExportRequestOrganization
      ]


-- | Construct a value of type 'OrganizationExportRequest' (by applying it's required fields, if any)
mkOrganizationExportRequest
  :: OrganizationExportRequest
mkOrganizationExportRequest =
  OrganizationExportRequest
  { organizationExportRequestOrganization = Nothing
  }

-- ** OrganizationExportResponse
-- | OrganizationExportResponse
data OrganizationExportResponse = OrganizationExportResponse
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationExportResponse
instance A.FromJSON OrganizationExportResponse where
  parseJSON = A.withObject "OrganizationExportResponse" $ \o ->
    pure OrganizationExportResponse
      

-- | ToJSON OrganizationExportResponse
instance A.ToJSON OrganizationExportResponse where
  toJSON OrganizationExportResponse  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'OrganizationExportResponse' (by applying it's required fields, if any)
mkOrganizationExportResponse
  :: OrganizationExportResponse
mkOrganizationExportResponse =
  OrganizationExportResponse
  { 
  }

-- ** PortfolioAddItemRequest
-- | PortfolioAddItemRequest
data PortfolioAddItemRequest = PortfolioAddItemRequest
  { portfolioAddItemRequestItem :: !(Text) -- ^ /Required/ "item" - The item to add to the portfolio.
  , portfolioAddItemRequestInsertBefore :: !(Maybe Text) -- ^ "insert_before" - An id of an item in this portfolio. The new item will be added before the one specified here. &#x60;insert_before&#x60; and &#x60;insert_after&#x60; parameters cannot both be specified.
  , portfolioAddItemRequestInsertAfter :: !(Maybe Text) -- ^ "insert_after" - An id of an item in this portfolio. The new item will be added after the one specified here. &#x60;insert_before&#x60; and &#x60;insert_after&#x60; parameters cannot both be specified.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PortfolioAddItemRequest
instance A.FromJSON PortfolioAddItemRequest where
  parseJSON = A.withObject "PortfolioAddItemRequest" $ \o ->
    PortfolioAddItemRequest
      <$> (o .:  "item")
      <*> (o .:? "insert_before")
      <*> (o .:? "insert_after")

-- | ToJSON PortfolioAddItemRequest
instance A.ToJSON PortfolioAddItemRequest where
  toJSON PortfolioAddItemRequest {..} =
   _omitNulls
      [ "item" .= portfolioAddItemRequestItem
      , "insert_before" .= portfolioAddItemRequestInsertBefore
      , "insert_after" .= portfolioAddItemRequestInsertAfter
      ]


-- | Construct a value of type 'PortfolioAddItemRequest' (by applying it's required fields, if any)
mkPortfolioAddItemRequest
  :: Text -- ^ 'portfolioAddItemRequestItem': The item to add to the portfolio.
  -> PortfolioAddItemRequest
mkPortfolioAddItemRequest portfolioAddItemRequestItem =
  PortfolioAddItemRequest
  { portfolioAddItemRequestItem
  , portfolioAddItemRequestInsertBefore = Nothing
  , portfolioAddItemRequestInsertAfter = Nothing
  }

-- ** PortfolioBase
-- | PortfolioBase
data PortfolioBase = PortfolioBase
  { portfolioBaseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , portfolioBaseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , portfolioBaseName :: !(Maybe Text) -- ^ "name" - The name of the portfolio.
  , portfolioBaseColor :: !(Maybe E'Color) -- ^ "color" - Color of the portfolio.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PortfolioBase
instance A.FromJSON PortfolioBase where
  parseJSON = A.withObject "PortfolioBase" $ \o ->
    PortfolioBase
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "color")

-- | ToJSON PortfolioBase
instance A.ToJSON PortfolioBase where
  toJSON PortfolioBase {..} =
   _omitNulls
      [ "gid" .= portfolioBaseGid
      , "resource_type" .= portfolioBaseResourceType
      , "name" .= portfolioBaseName
      , "color" .= portfolioBaseColor
      ]


-- | Construct a value of type 'PortfolioBase' (by applying it's required fields, if any)
mkPortfolioBase
  :: PortfolioBase
mkPortfolioBase =
  PortfolioBase
  { portfolioBaseGid = Nothing
  , portfolioBaseResourceType = Nothing
  , portfolioBaseName = Nothing
  , portfolioBaseColor = Nothing
  }

-- ** PortfolioBaseAllOf
-- | PortfolioBaseAllOf
data PortfolioBaseAllOf = PortfolioBaseAllOf
  { portfolioBaseAllOfColor :: !(Maybe E'Color) -- ^ "color" - Color of the portfolio.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PortfolioBaseAllOf
instance A.FromJSON PortfolioBaseAllOf where
  parseJSON = A.withObject "PortfolioBaseAllOf" $ \o ->
    PortfolioBaseAllOf
      <$> (o .:? "color")

-- | ToJSON PortfolioBaseAllOf
instance A.ToJSON PortfolioBaseAllOf where
  toJSON PortfolioBaseAllOf {..} =
   _omitNulls
      [ "color" .= portfolioBaseAllOfColor
      ]


-- | Construct a value of type 'PortfolioBaseAllOf' (by applying it's required fields, if any)
mkPortfolioBaseAllOf
  :: PortfolioBaseAllOf
mkPortfolioBaseAllOf =
  PortfolioBaseAllOf
  { portfolioBaseAllOfColor = Nothing
  }

-- ** PortfolioCompact
-- | PortfolioCompact
data PortfolioCompact = PortfolioCompact
  { portfolioCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , portfolioCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , portfolioCompactName :: !(Maybe Text) -- ^ "name" - The name of the portfolio.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PortfolioCompact
instance A.FromJSON PortfolioCompact where
  parseJSON = A.withObject "PortfolioCompact" $ \o ->
    PortfolioCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")

-- | ToJSON PortfolioCompact
instance A.ToJSON PortfolioCompact where
  toJSON PortfolioCompact {..} =
   _omitNulls
      [ "gid" .= portfolioCompactGid
      , "resource_type" .= portfolioCompactResourceType
      , "name" .= portfolioCompactName
      ]


-- | Construct a value of type 'PortfolioCompact' (by applying it's required fields, if any)
mkPortfolioCompact
  :: PortfolioCompact
mkPortfolioCompact =
  PortfolioCompact
  { portfolioCompactGid = Nothing
  , portfolioCompactResourceType = Nothing
  , portfolioCompactName = Nothing
  }

-- ** PortfolioCompactAllOf
-- | PortfolioCompactAllOf
-- A *portfolio* gives a high-level overview of the status of multiple initiatives in Asana. Portfolios provide a dashboard overview of the state of multiple projects, including a progress report and the most recent [project status](#asana-project-statuses) update. Portfolios have some restrictions on size. Each portfolio has a max of 250 items and, like projects, a max of 20 custom fields.
data PortfolioCompactAllOf = PortfolioCompactAllOf
  { portfolioCompactAllOfName :: !(Maybe Text) -- ^ "name" - The name of the portfolio.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PortfolioCompactAllOf
instance A.FromJSON PortfolioCompactAllOf where
  parseJSON = A.withObject "PortfolioCompactAllOf" $ \o ->
    PortfolioCompactAllOf
      <$> (o .:? "name")

-- | ToJSON PortfolioCompactAllOf
instance A.ToJSON PortfolioCompactAllOf where
  toJSON PortfolioCompactAllOf {..} =
   _omitNulls
      [ "name" .= portfolioCompactAllOfName
      ]


-- | Construct a value of type 'PortfolioCompactAllOf' (by applying it's required fields, if any)
mkPortfolioCompactAllOf
  :: PortfolioCompactAllOf
mkPortfolioCompactAllOf =
  PortfolioCompactAllOf
  { portfolioCompactAllOfName = Nothing
  }

-- ** PortfolioMembershipBase
-- | PortfolioMembershipBase
data PortfolioMembershipBase = PortfolioMembershipBase
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PortfolioMembershipBase
instance A.FromJSON PortfolioMembershipBase where
  parseJSON = A.withObject "PortfolioMembershipBase" $ \o ->
    pure PortfolioMembershipBase
      

-- | ToJSON PortfolioMembershipBase
instance A.ToJSON PortfolioMembershipBase where
  toJSON PortfolioMembershipBase  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'PortfolioMembershipBase' (by applying it's required fields, if any)
mkPortfolioMembershipBase
  :: PortfolioMembershipBase
mkPortfolioMembershipBase =
  PortfolioMembershipBase
  { 
  }

-- ** PortfolioMembershipCompact
-- | PortfolioMembershipCompact
data PortfolioMembershipCompact = PortfolioMembershipCompact
  { portfolioMembershipCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , portfolioMembershipCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , portfolioMembershipCompactPortfolio :: !(Maybe PortfolioCompact) -- ^ "portfolio"
  , portfolioMembershipCompactUser :: !(Maybe UserCompact) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PortfolioMembershipCompact
instance A.FromJSON PortfolioMembershipCompact where
  parseJSON = A.withObject "PortfolioMembershipCompact" $ \o ->
    PortfolioMembershipCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "portfolio")
      <*> (o .:? "user")

-- | ToJSON PortfolioMembershipCompact
instance A.ToJSON PortfolioMembershipCompact where
  toJSON PortfolioMembershipCompact {..} =
   _omitNulls
      [ "gid" .= portfolioMembershipCompactGid
      , "resource_type" .= portfolioMembershipCompactResourceType
      , "portfolio" .= portfolioMembershipCompactPortfolio
      , "user" .= portfolioMembershipCompactUser
      ]


-- | Construct a value of type 'PortfolioMembershipCompact' (by applying it's required fields, if any)
mkPortfolioMembershipCompact
  :: PortfolioMembershipCompact
mkPortfolioMembershipCompact =
  PortfolioMembershipCompact
  { portfolioMembershipCompactGid = Nothing
  , portfolioMembershipCompactResourceType = Nothing
  , portfolioMembershipCompactPortfolio = Nothing
  , portfolioMembershipCompactUser = Nothing
  }

-- ** PortfolioMembershipCompactAllOf
-- | PortfolioMembershipCompactAllOf
-- This object determines if a user is a member of a portfolio.
data PortfolioMembershipCompactAllOf = PortfolioMembershipCompactAllOf
  { portfolioMembershipCompactAllOfPortfolio :: !(Maybe PortfolioCompact) -- ^ "portfolio"
  , portfolioMembershipCompactAllOfUser :: !(Maybe UserCompact) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PortfolioMembershipCompactAllOf
instance A.FromJSON PortfolioMembershipCompactAllOf where
  parseJSON = A.withObject "PortfolioMembershipCompactAllOf" $ \o ->
    PortfolioMembershipCompactAllOf
      <$> (o .:? "portfolio")
      <*> (o .:? "user")

-- | ToJSON PortfolioMembershipCompactAllOf
instance A.ToJSON PortfolioMembershipCompactAllOf where
  toJSON PortfolioMembershipCompactAllOf {..} =
   _omitNulls
      [ "portfolio" .= portfolioMembershipCompactAllOfPortfolio
      , "user" .= portfolioMembershipCompactAllOfUser
      ]


-- | Construct a value of type 'PortfolioMembershipCompactAllOf' (by applying it's required fields, if any)
mkPortfolioMembershipCompactAllOf
  :: PortfolioMembershipCompactAllOf
mkPortfolioMembershipCompactAllOf =
  PortfolioMembershipCompactAllOf
  { portfolioMembershipCompactAllOfPortfolio = Nothing
  , portfolioMembershipCompactAllOfUser = Nothing
  }

-- ** PortfolioMembershipResponse
-- | PortfolioMembershipResponse
data PortfolioMembershipResponse = PortfolioMembershipResponse
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PortfolioMembershipResponse
instance A.FromJSON PortfolioMembershipResponse where
  parseJSON = A.withObject "PortfolioMembershipResponse" $ \o ->
    pure PortfolioMembershipResponse
      

-- | ToJSON PortfolioMembershipResponse
instance A.ToJSON PortfolioMembershipResponse where
  toJSON PortfolioMembershipResponse  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'PortfolioMembershipResponse' (by applying it's required fields, if any)
mkPortfolioMembershipResponse
  :: PortfolioMembershipResponse
mkPortfolioMembershipResponse =
  PortfolioMembershipResponse
  { 
  }

-- ** PortfolioRemoveItemRequest
-- | PortfolioRemoveItemRequest
data PortfolioRemoveItemRequest = PortfolioRemoveItemRequest
  { portfolioRemoveItemRequestItem :: !(Text) -- ^ /Required/ "item" - The item to remove from the portfolio.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PortfolioRemoveItemRequest
instance A.FromJSON PortfolioRemoveItemRequest where
  parseJSON = A.withObject "PortfolioRemoveItemRequest" $ \o ->
    PortfolioRemoveItemRequest
      <$> (o .:  "item")

-- | ToJSON PortfolioRemoveItemRequest
instance A.ToJSON PortfolioRemoveItemRequest where
  toJSON PortfolioRemoveItemRequest {..} =
   _omitNulls
      [ "item" .= portfolioRemoveItemRequestItem
      ]


-- | Construct a value of type 'PortfolioRemoveItemRequest' (by applying it's required fields, if any)
mkPortfolioRemoveItemRequest
  :: Text -- ^ 'portfolioRemoveItemRequestItem': The item to remove from the portfolio.
  -> PortfolioRemoveItemRequest
mkPortfolioRemoveItemRequest portfolioRemoveItemRequestItem =
  PortfolioRemoveItemRequest
  { portfolioRemoveItemRequestItem
  }

-- ** PortfolioRequest
-- | PortfolioRequest
data PortfolioRequest = PortfolioRequest
  { portfolioRequestGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , portfolioRequestResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , portfolioRequestName :: !(Maybe Text) -- ^ "name" - The name of the portfolio.
  , portfolioRequestColor :: !(Maybe E'Color) -- ^ "color" - Color of the portfolio.
  , portfolioRequestMembers :: !(Maybe [Text]) -- ^ "members" - An array of strings identifying users. These can either be the string \&quot;me\&quot;, an email, or the gid of a user.
  , portfolioRequestWorkspace :: !(Maybe Text) -- ^ "workspace" - Gid of an object.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PortfolioRequest
instance A.FromJSON PortfolioRequest where
  parseJSON = A.withObject "PortfolioRequest" $ \o ->
    PortfolioRequest
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "color")
      <*> (o .:? "members")
      <*> (o .:? "workspace")

-- | ToJSON PortfolioRequest
instance A.ToJSON PortfolioRequest where
  toJSON PortfolioRequest {..} =
   _omitNulls
      [ "gid" .= portfolioRequestGid
      , "resource_type" .= portfolioRequestResourceType
      , "name" .= portfolioRequestName
      , "color" .= portfolioRequestColor
      , "members" .= portfolioRequestMembers
      , "workspace" .= portfolioRequestWorkspace
      ]


-- | Construct a value of type 'PortfolioRequest' (by applying it's required fields, if any)
mkPortfolioRequest
  :: PortfolioRequest
mkPortfolioRequest =
  PortfolioRequest
  { portfolioRequestGid = Nothing
  , portfolioRequestResourceType = Nothing
  , portfolioRequestName = Nothing
  , portfolioRequestColor = Nothing
  , portfolioRequestMembers = Nothing
  , portfolioRequestWorkspace = Nothing
  }

-- ** PortfolioRequestAllOf
-- | PortfolioRequestAllOf
data PortfolioRequestAllOf = PortfolioRequestAllOf
  { portfolioRequestAllOfMembers :: !(Maybe [Text]) -- ^ "members" - An array of strings identifying users. These can either be the string \&quot;me\&quot;, an email, or the gid of a user.
  , portfolioRequestAllOfWorkspace :: !(Maybe Text) -- ^ "workspace" - Gid of an object.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PortfolioRequestAllOf
instance A.FromJSON PortfolioRequestAllOf where
  parseJSON = A.withObject "PortfolioRequestAllOf" $ \o ->
    PortfolioRequestAllOf
      <$> (o .:? "members")
      <*> (o .:? "workspace")

-- | ToJSON PortfolioRequestAllOf
instance A.ToJSON PortfolioRequestAllOf where
  toJSON PortfolioRequestAllOf {..} =
   _omitNulls
      [ "members" .= portfolioRequestAllOfMembers
      , "workspace" .= portfolioRequestAllOfWorkspace
      ]


-- | Construct a value of type 'PortfolioRequestAllOf' (by applying it's required fields, if any)
mkPortfolioRequestAllOf
  :: PortfolioRequestAllOf
mkPortfolioRequestAllOf =
  PortfolioRequestAllOf
  { portfolioRequestAllOfMembers = Nothing
  , portfolioRequestAllOfWorkspace = Nothing
  }

-- ** PortfolioResponse
-- | PortfolioResponse
data PortfolioResponse = PortfolioResponse
  { portfolioResponseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , portfolioResponseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , portfolioResponseName :: !(Maybe Text) -- ^ "name" - The name of the portfolio.
  , portfolioResponseColor :: !(Maybe E'Color) -- ^ "color" - Color of the portfolio.
  , portfolioResponseCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , portfolioResponseCreatedBy :: !(Maybe UserCompact) -- ^ "created_by"
  , portfolioResponseCustomFieldSettings :: !(Maybe [CustomFieldSettingResponse]) -- ^ "custom_field_settings" - Array of custom field settings applied to the portfolio.
  , portfolioResponseMembers :: !(Maybe [UserCompact]) -- ^ "members"
  , portfolioResponseOwner :: !(Maybe UserCompact) -- ^ "owner"
  , portfolioResponseWorkspace :: !(Maybe WorkspaceCompact) -- ^ "workspace"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PortfolioResponse
instance A.FromJSON PortfolioResponse where
  parseJSON = A.withObject "PortfolioResponse" $ \o ->
    PortfolioResponse
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "color")
      <*> (o .:? "created_at")
      <*> (o .:? "created_by")
      <*> (o .:? "custom_field_settings")
      <*> (o .:? "members")
      <*> (o .:? "owner")
      <*> (o .:? "workspace")

-- | ToJSON PortfolioResponse
instance A.ToJSON PortfolioResponse where
  toJSON PortfolioResponse {..} =
   _omitNulls
      [ "gid" .= portfolioResponseGid
      , "resource_type" .= portfolioResponseResourceType
      , "name" .= portfolioResponseName
      , "color" .= portfolioResponseColor
      , "created_at" .= portfolioResponseCreatedAt
      , "created_by" .= portfolioResponseCreatedBy
      , "custom_field_settings" .= portfolioResponseCustomFieldSettings
      , "members" .= portfolioResponseMembers
      , "owner" .= portfolioResponseOwner
      , "workspace" .= portfolioResponseWorkspace
      ]


-- | Construct a value of type 'PortfolioResponse' (by applying it's required fields, if any)
mkPortfolioResponse
  :: PortfolioResponse
mkPortfolioResponse =
  PortfolioResponse
  { portfolioResponseGid = Nothing
  , portfolioResponseResourceType = Nothing
  , portfolioResponseName = Nothing
  , portfolioResponseColor = Nothing
  , portfolioResponseCreatedAt = Nothing
  , portfolioResponseCreatedBy = Nothing
  , portfolioResponseCustomFieldSettings = Nothing
  , portfolioResponseMembers = Nothing
  , portfolioResponseOwner = Nothing
  , portfolioResponseWorkspace = Nothing
  }

-- ** PortfolioResponseAllOf
-- | PortfolioResponseAllOf
data PortfolioResponseAllOf = PortfolioResponseAllOf
  { portfolioResponseAllOfCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , portfolioResponseAllOfCreatedBy :: !(Maybe UserCompact) -- ^ "created_by"
  , portfolioResponseAllOfCustomFieldSettings :: !(Maybe [CustomFieldSettingResponse]) -- ^ "custom_field_settings" - Array of custom field settings applied to the portfolio.
  , portfolioResponseAllOfMembers :: !(Maybe [UserCompact]) -- ^ "members"
  , portfolioResponseAllOfOwner :: !(Maybe UserCompact) -- ^ "owner"
  , portfolioResponseAllOfWorkspace :: !(Maybe WorkspaceCompact) -- ^ "workspace"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PortfolioResponseAllOf
instance A.FromJSON PortfolioResponseAllOf where
  parseJSON = A.withObject "PortfolioResponseAllOf" $ \o ->
    PortfolioResponseAllOf
      <$> (o .:? "created_at")
      <*> (o .:? "created_by")
      <*> (o .:? "custom_field_settings")
      <*> (o .:? "members")
      <*> (o .:? "owner")
      <*> (o .:? "workspace")

-- | ToJSON PortfolioResponseAllOf
instance A.ToJSON PortfolioResponseAllOf where
  toJSON PortfolioResponseAllOf {..} =
   _omitNulls
      [ "created_at" .= portfolioResponseAllOfCreatedAt
      , "created_by" .= portfolioResponseAllOfCreatedBy
      , "custom_field_settings" .= portfolioResponseAllOfCustomFieldSettings
      , "members" .= portfolioResponseAllOfMembers
      , "owner" .= portfolioResponseAllOfOwner
      , "workspace" .= portfolioResponseAllOfWorkspace
      ]


-- | Construct a value of type 'PortfolioResponseAllOf' (by applying it's required fields, if any)
mkPortfolioResponseAllOf
  :: PortfolioResponseAllOf
mkPortfolioResponseAllOf =
  PortfolioResponseAllOf
  { portfolioResponseAllOfCreatedAt = Nothing
  , portfolioResponseAllOfCreatedBy = Nothing
  , portfolioResponseAllOfCustomFieldSettings = Nothing
  , portfolioResponseAllOfMembers = Nothing
  , portfolioResponseAllOfOwner = Nothing
  , portfolioResponseAllOfWorkspace = Nothing
  }

-- ** Preview
-- | Preview
-- A collection of rich text that will be displayed as a preview to another app.  This is read-only except for a small group of whitelisted apps.
data Preview = Preview
  { previewFallback :: !(Maybe Text) -- ^ "fallback" - Some fallback text to display if unable to display the full preview.
  , previewFooter :: !(Maybe Text) -- ^ "footer" - Text to display in the footer.
  , previewHeader :: !(Maybe Text) -- ^ "header" - Text to display in the header.
  , previewHeaderLink :: !(Maybe Text) -- ^ "header_link" - Where the header will link to.
  , previewHtmlText :: !(Maybe Text) -- ^ "html_text" - HTML formatted text for the body of the preview.
  , previewText :: !(Maybe Text) -- ^ "text" - Text for the body of the preview.
  , previewTitle :: !(Maybe Text) -- ^ "title" - Text to display as the title.
  , previewTitleLink :: !(Maybe Text) -- ^ "title_link" - Where to title will link to.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Preview
instance A.FromJSON Preview where
  parseJSON = A.withObject "Preview" $ \o ->
    Preview
      <$> (o .:? "fallback")
      <*> (o .:? "footer")
      <*> (o .:? "header")
      <*> (o .:? "header_link")
      <*> (o .:? "html_text")
      <*> (o .:? "text")
      <*> (o .:? "title")
      <*> (o .:? "title_link")

-- | ToJSON Preview
instance A.ToJSON Preview where
  toJSON Preview {..} =
   _omitNulls
      [ "fallback" .= previewFallback
      , "footer" .= previewFooter
      , "header" .= previewHeader
      , "header_link" .= previewHeaderLink
      , "html_text" .= previewHtmlText
      , "text" .= previewText
      , "title" .= previewTitle
      , "title_link" .= previewTitleLink
      ]


-- | Construct a value of type 'Preview' (by applying it's required fields, if any)
mkPreview
  :: Preview
mkPreview =
  Preview
  { previewFallback = Nothing
  , previewFooter = Nothing
  , previewHeader = Nothing
  , previewHeaderLink = Nothing
  , previewHtmlText = Nothing
  , previewText = Nothing
  , previewTitle = Nothing
  , previewTitleLink = Nothing
  }

-- ** ProjectBase
-- | ProjectBase
data ProjectBase = ProjectBase
  { projectBaseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , projectBaseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , projectBaseName :: !(Maybe Text) -- ^ "name" - Name of the project. This is generally a short sentence fragment that fits on a line in the UI for maximum readability. However, it can be longer.
  , projectBaseArchived :: !(Maybe Bool) -- ^ "archived" - True if the project is archived, false if not. Archived projects do not show in the UI by default and may be treated differently for queries.
  , projectBaseColor :: !(Maybe E'Color) -- ^ "color" - Color of the project.
  , projectBaseCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , projectBaseCurrentStatus :: !(Maybe ProjectStatusResponse) -- ^ "current_status"
  , projectBaseCustomFieldSettings :: !(Maybe [CustomFieldSettingCompact]) -- ^ "custom_field_settings" - Array of Custom Field Settings (in compact form).
  , projectBaseDefaultView :: !(Maybe E'DefaultView) -- ^ "default_view" - The default view (list, board, calendar, or timeline) of a project.
  , projectBaseDueDate :: !(Maybe DateTime) -- ^ "due_date" - *Deprecated: new integrations should prefer the due_on field.*
  , projectBaseDueOn :: !(Maybe DateTime) -- ^ "due_on" - The day on which this project is due. This takes a date with format YYYY-MM-DD.
  , projectBaseHtmlNotes :: !(Maybe Text) -- ^ "html_notes" - [Opt In](#input-output-options). The notes of the project with formatting as HTML.
  , projectBaseIsTemplate :: !(Maybe Bool) -- ^ "is_template" - [Opt In](#input-output-options). Determines if the project is a template.
  , projectBaseMembers :: !(Maybe [UserCompact]) -- ^ "members" - Array of users who are members of this project.
  , projectBaseModifiedAt :: !(Maybe DateTime) -- ^ "modified_at" - The time at which this project was last modified. *Note: This does not currently reflect any changes in associations such as tasks or comments that may have been added or removed from the project.*
  , projectBaseNotes :: !(Maybe Text) -- ^ "notes" - More detailed, free-form textual information associated with the project.
  , projectBasePublic :: !(Maybe Bool) -- ^ "public" - True if the project is public to the organization. If false, do not share this project with other users in this organization without explicitly checking to see if they have access.
  , projectBaseStartOn :: !(Maybe Date) -- ^ "start_on" - The day on which work for this project begins, or null if the project has no start date. This takes a date with &#x60;YYYY-MM-DD&#x60; format. *Note: &#x60;due_on&#x60; or &#x60;due_at&#x60; must be present in the request when setting or unsetting the &#x60;start_on&#x60; parameter.*
  , projectBaseWorkspace :: !(Maybe WorkspaceCompact) -- ^ "workspace"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectBase
instance A.FromJSON ProjectBase where
  parseJSON = A.withObject "ProjectBase" $ \o ->
    ProjectBase
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "archived")
      <*> (o .:? "color")
      <*> (o .:? "created_at")
      <*> (o .:? "current_status")
      <*> (o .:? "custom_field_settings")
      <*> (o .:? "default_view")
      <*> (o .:? "due_date")
      <*> (o .:? "due_on")
      <*> (o .:? "html_notes")
      <*> (o .:? "is_template")
      <*> (o .:? "members")
      <*> (o .:? "modified_at")
      <*> (o .:? "notes")
      <*> (o .:? "public")
      <*> (o .:? "start_on")
      <*> (o .:? "workspace")

-- | ToJSON ProjectBase
instance A.ToJSON ProjectBase where
  toJSON ProjectBase {..} =
   _omitNulls
      [ "gid" .= projectBaseGid
      , "resource_type" .= projectBaseResourceType
      , "name" .= projectBaseName
      , "archived" .= projectBaseArchived
      , "color" .= projectBaseColor
      , "created_at" .= projectBaseCreatedAt
      , "current_status" .= projectBaseCurrentStatus
      , "custom_field_settings" .= projectBaseCustomFieldSettings
      , "default_view" .= projectBaseDefaultView
      , "due_date" .= projectBaseDueDate
      , "due_on" .= projectBaseDueOn
      , "html_notes" .= projectBaseHtmlNotes
      , "is_template" .= projectBaseIsTemplate
      , "members" .= projectBaseMembers
      , "modified_at" .= projectBaseModifiedAt
      , "notes" .= projectBaseNotes
      , "public" .= projectBasePublic
      , "start_on" .= projectBaseStartOn
      , "workspace" .= projectBaseWorkspace
      ]


-- | Construct a value of type 'ProjectBase' (by applying it's required fields, if any)
mkProjectBase
  :: ProjectBase
mkProjectBase =
  ProjectBase
  { projectBaseGid = Nothing
  , projectBaseResourceType = Nothing
  , projectBaseName = Nothing
  , projectBaseArchived = Nothing
  , projectBaseColor = Nothing
  , projectBaseCreatedAt = Nothing
  , projectBaseCurrentStatus = Nothing
  , projectBaseCustomFieldSettings = Nothing
  , projectBaseDefaultView = Nothing
  , projectBaseDueDate = Nothing
  , projectBaseDueOn = Nothing
  , projectBaseHtmlNotes = Nothing
  , projectBaseIsTemplate = Nothing
  , projectBaseMembers = Nothing
  , projectBaseModifiedAt = Nothing
  , projectBaseNotes = Nothing
  , projectBasePublic = Nothing
  , projectBaseStartOn = Nothing
  , projectBaseWorkspace = Nothing
  }

-- ** ProjectBaseAllOf
-- | ProjectBaseAllOf
data ProjectBaseAllOf = ProjectBaseAllOf
  { projectBaseAllOfArchived :: !(Maybe Bool) -- ^ "archived" - True if the project is archived, false if not. Archived projects do not show in the UI by default and may be treated differently for queries.
  , projectBaseAllOfColor :: !(Maybe E'Color) -- ^ "color" - Color of the project.
  , projectBaseAllOfCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , projectBaseAllOfCurrentStatus :: !(Maybe ProjectStatusResponse) -- ^ "current_status"
  , projectBaseAllOfCustomFieldSettings :: !(Maybe [CustomFieldSettingCompact]) -- ^ "custom_field_settings" - Array of Custom Field Settings (in compact form).
  , projectBaseAllOfDefaultView :: !(Maybe E'DefaultView) -- ^ "default_view" - The default view (list, board, calendar, or timeline) of a project.
  , projectBaseAllOfDueDate :: !(Maybe DateTime) -- ^ "due_date" - *Deprecated: new integrations should prefer the due_on field.*
  , projectBaseAllOfDueOn :: !(Maybe DateTime) -- ^ "due_on" - The day on which this project is due. This takes a date with format YYYY-MM-DD.
  , projectBaseAllOfHtmlNotes :: !(Maybe Text) -- ^ "html_notes" - [Opt In](#input-output-options). The notes of the project with formatting as HTML.
  , projectBaseAllOfIsTemplate :: !(Maybe Bool) -- ^ "is_template" - [Opt In](#input-output-options). Determines if the project is a template.
  , projectBaseAllOfMembers :: !(Maybe [UserCompact]) -- ^ "members" - Array of users who are members of this project.
  , projectBaseAllOfModifiedAt :: !(Maybe DateTime) -- ^ "modified_at" - The time at which this project was last modified. *Note: This does not currently reflect any changes in associations such as tasks or comments that may have been added or removed from the project.*
  , projectBaseAllOfNotes :: !(Maybe Text) -- ^ "notes" - More detailed, free-form textual information associated with the project.
  , projectBaseAllOfPublic :: !(Maybe Bool) -- ^ "public" - True if the project is public to the organization. If false, do not share this project with other users in this organization without explicitly checking to see if they have access.
  , projectBaseAllOfStartOn :: !(Maybe Date) -- ^ "start_on" - The day on which work for this project begins, or null if the project has no start date. This takes a date with &#x60;YYYY-MM-DD&#x60; format. *Note: &#x60;due_on&#x60; or &#x60;due_at&#x60; must be present in the request when setting or unsetting the &#x60;start_on&#x60; parameter.*
  , projectBaseAllOfWorkspace :: !(Maybe WorkspaceCompact) -- ^ "workspace"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectBaseAllOf
instance A.FromJSON ProjectBaseAllOf where
  parseJSON = A.withObject "ProjectBaseAllOf" $ \o ->
    ProjectBaseAllOf
      <$> (o .:? "archived")
      <*> (o .:? "color")
      <*> (o .:? "created_at")
      <*> (o .:? "current_status")
      <*> (o .:? "custom_field_settings")
      <*> (o .:? "default_view")
      <*> (o .:? "due_date")
      <*> (o .:? "due_on")
      <*> (o .:? "html_notes")
      <*> (o .:? "is_template")
      <*> (o .:? "members")
      <*> (o .:? "modified_at")
      <*> (o .:? "notes")
      <*> (o .:? "public")
      <*> (o .:? "start_on")
      <*> (o .:? "workspace")

-- | ToJSON ProjectBaseAllOf
instance A.ToJSON ProjectBaseAllOf where
  toJSON ProjectBaseAllOf {..} =
   _omitNulls
      [ "archived" .= projectBaseAllOfArchived
      , "color" .= projectBaseAllOfColor
      , "created_at" .= projectBaseAllOfCreatedAt
      , "current_status" .= projectBaseAllOfCurrentStatus
      , "custom_field_settings" .= projectBaseAllOfCustomFieldSettings
      , "default_view" .= projectBaseAllOfDefaultView
      , "due_date" .= projectBaseAllOfDueDate
      , "due_on" .= projectBaseAllOfDueOn
      , "html_notes" .= projectBaseAllOfHtmlNotes
      , "is_template" .= projectBaseAllOfIsTemplate
      , "members" .= projectBaseAllOfMembers
      , "modified_at" .= projectBaseAllOfModifiedAt
      , "notes" .= projectBaseAllOfNotes
      , "public" .= projectBaseAllOfPublic
      , "start_on" .= projectBaseAllOfStartOn
      , "workspace" .= projectBaseAllOfWorkspace
      ]


-- | Construct a value of type 'ProjectBaseAllOf' (by applying it's required fields, if any)
mkProjectBaseAllOf
  :: ProjectBaseAllOf
mkProjectBaseAllOf =
  ProjectBaseAllOf
  { projectBaseAllOfArchived = Nothing
  , projectBaseAllOfColor = Nothing
  , projectBaseAllOfCreatedAt = Nothing
  , projectBaseAllOfCurrentStatus = Nothing
  , projectBaseAllOfCustomFieldSettings = Nothing
  , projectBaseAllOfDefaultView = Nothing
  , projectBaseAllOfDueDate = Nothing
  , projectBaseAllOfDueOn = Nothing
  , projectBaseAllOfHtmlNotes = Nothing
  , projectBaseAllOfIsTemplate = Nothing
  , projectBaseAllOfMembers = Nothing
  , projectBaseAllOfModifiedAt = Nothing
  , projectBaseAllOfNotes = Nothing
  , projectBaseAllOfPublic = Nothing
  , projectBaseAllOfStartOn = Nothing
  , projectBaseAllOfWorkspace = Nothing
  }

-- ** ProjectCompact
-- | ProjectCompact
data ProjectCompact = ProjectCompact
  { projectCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , projectCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , projectCompactName :: !(Maybe Text) -- ^ "name" - Name of the project. This is generally a short sentence fragment that fits on a line in the UI for maximum readability. However, it can be longer.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectCompact
instance A.FromJSON ProjectCompact where
  parseJSON = A.withObject "ProjectCompact" $ \o ->
    ProjectCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")

-- | ToJSON ProjectCompact
instance A.ToJSON ProjectCompact where
  toJSON ProjectCompact {..} =
   _omitNulls
      [ "gid" .= projectCompactGid
      , "resource_type" .= projectCompactResourceType
      , "name" .= projectCompactName
      ]


-- | Construct a value of type 'ProjectCompact' (by applying it's required fields, if any)
mkProjectCompact
  :: ProjectCompact
mkProjectCompact =
  ProjectCompact
  { projectCompactGid = Nothing
  , projectCompactResourceType = Nothing
  , projectCompactName = Nothing
  }

-- ** ProjectCompactAllOf
-- | ProjectCompactAllOf
-- A *project* represents a prioritized list of tasks in Asana or a board with columns of tasks represented as cards. It exists in a single workspace or organization and is accessible to a subset of users in that workspace or organization, depending on its permissions.
data ProjectCompactAllOf = ProjectCompactAllOf
  { projectCompactAllOfName :: !(Maybe Text) -- ^ "name" - Name of the project. This is generally a short sentence fragment that fits on a line in the UI for maximum readability. However, it can be longer.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectCompactAllOf
instance A.FromJSON ProjectCompactAllOf where
  parseJSON = A.withObject "ProjectCompactAllOf" $ \o ->
    ProjectCompactAllOf
      <$> (o .:? "name")

-- | ToJSON ProjectCompactAllOf
instance A.ToJSON ProjectCompactAllOf where
  toJSON ProjectCompactAllOf {..} =
   _omitNulls
      [ "name" .= projectCompactAllOfName
      ]


-- | Construct a value of type 'ProjectCompactAllOf' (by applying it's required fields, if any)
mkProjectCompactAllOf
  :: ProjectCompactAllOf
mkProjectCompactAllOf =
  ProjectCompactAllOf
  { projectCompactAllOfName = Nothing
  }

-- ** ProjectDuplicateRequest
-- | ProjectDuplicateRequest
data ProjectDuplicateRequest = ProjectDuplicateRequest
  { projectDuplicateRequestName :: !(Text) -- ^ /Required/ "name" - The name of the new project.
  , projectDuplicateRequestTeam :: !(Maybe Text) -- ^ "team" - Sets the team of the new project. If team is not defined, the new project will be in the same team as the the original project.
  , projectDuplicateRequestInclude :: !(Maybe E'Include) -- ^ "include" - The elements that will be duplicated to the new project. Tasks are always included.
  , projectDuplicateRequestScheduleDates :: !(Maybe ProjectDuplicateRequestScheduleDates) -- ^ "schedule_dates"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectDuplicateRequest
instance A.FromJSON ProjectDuplicateRequest where
  parseJSON = A.withObject "ProjectDuplicateRequest" $ \o ->
    ProjectDuplicateRequest
      <$> (o .:  "name")
      <*> (o .:? "team")
      <*> (o .:? "include")
      <*> (o .:? "schedule_dates")

-- | ToJSON ProjectDuplicateRequest
instance A.ToJSON ProjectDuplicateRequest where
  toJSON ProjectDuplicateRequest {..} =
   _omitNulls
      [ "name" .= projectDuplicateRequestName
      , "team" .= projectDuplicateRequestTeam
      , "include" .= projectDuplicateRequestInclude
      , "schedule_dates" .= projectDuplicateRequestScheduleDates
      ]


-- | Construct a value of type 'ProjectDuplicateRequest' (by applying it's required fields, if any)
mkProjectDuplicateRequest
  :: Text -- ^ 'projectDuplicateRequestName': The name of the new project.
  -> ProjectDuplicateRequest
mkProjectDuplicateRequest projectDuplicateRequestName =
  ProjectDuplicateRequest
  { projectDuplicateRequestName
  , projectDuplicateRequestTeam = Nothing
  , projectDuplicateRequestInclude = Nothing
  , projectDuplicateRequestScheduleDates = Nothing
  }

-- ** ProjectDuplicateRequestScheduleDates
-- | ProjectDuplicateRequestScheduleDates
-- A dictionary of options to auto-shift dates. `task_dates` must be included to use this option. Requires either `start_on` or `due_on`, but not both.
data ProjectDuplicateRequestScheduleDates = ProjectDuplicateRequestScheduleDates
  { projectDuplicateRequestScheduleDatesShouldSkipWeekends :: !(Bool) -- ^ /Required/ "should_skip_weekends" - Determines if the auto-shifted dates should skip weekends.
  , projectDuplicateRequestScheduleDatesDueOn :: !(Maybe Text) -- ^ "due_on" - Sets the last due date in the duplicated project to the given date. The rest of the due dates will be offset by the same amount as the due dates in the original project.
  , projectDuplicateRequestScheduleDatesStartOn :: !(Maybe Text) -- ^ "start_on" - Sets the first start date in the duplicated project to the given date. The rest of the start dates will be offset by the same amount as the start dates in the original project.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectDuplicateRequestScheduleDates
instance A.FromJSON ProjectDuplicateRequestScheduleDates where
  parseJSON = A.withObject "ProjectDuplicateRequestScheduleDates" $ \o ->
    ProjectDuplicateRequestScheduleDates
      <$> (o .:  "should_skip_weekends")
      <*> (o .:? "due_on")
      <*> (o .:? "start_on")

-- | ToJSON ProjectDuplicateRequestScheduleDates
instance A.ToJSON ProjectDuplicateRequestScheduleDates where
  toJSON ProjectDuplicateRequestScheduleDates {..} =
   _omitNulls
      [ "should_skip_weekends" .= projectDuplicateRequestScheduleDatesShouldSkipWeekends
      , "due_on" .= projectDuplicateRequestScheduleDatesDueOn
      , "start_on" .= projectDuplicateRequestScheduleDatesStartOn
      ]


-- | Construct a value of type 'ProjectDuplicateRequestScheduleDates' (by applying it's required fields, if any)
mkProjectDuplicateRequestScheduleDates
  :: Bool -- ^ 'projectDuplicateRequestScheduleDatesShouldSkipWeekends': Determines if the auto-shifted dates should skip weekends.
  -> ProjectDuplicateRequestScheduleDates
mkProjectDuplicateRequestScheduleDates projectDuplicateRequestScheduleDatesShouldSkipWeekends =
  ProjectDuplicateRequestScheduleDates
  { projectDuplicateRequestScheduleDatesShouldSkipWeekends
  , projectDuplicateRequestScheduleDatesDueOn = Nothing
  , projectDuplicateRequestScheduleDatesStartOn = Nothing
  }

-- ** ProjectMembershipBase
-- | ProjectMembershipBase
data ProjectMembershipBase = ProjectMembershipBase
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectMembershipBase
instance A.FromJSON ProjectMembershipBase where
  parseJSON = A.withObject "ProjectMembershipBase" $ \o ->
    pure ProjectMembershipBase
      

-- | ToJSON ProjectMembershipBase
instance A.ToJSON ProjectMembershipBase where
  toJSON ProjectMembershipBase  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'ProjectMembershipBase' (by applying it's required fields, if any)
mkProjectMembershipBase
  :: ProjectMembershipBase
mkProjectMembershipBase =
  ProjectMembershipBase
  { 
  }

-- ** ProjectMembershipCompact
-- | ProjectMembershipCompact
data ProjectMembershipCompact = ProjectMembershipCompact
  { projectMembershipCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , projectMembershipCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , projectMembershipCompactUser :: !(Maybe UserCompact) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectMembershipCompact
instance A.FromJSON ProjectMembershipCompact where
  parseJSON = A.withObject "ProjectMembershipCompact" $ \o ->
    ProjectMembershipCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "user")

-- | ToJSON ProjectMembershipCompact
instance A.ToJSON ProjectMembershipCompact where
  toJSON ProjectMembershipCompact {..} =
   _omitNulls
      [ "gid" .= projectMembershipCompactGid
      , "resource_type" .= projectMembershipCompactResourceType
      , "user" .= projectMembershipCompactUser
      ]


-- | Construct a value of type 'ProjectMembershipCompact' (by applying it's required fields, if any)
mkProjectMembershipCompact
  :: ProjectMembershipCompact
mkProjectMembershipCompact =
  ProjectMembershipCompact
  { projectMembershipCompactGid = Nothing
  , projectMembershipCompactResourceType = Nothing
  , projectMembershipCompactUser = Nothing
  }

-- ** ProjectMembershipCompactAllOf
-- | ProjectMembershipCompactAllOf
-- With the introduction of “comment-only” projects in Asana, a user’s membership in a project comes with associated permissions. These permissions (whether a user has full access to the project or comment-only access) are accessible through the project memberships endpoints described here.
data ProjectMembershipCompactAllOf = ProjectMembershipCompactAllOf
  { projectMembershipCompactAllOfUser :: !(Maybe UserCompact) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectMembershipCompactAllOf
instance A.FromJSON ProjectMembershipCompactAllOf where
  parseJSON = A.withObject "ProjectMembershipCompactAllOf" $ \o ->
    ProjectMembershipCompactAllOf
      <$> (o .:? "user")

-- | ToJSON ProjectMembershipCompactAllOf
instance A.ToJSON ProjectMembershipCompactAllOf where
  toJSON ProjectMembershipCompactAllOf {..} =
   _omitNulls
      [ "user" .= projectMembershipCompactAllOfUser
      ]


-- | Construct a value of type 'ProjectMembershipCompactAllOf' (by applying it's required fields, if any)
mkProjectMembershipCompactAllOf
  :: ProjectMembershipCompactAllOf
mkProjectMembershipCompactAllOf =
  ProjectMembershipCompactAllOf
  { projectMembershipCompactAllOfUser = Nothing
  }

-- ** ProjectMembershipResponse
-- | ProjectMembershipResponse
data ProjectMembershipResponse = ProjectMembershipResponse
  { projectMembershipResponseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , projectMembershipResponseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , projectMembershipResponseUser :: !(Maybe UserCompact) -- ^ "user"
  , projectMembershipResponseProject :: !(Maybe ProjectCompact) -- ^ "project"
  , projectMembershipResponseWriteAccess :: !(Maybe E'WriteAccess) -- ^ "write_access" - Whether the user has full access to the project or has comment-only access.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectMembershipResponse
instance A.FromJSON ProjectMembershipResponse where
  parseJSON = A.withObject "ProjectMembershipResponse" $ \o ->
    ProjectMembershipResponse
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "user")
      <*> (o .:? "project")
      <*> (o .:? "write_access")

-- | ToJSON ProjectMembershipResponse
instance A.ToJSON ProjectMembershipResponse where
  toJSON ProjectMembershipResponse {..} =
   _omitNulls
      [ "gid" .= projectMembershipResponseGid
      , "resource_type" .= projectMembershipResponseResourceType
      , "user" .= projectMembershipResponseUser
      , "project" .= projectMembershipResponseProject
      , "write_access" .= projectMembershipResponseWriteAccess
      ]


-- | Construct a value of type 'ProjectMembershipResponse' (by applying it's required fields, if any)
mkProjectMembershipResponse
  :: ProjectMembershipResponse
mkProjectMembershipResponse =
  ProjectMembershipResponse
  { projectMembershipResponseGid = Nothing
  , projectMembershipResponseResourceType = Nothing
  , projectMembershipResponseUser = Nothing
  , projectMembershipResponseProject = Nothing
  , projectMembershipResponseWriteAccess = Nothing
  }

-- ** ProjectMembershipResponseAllOf
-- | ProjectMembershipResponseAllOf
data ProjectMembershipResponseAllOf = ProjectMembershipResponseAllOf
  { projectMembershipResponseAllOfProject :: !(Maybe ProjectCompact) -- ^ "project"
  , projectMembershipResponseAllOfWriteAccess :: !(Maybe E'WriteAccess) -- ^ "write_access" - Whether the user has full access to the project or has comment-only access.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectMembershipResponseAllOf
instance A.FromJSON ProjectMembershipResponseAllOf where
  parseJSON = A.withObject "ProjectMembershipResponseAllOf" $ \o ->
    ProjectMembershipResponseAllOf
      <$> (o .:? "project")
      <*> (o .:? "write_access")

-- | ToJSON ProjectMembershipResponseAllOf
instance A.ToJSON ProjectMembershipResponseAllOf where
  toJSON ProjectMembershipResponseAllOf {..} =
   _omitNulls
      [ "project" .= projectMembershipResponseAllOfProject
      , "write_access" .= projectMembershipResponseAllOfWriteAccess
      ]


-- | Construct a value of type 'ProjectMembershipResponseAllOf' (by applying it's required fields, if any)
mkProjectMembershipResponseAllOf
  :: ProjectMembershipResponseAllOf
mkProjectMembershipResponseAllOf =
  ProjectMembershipResponseAllOf
  { projectMembershipResponseAllOfProject = Nothing
  , projectMembershipResponseAllOfWriteAccess = Nothing
  }

-- ** ProjectRequest
-- | ProjectRequest
data ProjectRequest = ProjectRequest
  { projectRequestGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , projectRequestResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , projectRequestName :: !(Maybe Text) -- ^ "name" - Name of the project. This is generally a short sentence fragment that fits on a line in the UI for maximum readability. However, it can be longer.
  , projectRequestArchived :: !(Maybe Bool) -- ^ "archived" - True if the project is archived, false if not. Archived projects do not show in the UI by default and may be treated differently for queries.
  , projectRequestColor :: !(Maybe E'Color) -- ^ "color" - Color of the project.
  , projectRequestCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , projectRequestCurrentStatus :: !(Maybe ProjectStatusResponse) -- ^ "current_status"
  , projectRequestCustomFieldSettings :: !(Maybe [CustomFieldSettingCompact]) -- ^ "custom_field_settings" - Array of Custom Field Settings (in compact form).
  , projectRequestDefaultView :: !(Maybe E'DefaultView) -- ^ "default_view" - The default view (list, board, calendar, or timeline) of a project.
  , projectRequestDueDate :: !(Maybe DateTime) -- ^ "due_date" - *Deprecated: new integrations should prefer the due_on field.*
  , projectRequestDueOn :: !(Maybe DateTime) -- ^ "due_on" - The day on which this project is due. This takes a date with format YYYY-MM-DD.
  , projectRequestHtmlNotes :: !(Maybe Text) -- ^ "html_notes" - [Opt In](#input-output-options). The notes of the project with formatting as HTML.
  , projectRequestIsTemplate :: !(Maybe Bool) -- ^ "is_template" - [Opt In](#input-output-options). Determines if the project is a template.
  , projectRequestMembers :: !(Maybe [UserCompact]) -- ^ "members" - Array of users who are members of this project.
  , projectRequestModifiedAt :: !(Maybe DateTime) -- ^ "modified_at" - The time at which this project was last modified. *Note: This does not currently reflect any changes in associations such as tasks or comments that may have been added or removed from the project.*
  , projectRequestNotes :: !(Maybe Text) -- ^ "notes" - More detailed, free-form textual information associated with the project.
  , projectRequestPublic :: !(Maybe Bool) -- ^ "public" - True if the project is public to the organization. If false, do not share this project with other users in this organization without explicitly checking to see if they have access.
  , projectRequestStartOn :: !(Maybe Date) -- ^ "start_on" - The day on which work for this project begins, or null if the project has no start date. This takes a date with &#x60;YYYY-MM-DD&#x60; format. *Note: &#x60;due_on&#x60; or &#x60;due_at&#x60; must be present in the request when setting or unsetting the &#x60;start_on&#x60; parameter.*
  , projectRequestWorkspace :: !(Maybe WorkspaceCompact) -- ^ "workspace"
  , projectRequestCustomFields :: !(Maybe (Map.Map String Text)) -- ^ "custom_fields" - An object where each key is a Custom Field gid and each value is an enum gid, string, or number.
  , projectRequestFollowers :: !(Maybe Text) -- ^ "followers" - *Create-only*. Comma separated string of users. Followers are a subset of members who receive all notifications for a project, the default notification setting when adding members to a project in-product.
  , projectRequestOwner :: !(Maybe Text) -- ^ "owner" - The current owner of the project, may be null.
  , projectRequestTeam :: !(Maybe Text) -- ^ "team" - *Create-only*. The team that this project is shared with. This field only exists for projects in organizations.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectRequest
instance A.FromJSON ProjectRequest where
  parseJSON = A.withObject "ProjectRequest" $ \o ->
    ProjectRequest
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "archived")
      <*> (o .:? "color")
      <*> (o .:? "created_at")
      <*> (o .:? "current_status")
      <*> (o .:? "custom_field_settings")
      <*> (o .:? "default_view")
      <*> (o .:? "due_date")
      <*> (o .:? "due_on")
      <*> (o .:? "html_notes")
      <*> (o .:? "is_template")
      <*> (o .:? "members")
      <*> (o .:? "modified_at")
      <*> (o .:? "notes")
      <*> (o .:? "public")
      <*> (o .:? "start_on")
      <*> (o .:? "workspace")
      <*> (o .:? "custom_fields")
      <*> (o .:? "followers")
      <*> (o .:? "owner")
      <*> (o .:? "team")

-- | ToJSON ProjectRequest
instance A.ToJSON ProjectRequest where
  toJSON ProjectRequest {..} =
   _omitNulls
      [ "gid" .= projectRequestGid
      , "resource_type" .= projectRequestResourceType
      , "name" .= projectRequestName
      , "archived" .= projectRequestArchived
      , "color" .= projectRequestColor
      , "created_at" .= projectRequestCreatedAt
      , "current_status" .= projectRequestCurrentStatus
      , "custom_field_settings" .= projectRequestCustomFieldSettings
      , "default_view" .= projectRequestDefaultView
      , "due_date" .= projectRequestDueDate
      , "due_on" .= projectRequestDueOn
      , "html_notes" .= projectRequestHtmlNotes
      , "is_template" .= projectRequestIsTemplate
      , "members" .= projectRequestMembers
      , "modified_at" .= projectRequestModifiedAt
      , "notes" .= projectRequestNotes
      , "public" .= projectRequestPublic
      , "start_on" .= projectRequestStartOn
      , "workspace" .= projectRequestWorkspace
      , "custom_fields" .= projectRequestCustomFields
      , "followers" .= projectRequestFollowers
      , "owner" .= projectRequestOwner
      , "team" .= projectRequestTeam
      ]


-- | Construct a value of type 'ProjectRequest' (by applying it's required fields, if any)
mkProjectRequest
  :: ProjectRequest
mkProjectRequest =
  ProjectRequest
  { projectRequestGid = Nothing
  , projectRequestResourceType = Nothing
  , projectRequestName = Nothing
  , projectRequestArchived = Nothing
  , projectRequestColor = Nothing
  , projectRequestCreatedAt = Nothing
  , projectRequestCurrentStatus = Nothing
  , projectRequestCustomFieldSettings = Nothing
  , projectRequestDefaultView = Nothing
  , projectRequestDueDate = Nothing
  , projectRequestDueOn = Nothing
  , projectRequestHtmlNotes = Nothing
  , projectRequestIsTemplate = Nothing
  , projectRequestMembers = Nothing
  , projectRequestModifiedAt = Nothing
  , projectRequestNotes = Nothing
  , projectRequestPublic = Nothing
  , projectRequestStartOn = Nothing
  , projectRequestWorkspace = Nothing
  , projectRequestCustomFields = Nothing
  , projectRequestFollowers = Nothing
  , projectRequestOwner = Nothing
  , projectRequestTeam = Nothing
  }

-- ** ProjectRequestAllOf
-- | ProjectRequestAllOf
data ProjectRequestAllOf = ProjectRequestAllOf
  { projectRequestAllOfCustomFields :: !(Maybe (Map.Map String Text)) -- ^ "custom_fields" - An object where each key is a Custom Field gid and each value is an enum gid, string, or number.
  , projectRequestAllOfFollowers :: !(Maybe Text) -- ^ "followers" - *Create-only*. Comma separated string of users. Followers are a subset of members who receive all notifications for a project, the default notification setting when adding members to a project in-product.
  , projectRequestAllOfOwner :: !(Maybe Text) -- ^ "owner" - The current owner of the project, may be null.
  , projectRequestAllOfTeam :: !(Maybe Text) -- ^ "team" - *Create-only*. The team that this project is shared with. This field only exists for projects in organizations.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectRequestAllOf
instance A.FromJSON ProjectRequestAllOf where
  parseJSON = A.withObject "ProjectRequestAllOf" $ \o ->
    ProjectRequestAllOf
      <$> (o .:? "custom_fields")
      <*> (o .:? "followers")
      <*> (o .:? "owner")
      <*> (o .:? "team")

-- | ToJSON ProjectRequestAllOf
instance A.ToJSON ProjectRequestAllOf where
  toJSON ProjectRequestAllOf {..} =
   _omitNulls
      [ "custom_fields" .= projectRequestAllOfCustomFields
      , "followers" .= projectRequestAllOfFollowers
      , "owner" .= projectRequestAllOfOwner
      , "team" .= projectRequestAllOfTeam
      ]


-- | Construct a value of type 'ProjectRequestAllOf' (by applying it's required fields, if any)
mkProjectRequestAllOf
  :: ProjectRequestAllOf
mkProjectRequestAllOf =
  ProjectRequestAllOf
  { projectRequestAllOfCustomFields = Nothing
  , projectRequestAllOfFollowers = Nothing
  , projectRequestAllOfOwner = Nothing
  , projectRequestAllOfTeam = Nothing
  }

-- ** ProjectResponse
-- | ProjectResponse
data ProjectResponse = ProjectResponse
  { projectResponseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , projectResponseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , projectResponseName :: !(Maybe Text) -- ^ "name" - Name of the project. This is generally a short sentence fragment that fits on a line in the UI for maximum readability. However, it can be longer.
  , projectResponseArchived :: !(Maybe Bool) -- ^ "archived" - True if the project is archived, false if not. Archived projects do not show in the UI by default and may be treated differently for queries.
  , projectResponseColor :: !(Maybe E'Color) -- ^ "color" - Color of the project.
  , projectResponseCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , projectResponseCurrentStatus :: !(Maybe ProjectStatusResponse) -- ^ "current_status"
  , projectResponseCustomFieldSettings :: !(Maybe [CustomFieldSettingCompact]) -- ^ "custom_field_settings" - Array of Custom Field Settings (in compact form).
  , projectResponseDefaultView :: !(Maybe E'DefaultView) -- ^ "default_view" - The default view (list, board, calendar, or timeline) of a project.
  , projectResponseDueDate :: !(Maybe DateTime) -- ^ "due_date" - *Deprecated: new integrations should prefer the due_on field.*
  , projectResponseDueOn :: !(Maybe DateTime) -- ^ "due_on" - The day on which this project is due. This takes a date with format YYYY-MM-DD.
  , projectResponseHtmlNotes :: !(Maybe Text) -- ^ "html_notes" - [Opt In](#input-output-options). The notes of the project with formatting as HTML.
  , projectResponseIsTemplate :: !(Maybe Bool) -- ^ "is_template" - [Opt In](#input-output-options). Determines if the project is a template.
  , projectResponseMembers :: !(Maybe [UserCompact]) -- ^ "members" - Array of users who are members of this project.
  , projectResponseModifiedAt :: !(Maybe DateTime) -- ^ "modified_at" - The time at which this project was last modified. *Note: This does not currently reflect any changes in associations such as tasks or comments that may have been added or removed from the project.*
  , projectResponseNotes :: !(Maybe Text) -- ^ "notes" - More detailed, free-form textual information associated with the project.
  , projectResponsePublic :: !(Maybe Bool) -- ^ "public" - True if the project is public to the organization. If false, do not share this project with other users in this organization without explicitly checking to see if they have access.
  , projectResponseStartOn :: !(Maybe Date) -- ^ "start_on" - The day on which work for this project begins, or null if the project has no start date. This takes a date with &#x60;YYYY-MM-DD&#x60; format. *Note: &#x60;due_on&#x60; or &#x60;due_at&#x60; must be present in the request when setting or unsetting the &#x60;start_on&#x60; parameter.*
  , projectResponseWorkspace :: !(Maybe WorkspaceCompact) -- ^ "workspace"
  , projectResponseCustomFields :: !(Maybe [CustomFieldCompact]) -- ^ "custom_fields" - Array of Custom Fields.
  , projectResponseFollowers :: !(Maybe [UserCompact]) -- ^ "followers" - Array of users following this project. Followers are a subset of members who receive all notifications for a project, the default notification setting when adding members to a project in-product.
  , projectResponseOwner :: !(Maybe UserCompact) -- ^ "owner" - The current owner of the project, may be null.
  , projectResponseTeam :: !(Maybe TeamCompact) -- ^ "team"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectResponse
instance A.FromJSON ProjectResponse where
  parseJSON = A.withObject "ProjectResponse" $ \o ->
    ProjectResponse
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "archived")
      <*> (o .:? "color")
      <*> (o .:? "created_at")
      <*> (o .:? "current_status")
      <*> (o .:? "custom_field_settings")
      <*> (o .:? "default_view")
      <*> (o .:? "due_date")
      <*> (o .:? "due_on")
      <*> (o .:? "html_notes")
      <*> (o .:? "is_template")
      <*> (o .:? "members")
      <*> (o .:? "modified_at")
      <*> (o .:? "notes")
      <*> (o .:? "public")
      <*> (o .:? "start_on")
      <*> (o .:? "workspace")
      <*> (o .:? "custom_fields")
      <*> (o .:? "followers")
      <*> (o .:? "owner")
      <*> (o .:? "team")

-- | ToJSON ProjectResponse
instance A.ToJSON ProjectResponse where
  toJSON ProjectResponse {..} =
   _omitNulls
      [ "gid" .= projectResponseGid
      , "resource_type" .= projectResponseResourceType
      , "name" .= projectResponseName
      , "archived" .= projectResponseArchived
      , "color" .= projectResponseColor
      , "created_at" .= projectResponseCreatedAt
      , "current_status" .= projectResponseCurrentStatus
      , "custom_field_settings" .= projectResponseCustomFieldSettings
      , "default_view" .= projectResponseDefaultView
      , "due_date" .= projectResponseDueDate
      , "due_on" .= projectResponseDueOn
      , "html_notes" .= projectResponseHtmlNotes
      , "is_template" .= projectResponseIsTemplate
      , "members" .= projectResponseMembers
      , "modified_at" .= projectResponseModifiedAt
      , "notes" .= projectResponseNotes
      , "public" .= projectResponsePublic
      , "start_on" .= projectResponseStartOn
      , "workspace" .= projectResponseWorkspace
      , "custom_fields" .= projectResponseCustomFields
      , "followers" .= projectResponseFollowers
      , "owner" .= projectResponseOwner
      , "team" .= projectResponseTeam
      ]


-- | Construct a value of type 'ProjectResponse' (by applying it's required fields, if any)
mkProjectResponse
  :: ProjectResponse
mkProjectResponse =
  ProjectResponse
  { projectResponseGid = Nothing
  , projectResponseResourceType = Nothing
  , projectResponseName = Nothing
  , projectResponseArchived = Nothing
  , projectResponseColor = Nothing
  , projectResponseCreatedAt = Nothing
  , projectResponseCurrentStatus = Nothing
  , projectResponseCustomFieldSettings = Nothing
  , projectResponseDefaultView = Nothing
  , projectResponseDueDate = Nothing
  , projectResponseDueOn = Nothing
  , projectResponseHtmlNotes = Nothing
  , projectResponseIsTemplate = Nothing
  , projectResponseMembers = Nothing
  , projectResponseModifiedAt = Nothing
  , projectResponseNotes = Nothing
  , projectResponsePublic = Nothing
  , projectResponseStartOn = Nothing
  , projectResponseWorkspace = Nothing
  , projectResponseCustomFields = Nothing
  , projectResponseFollowers = Nothing
  , projectResponseOwner = Nothing
  , projectResponseTeam = Nothing
  }

-- ** ProjectResponseAllOf
-- | ProjectResponseAllOf
data ProjectResponseAllOf = ProjectResponseAllOf
  { projectResponseAllOfCustomFields :: !(Maybe [CustomFieldCompact]) -- ^ "custom_fields" - Array of Custom Fields.
  , projectResponseAllOfFollowers :: !(Maybe [UserCompact]) -- ^ "followers" - Array of users following this project. Followers are a subset of members who receive all notifications for a project, the default notification setting when adding members to a project in-product.
  , projectResponseAllOfOwner :: !(Maybe UserCompact) -- ^ "owner" - The current owner of the project, may be null.
  , projectResponseAllOfTeam :: !(Maybe TeamCompact) -- ^ "team"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectResponseAllOf
instance A.FromJSON ProjectResponseAllOf where
  parseJSON = A.withObject "ProjectResponseAllOf" $ \o ->
    ProjectResponseAllOf
      <$> (o .:? "custom_fields")
      <*> (o .:? "followers")
      <*> (o .:? "owner")
      <*> (o .:? "team")

-- | ToJSON ProjectResponseAllOf
instance A.ToJSON ProjectResponseAllOf where
  toJSON ProjectResponseAllOf {..} =
   _omitNulls
      [ "custom_fields" .= projectResponseAllOfCustomFields
      , "followers" .= projectResponseAllOfFollowers
      , "owner" .= projectResponseAllOfOwner
      , "team" .= projectResponseAllOfTeam
      ]


-- | Construct a value of type 'ProjectResponseAllOf' (by applying it's required fields, if any)
mkProjectResponseAllOf
  :: ProjectResponseAllOf
mkProjectResponseAllOf =
  ProjectResponseAllOf
  { projectResponseAllOfCustomFields = Nothing
  , projectResponseAllOfFollowers = Nothing
  , projectResponseAllOfOwner = Nothing
  , projectResponseAllOfTeam = Nothing
  }

-- ** ProjectSectionInsertRequest
-- | ProjectSectionInsertRequest
data ProjectSectionInsertRequest = ProjectSectionInsertRequest
  { projectSectionInsertRequestProject :: !(Text) -- ^ /Required/ "project" - The project in which to reorder the given section.
  , projectSectionInsertRequestSection :: !(Text) -- ^ /Required/ "section" - The section to reorder.
  , projectSectionInsertRequestBeforeSection :: !(Maybe Text) -- ^ "before_section" - Insert the given section immediately before the section specified by this parameter.
  , projectSectionInsertRequestAfterSection :: !(Maybe Text) -- ^ "after_section" - Insert the given section immediately after the section specified by this parameter.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectSectionInsertRequest
instance A.FromJSON ProjectSectionInsertRequest where
  parseJSON = A.withObject "ProjectSectionInsertRequest" $ \o ->
    ProjectSectionInsertRequest
      <$> (o .:  "project")
      <*> (o .:  "section")
      <*> (o .:? "before_section")
      <*> (o .:? "after_section")

-- | ToJSON ProjectSectionInsertRequest
instance A.ToJSON ProjectSectionInsertRequest where
  toJSON ProjectSectionInsertRequest {..} =
   _omitNulls
      [ "project" .= projectSectionInsertRequestProject
      , "section" .= projectSectionInsertRequestSection
      , "before_section" .= projectSectionInsertRequestBeforeSection
      , "after_section" .= projectSectionInsertRequestAfterSection
      ]


-- | Construct a value of type 'ProjectSectionInsertRequest' (by applying it's required fields, if any)
mkProjectSectionInsertRequest
  :: Text -- ^ 'projectSectionInsertRequestProject': The project in which to reorder the given section.
  -> Text -- ^ 'projectSectionInsertRequestSection': The section to reorder.
  -> ProjectSectionInsertRequest
mkProjectSectionInsertRequest projectSectionInsertRequestProject projectSectionInsertRequestSection =
  ProjectSectionInsertRequest
  { projectSectionInsertRequestProject
  , projectSectionInsertRequestSection
  , projectSectionInsertRequestBeforeSection = Nothing
  , projectSectionInsertRequestAfterSection = Nothing
  }

-- ** ProjectStatusBase
-- | ProjectStatusBase
data ProjectStatusBase = ProjectStatusBase
  { projectStatusBaseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , projectStatusBaseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , projectStatusBaseTitle :: !(Maybe Text) -- ^ "title" - The title of the project status update.
  , projectStatusBaseProject :: !(Text) -- ^ /Required/ "project" - Globally unique identifier for the project.
  , projectStatusBaseText :: !(Text) -- ^ /Required/ "text" - The text content of the status update.
  , projectStatusBaseHtmlText :: !(Maybe Text) -- ^ "html_text" - [Opt In](#input-output-options). The text content of the status update with formatting as HTML.
  , projectStatusBaseColor :: !(E'Color2) -- ^ /Required/ "color" - The color associated with the status update.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectStatusBase
instance A.FromJSON ProjectStatusBase where
  parseJSON = A.withObject "ProjectStatusBase" $ \o ->
    ProjectStatusBase
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "title")
      <*> (o .:  "project")
      <*> (o .:  "text")
      <*> (o .:? "html_text")
      <*> (o .:  "color")

-- | ToJSON ProjectStatusBase
instance A.ToJSON ProjectStatusBase where
  toJSON ProjectStatusBase {..} =
   _omitNulls
      [ "gid" .= projectStatusBaseGid
      , "resource_type" .= projectStatusBaseResourceType
      , "title" .= projectStatusBaseTitle
      , "project" .= projectStatusBaseProject
      , "text" .= projectStatusBaseText
      , "html_text" .= projectStatusBaseHtmlText
      , "color" .= projectStatusBaseColor
      ]


-- | Construct a value of type 'ProjectStatusBase' (by applying it's required fields, if any)
mkProjectStatusBase
  :: Text -- ^ 'projectStatusBaseProject': Globally unique identifier for the project.
  -> Text -- ^ 'projectStatusBaseText': The text content of the status update.
  -> E'Color2 -- ^ 'projectStatusBaseColor': The color associated with the status update.
  -> ProjectStatusBase
mkProjectStatusBase projectStatusBaseProject projectStatusBaseText projectStatusBaseColor =
  ProjectStatusBase
  { projectStatusBaseGid = Nothing
  , projectStatusBaseResourceType = Nothing
  , projectStatusBaseTitle = Nothing
  , projectStatusBaseProject
  , projectStatusBaseText
  , projectStatusBaseHtmlText = Nothing
  , projectStatusBaseColor
  }

-- ** ProjectStatusBaseAllOf
-- | ProjectStatusBaseAllOf
data ProjectStatusBaseAllOf = ProjectStatusBaseAllOf
  { projectStatusBaseAllOfProject :: !(Text) -- ^ /Required/ "project" - Globally unique identifier for the project.
  , projectStatusBaseAllOfText :: !(Text) -- ^ /Required/ "text" - The text content of the status update.
  , projectStatusBaseAllOfHtmlText :: !(Maybe Text) -- ^ "html_text" - [Opt In](#input-output-options). The text content of the status update with formatting as HTML.
  , projectStatusBaseAllOfColor :: !(E'Color2) -- ^ /Required/ "color" - The color associated with the status update.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectStatusBaseAllOf
instance A.FromJSON ProjectStatusBaseAllOf where
  parseJSON = A.withObject "ProjectStatusBaseAllOf" $ \o ->
    ProjectStatusBaseAllOf
      <$> (o .:  "project")
      <*> (o .:  "text")
      <*> (o .:? "html_text")
      <*> (o .:  "color")

-- | ToJSON ProjectStatusBaseAllOf
instance A.ToJSON ProjectStatusBaseAllOf where
  toJSON ProjectStatusBaseAllOf {..} =
   _omitNulls
      [ "project" .= projectStatusBaseAllOfProject
      , "text" .= projectStatusBaseAllOfText
      , "html_text" .= projectStatusBaseAllOfHtmlText
      , "color" .= projectStatusBaseAllOfColor
      ]


-- | Construct a value of type 'ProjectStatusBaseAllOf' (by applying it's required fields, if any)
mkProjectStatusBaseAllOf
  :: Text -- ^ 'projectStatusBaseAllOfProject': Globally unique identifier for the project.
  -> Text -- ^ 'projectStatusBaseAllOfText': The text content of the status update.
  -> E'Color2 -- ^ 'projectStatusBaseAllOfColor': The color associated with the status update.
  -> ProjectStatusBaseAllOf
mkProjectStatusBaseAllOf projectStatusBaseAllOfProject projectStatusBaseAllOfText projectStatusBaseAllOfColor =
  ProjectStatusBaseAllOf
  { projectStatusBaseAllOfProject
  , projectStatusBaseAllOfText
  , projectStatusBaseAllOfHtmlText = Nothing
  , projectStatusBaseAllOfColor
  }

-- ** ProjectStatusCompact
-- | ProjectStatusCompact
data ProjectStatusCompact = ProjectStatusCompact
  { projectStatusCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , projectStatusCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , projectStatusCompactTitle :: !(Maybe Text) -- ^ "title" - The title of the project status update.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectStatusCompact
instance A.FromJSON ProjectStatusCompact where
  parseJSON = A.withObject "ProjectStatusCompact" $ \o ->
    ProjectStatusCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "title")

-- | ToJSON ProjectStatusCompact
instance A.ToJSON ProjectStatusCompact where
  toJSON ProjectStatusCompact {..} =
   _omitNulls
      [ "gid" .= projectStatusCompactGid
      , "resource_type" .= projectStatusCompactResourceType
      , "title" .= projectStatusCompactTitle
      ]


-- | Construct a value of type 'ProjectStatusCompact' (by applying it's required fields, if any)
mkProjectStatusCompact
  :: ProjectStatusCompact
mkProjectStatusCompact =
  ProjectStatusCompact
  { projectStatusCompactGid = Nothing
  , projectStatusCompactResourceType = Nothing
  , projectStatusCompactTitle = Nothing
  }

-- ** ProjectStatusCompactAllOf
-- | ProjectStatusCompactAllOf
-- A *project status* is an update on the progress of a particular project, and is sent out to all project followers when created. These updates include both text describing the update and a color code intended to represent the overall state of the project: \"green\" for projects that are on track, \"yellow\" for projects at risk, and \"red\" for projects that are behind.
data ProjectStatusCompactAllOf = ProjectStatusCompactAllOf
  { projectStatusCompactAllOfTitle :: !(Maybe Text) -- ^ "title" - The title of the project status update.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectStatusCompactAllOf
instance A.FromJSON ProjectStatusCompactAllOf where
  parseJSON = A.withObject "ProjectStatusCompactAllOf" $ \o ->
    ProjectStatusCompactAllOf
      <$> (o .:? "title")

-- | ToJSON ProjectStatusCompactAllOf
instance A.ToJSON ProjectStatusCompactAllOf where
  toJSON ProjectStatusCompactAllOf {..} =
   _omitNulls
      [ "title" .= projectStatusCompactAllOfTitle
      ]


-- | Construct a value of type 'ProjectStatusCompactAllOf' (by applying it's required fields, if any)
mkProjectStatusCompactAllOf
  :: ProjectStatusCompactAllOf
mkProjectStatusCompactAllOf =
  ProjectStatusCompactAllOf
  { projectStatusCompactAllOfTitle = Nothing
  }

-- ** ProjectStatusRequest
-- | ProjectStatusRequest
data ProjectStatusRequest = ProjectStatusRequest
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectStatusRequest
instance A.FromJSON ProjectStatusRequest where
  parseJSON = A.withObject "ProjectStatusRequest" $ \o ->
    pure ProjectStatusRequest
      

-- | ToJSON ProjectStatusRequest
instance A.ToJSON ProjectStatusRequest where
  toJSON ProjectStatusRequest  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'ProjectStatusRequest' (by applying it's required fields, if any)
mkProjectStatusRequest
  :: ProjectStatusRequest
mkProjectStatusRequest =
  ProjectStatusRequest
  { 
  }

-- ** ProjectStatusResponse
-- | ProjectStatusResponse
data ProjectStatusResponse = ProjectStatusResponse
  { projectStatusResponseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , projectStatusResponseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , projectStatusResponseTitle :: !(Maybe Text) -- ^ "title" - The title of the project status update.
  , projectStatusResponseProject :: !(Text) -- ^ /Required/ "project" - Globally unique identifier for the project.
  , projectStatusResponseText :: !(Text) -- ^ /Required/ "text" - The text content of the status update.
  , projectStatusResponseHtmlText :: !(Maybe Text) -- ^ "html_text" - [Opt In](#input-output-options). The text content of the status update with formatting as HTML.
  , projectStatusResponseColor :: !(E'Color2) -- ^ /Required/ "color" - The color associated with the status update.
  , projectStatusResponseCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , projectStatusResponseCreatedBy :: !(Maybe UserCompact) -- ^ "created_by"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectStatusResponse
instance A.FromJSON ProjectStatusResponse where
  parseJSON = A.withObject "ProjectStatusResponse" $ \o ->
    ProjectStatusResponse
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "title")
      <*> (o .:  "project")
      <*> (o .:  "text")
      <*> (o .:? "html_text")
      <*> (o .:  "color")
      <*> (o .:? "created_at")
      <*> (o .:? "created_by")

-- | ToJSON ProjectStatusResponse
instance A.ToJSON ProjectStatusResponse where
  toJSON ProjectStatusResponse {..} =
   _omitNulls
      [ "gid" .= projectStatusResponseGid
      , "resource_type" .= projectStatusResponseResourceType
      , "title" .= projectStatusResponseTitle
      , "project" .= projectStatusResponseProject
      , "text" .= projectStatusResponseText
      , "html_text" .= projectStatusResponseHtmlText
      , "color" .= projectStatusResponseColor
      , "created_at" .= projectStatusResponseCreatedAt
      , "created_by" .= projectStatusResponseCreatedBy
      ]


-- | Construct a value of type 'ProjectStatusResponse' (by applying it's required fields, if any)
mkProjectStatusResponse
  :: Text -- ^ 'projectStatusResponseProject': Globally unique identifier for the project.
  -> Text -- ^ 'projectStatusResponseText': The text content of the status update.
  -> E'Color2 -- ^ 'projectStatusResponseColor': The color associated with the status update.
  -> ProjectStatusResponse
mkProjectStatusResponse projectStatusResponseProject projectStatusResponseText projectStatusResponseColor =
  ProjectStatusResponse
  { projectStatusResponseGid = Nothing
  , projectStatusResponseResourceType = Nothing
  , projectStatusResponseTitle = Nothing
  , projectStatusResponseProject
  , projectStatusResponseText
  , projectStatusResponseHtmlText = Nothing
  , projectStatusResponseColor
  , projectStatusResponseCreatedAt = Nothing
  , projectStatusResponseCreatedBy = Nothing
  }

-- ** ProjectStatusResponseAllOf
-- | ProjectStatusResponseAllOf
data ProjectStatusResponseAllOf = ProjectStatusResponseAllOf
  { projectStatusResponseAllOfCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , projectStatusResponseAllOfCreatedBy :: !(Maybe UserCompact) -- ^ "created_by"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectStatusResponseAllOf
instance A.FromJSON ProjectStatusResponseAllOf where
  parseJSON = A.withObject "ProjectStatusResponseAllOf" $ \o ->
    ProjectStatusResponseAllOf
      <$> (o .:? "created_at")
      <*> (o .:? "created_by")

-- | ToJSON ProjectStatusResponseAllOf
instance A.ToJSON ProjectStatusResponseAllOf where
  toJSON ProjectStatusResponseAllOf {..} =
   _omitNulls
      [ "created_at" .= projectStatusResponseAllOfCreatedAt
      , "created_by" .= projectStatusResponseAllOfCreatedBy
      ]


-- | Construct a value of type 'ProjectStatusResponseAllOf' (by applying it's required fields, if any)
mkProjectStatusResponseAllOf
  :: ProjectStatusResponseAllOf
mkProjectStatusResponseAllOf =
  ProjectStatusResponseAllOf
  { projectStatusResponseAllOfCreatedAt = Nothing
  , projectStatusResponseAllOfCreatedBy = Nothing
  }

-- ** RemoveCustomFieldSettingRequest
-- | RemoveCustomFieldSettingRequest
data RemoveCustomFieldSettingRequest = RemoveCustomFieldSettingRequest
  { removeCustomFieldSettingRequestCustomField :: !(Text) -- ^ /Required/ "custom_field" - The custom field to remove from this portfolio.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RemoveCustomFieldSettingRequest
instance A.FromJSON RemoveCustomFieldSettingRequest where
  parseJSON = A.withObject "RemoveCustomFieldSettingRequest" $ \o ->
    RemoveCustomFieldSettingRequest
      <$> (o .:  "custom_field")

-- | ToJSON RemoveCustomFieldSettingRequest
instance A.ToJSON RemoveCustomFieldSettingRequest where
  toJSON RemoveCustomFieldSettingRequest {..} =
   _omitNulls
      [ "custom_field" .= removeCustomFieldSettingRequestCustomField
      ]


-- | Construct a value of type 'RemoveCustomFieldSettingRequest' (by applying it's required fields, if any)
mkRemoveCustomFieldSettingRequest
  :: Text -- ^ 'removeCustomFieldSettingRequestCustomField': The custom field to remove from this portfolio.
  -> RemoveCustomFieldSettingRequest
mkRemoveCustomFieldSettingRequest removeCustomFieldSettingRequestCustomField =
  RemoveCustomFieldSettingRequest
  { removeCustomFieldSettingRequestCustomField
  }

-- ** RemoveFollowersRequest
-- | RemoveFollowersRequest
data RemoveFollowersRequest = RemoveFollowersRequest
  { removeFollowersRequestFollowers :: !(Text) -- ^ /Required/ "followers" - An array of strings identifying users. These can either be the string \&quot;me\&quot;, an email, or the gid of a user.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RemoveFollowersRequest
instance A.FromJSON RemoveFollowersRequest where
  parseJSON = A.withObject "RemoveFollowersRequest" $ \o ->
    RemoveFollowersRequest
      <$> (o .:  "followers")

-- | ToJSON RemoveFollowersRequest
instance A.ToJSON RemoveFollowersRequest where
  toJSON RemoveFollowersRequest {..} =
   _omitNulls
      [ "followers" .= removeFollowersRequestFollowers
      ]


-- | Construct a value of type 'RemoveFollowersRequest' (by applying it's required fields, if any)
mkRemoveFollowersRequest
  :: Text -- ^ 'removeFollowersRequestFollowers': An array of strings identifying users. These can either be the string \"me\", an email, or the gid of a user.
  -> RemoveFollowersRequest
mkRemoveFollowersRequest removeFollowersRequestFollowers =
  RemoveFollowersRequest
  { removeFollowersRequestFollowers
  }

-- ** RemoveMembersRequest
-- | RemoveMembersRequest
data RemoveMembersRequest = RemoveMembersRequest
  { removeMembersRequestMembers :: !(Text) -- ^ /Required/ "members" - An array of strings identifying users. These can either be the string \&quot;me\&quot;, an email, or the gid of a user.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RemoveMembersRequest
instance A.FromJSON RemoveMembersRequest where
  parseJSON = A.withObject "RemoveMembersRequest" $ \o ->
    RemoveMembersRequest
      <$> (o .:  "members")

-- | ToJSON RemoveMembersRequest
instance A.ToJSON RemoveMembersRequest where
  toJSON RemoveMembersRequest {..} =
   _omitNulls
      [ "members" .= removeMembersRequestMembers
      ]


-- | Construct a value of type 'RemoveMembersRequest' (by applying it's required fields, if any)
mkRemoveMembersRequest
  :: Text -- ^ 'removeMembersRequestMembers': An array of strings identifying users. These can either be the string \"me\", an email, or the gid of a user.
  -> RemoveMembersRequest
mkRemoveMembersRequest removeMembersRequestMembers =
  RemoveMembersRequest
  { removeMembersRequestMembers
  }

-- ** SectionBase
-- | SectionBase
data SectionBase = SectionBase
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SectionBase
instance A.FromJSON SectionBase where
  parseJSON = A.withObject "SectionBase" $ \o ->
    pure SectionBase
      

-- | ToJSON SectionBase
instance A.ToJSON SectionBase where
  toJSON SectionBase  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'SectionBase' (by applying it's required fields, if any)
mkSectionBase
  :: SectionBase
mkSectionBase =
  SectionBase
  { 
  }

-- ** SectionCompact
-- | SectionCompact
data SectionCompact = SectionCompact
  { sectionCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , sectionCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , sectionCompactName :: !(Maybe Text) -- ^ "name" - The name of the section (i.e. the text displayed as the section header).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SectionCompact
instance A.FromJSON SectionCompact where
  parseJSON = A.withObject "SectionCompact" $ \o ->
    SectionCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")

-- | ToJSON SectionCompact
instance A.ToJSON SectionCompact where
  toJSON SectionCompact {..} =
   _omitNulls
      [ "gid" .= sectionCompactGid
      , "resource_type" .= sectionCompactResourceType
      , "name" .= sectionCompactName
      ]


-- | Construct a value of type 'SectionCompact' (by applying it's required fields, if any)
mkSectionCompact
  :: SectionCompact
mkSectionCompact =
  SectionCompact
  { sectionCompactGid = Nothing
  , sectionCompactResourceType = Nothing
  , sectionCompactName = Nothing
  }

-- ** SectionCompactAllOf
-- | SectionCompactAllOf
-- A *section* is a subdivision of a project that groups tasks together. It can either be a header above a list of tasks in a list view or a column in a board view of a project.
data SectionCompactAllOf = SectionCompactAllOf
  { sectionCompactAllOfName :: !(Maybe Text) -- ^ "name" - The name of the section (i.e. the text displayed as the section header).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SectionCompactAllOf
instance A.FromJSON SectionCompactAllOf where
  parseJSON = A.withObject "SectionCompactAllOf" $ \o ->
    SectionCompactAllOf
      <$> (o .:? "name")

-- | ToJSON SectionCompactAllOf
instance A.ToJSON SectionCompactAllOf where
  toJSON SectionCompactAllOf {..} =
   _omitNulls
      [ "name" .= sectionCompactAllOfName
      ]


-- | Construct a value of type 'SectionCompactAllOf' (by applying it's required fields, if any)
mkSectionCompactAllOf
  :: SectionCompactAllOf
mkSectionCompactAllOf =
  SectionCompactAllOf
  { sectionCompactAllOfName = Nothing
  }

-- ** SectionRequest
-- | SectionRequest
data SectionRequest = SectionRequest
  { sectionRequestProject :: !(Text) -- ^ /Required/ "project" - *Create-Only* The project to create the section in
  , sectionRequestName :: !(Text) -- ^ /Required/ "name" - The text to be displayed as the section name. This cannot be an empty string.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SectionRequest
instance A.FromJSON SectionRequest where
  parseJSON = A.withObject "SectionRequest" $ \o ->
    SectionRequest
      <$> (o .:  "project")
      <*> (o .:  "name")

-- | ToJSON SectionRequest
instance A.ToJSON SectionRequest where
  toJSON SectionRequest {..} =
   _omitNulls
      [ "project" .= sectionRequestProject
      , "name" .= sectionRequestName
      ]


-- | Construct a value of type 'SectionRequest' (by applying it's required fields, if any)
mkSectionRequest
  :: Text -- ^ 'sectionRequestProject': *Create-Only* The project to create the section in
  -> Text -- ^ 'sectionRequestName': The text to be displayed as the section name. This cannot be an empty string.
  -> SectionRequest
mkSectionRequest sectionRequestProject sectionRequestName =
  SectionRequest
  { sectionRequestProject
  , sectionRequestName
  }

-- ** SectionResponse
-- | SectionResponse
data SectionResponse = SectionResponse
  { sectionResponseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , sectionResponseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , sectionResponseName :: !(Maybe Text) -- ^ "name" - The name of the section (i.e. the text displayed as the section header).
  , sectionResponseCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , sectionResponseProject :: !(Maybe ProjectCompact) -- ^ "project"
  , sectionResponseProjects :: !(Maybe [ProjectCompact]) -- ^ "projects" - *Deprecated - please use project instead*
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SectionResponse
instance A.FromJSON SectionResponse where
  parseJSON = A.withObject "SectionResponse" $ \o ->
    SectionResponse
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "created_at")
      <*> (o .:? "project")
      <*> (o .:? "projects")

-- | ToJSON SectionResponse
instance A.ToJSON SectionResponse where
  toJSON SectionResponse {..} =
   _omitNulls
      [ "gid" .= sectionResponseGid
      , "resource_type" .= sectionResponseResourceType
      , "name" .= sectionResponseName
      , "created_at" .= sectionResponseCreatedAt
      , "project" .= sectionResponseProject
      , "projects" .= sectionResponseProjects
      ]


-- | Construct a value of type 'SectionResponse' (by applying it's required fields, if any)
mkSectionResponse
  :: SectionResponse
mkSectionResponse =
  SectionResponse
  { sectionResponseGid = Nothing
  , sectionResponseResourceType = Nothing
  , sectionResponseName = Nothing
  , sectionResponseCreatedAt = Nothing
  , sectionResponseProject = Nothing
  , sectionResponseProjects = Nothing
  }

-- ** SectionResponseAllOf
-- | SectionResponseAllOf
data SectionResponseAllOf = SectionResponseAllOf
  { sectionResponseAllOfCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , sectionResponseAllOfProject :: !(Maybe ProjectCompact) -- ^ "project"
  , sectionResponseAllOfProjects :: !(Maybe [ProjectCompact]) -- ^ "projects" - *Deprecated - please use project instead*
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SectionResponseAllOf
instance A.FromJSON SectionResponseAllOf where
  parseJSON = A.withObject "SectionResponseAllOf" $ \o ->
    SectionResponseAllOf
      <$> (o .:? "created_at")
      <*> (o .:? "project")
      <*> (o .:? "projects")

-- | ToJSON SectionResponseAllOf
instance A.ToJSON SectionResponseAllOf where
  toJSON SectionResponseAllOf {..} =
   _omitNulls
      [ "created_at" .= sectionResponseAllOfCreatedAt
      , "project" .= sectionResponseAllOfProject
      , "projects" .= sectionResponseAllOfProjects
      ]


-- | Construct a value of type 'SectionResponseAllOf' (by applying it's required fields, if any)
mkSectionResponseAllOf
  :: SectionResponseAllOf
mkSectionResponseAllOf =
  SectionResponseAllOf
  { sectionResponseAllOfCreatedAt = Nothing
  , sectionResponseAllOfProject = Nothing
  , sectionResponseAllOfProjects = Nothing
  }

-- ** SectionTaskInsertRequest
-- | SectionTaskInsertRequest
data SectionTaskInsertRequest = SectionTaskInsertRequest
  { sectionTaskInsertRequestTask :: !(Text) -- ^ /Required/ "task" - The task to add to this section.
  , sectionTaskInsertRequestInsertBefore :: !(Maybe Text) -- ^ "insert_before" - An existing task within this section before which the added task should be inserted. Cannot be provided together with insert_after.
  , sectionTaskInsertRequestInsertAfter :: !(Maybe Text) -- ^ "insert_after" - An existing task within this section after which the added task should be inserted. Cannot be provided together with insert_before.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SectionTaskInsertRequest
instance A.FromJSON SectionTaskInsertRequest where
  parseJSON = A.withObject "SectionTaskInsertRequest" $ \o ->
    SectionTaskInsertRequest
      <$> (o .:  "task")
      <*> (o .:? "insert_before")
      <*> (o .:? "insert_after")

-- | ToJSON SectionTaskInsertRequest
instance A.ToJSON SectionTaskInsertRequest where
  toJSON SectionTaskInsertRequest {..} =
   _omitNulls
      [ "task" .= sectionTaskInsertRequestTask
      , "insert_before" .= sectionTaskInsertRequestInsertBefore
      , "insert_after" .= sectionTaskInsertRequestInsertAfter
      ]


-- | Construct a value of type 'SectionTaskInsertRequest' (by applying it's required fields, if any)
mkSectionTaskInsertRequest
  :: Text -- ^ 'sectionTaskInsertRequestTask': The task to add to this section.
  -> SectionTaskInsertRequest
mkSectionTaskInsertRequest sectionTaskInsertRequestTask =
  SectionTaskInsertRequest
  { sectionTaskInsertRequestTask
  , sectionTaskInsertRequestInsertBefore = Nothing
  , sectionTaskInsertRequestInsertAfter = Nothing
  }

-- ** StoryBase
-- | StoryBase
data StoryBase = StoryBase
  { storyBaseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , storyBaseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , storyBaseCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , storyBaseCreatedBy :: !(Maybe UserCompact) -- ^ "created_by"
  , storyBaseResourceSubtype :: !(Maybe Text) -- ^ "resource_subtype" - The subtype of this resource. Different subtypes retain many of the same fields and behavior, but may render differently in Asana or represent resources with different semantic meaning.
  , storyBaseText :: !(Maybe Text) -- ^ "text" - The plain text of the comment to add. Cannot be used with html_text.
  , storyBaseType :: !(Maybe Text) -- ^ "type" - *Deprecated: new integrations should prefer the &#x60;resource_subtype&#x60; field.* 
  , storyBaseHtmlText :: !(Maybe Text) -- ^ "html_text" - [Opt In](#input-output-options). HTML formatted text for a comment. This will not include the name of the creator.
  , storyBaseIsPinned :: !(Maybe Bool) -- ^ "is_pinned" - *Conditional*. Whether the story should be pinned on the resource.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StoryBase
instance A.FromJSON StoryBase where
  parseJSON = A.withObject "StoryBase" $ \o ->
    StoryBase
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "created_at")
      <*> (o .:? "created_by")
      <*> (o .:? "resource_subtype")
      <*> (o .:? "text")
      <*> (o .:? "type")
      <*> (o .:? "html_text")
      <*> (o .:? "is_pinned")

-- | ToJSON StoryBase
instance A.ToJSON StoryBase where
  toJSON StoryBase {..} =
   _omitNulls
      [ "gid" .= storyBaseGid
      , "resource_type" .= storyBaseResourceType
      , "created_at" .= storyBaseCreatedAt
      , "created_by" .= storyBaseCreatedBy
      , "resource_subtype" .= storyBaseResourceSubtype
      , "text" .= storyBaseText
      , "type" .= storyBaseType
      , "html_text" .= storyBaseHtmlText
      , "is_pinned" .= storyBaseIsPinned
      ]


-- | Construct a value of type 'StoryBase' (by applying it's required fields, if any)
mkStoryBase
  :: StoryBase
mkStoryBase =
  StoryBase
  { storyBaseGid = Nothing
  , storyBaseResourceType = Nothing
  , storyBaseCreatedAt = Nothing
  , storyBaseCreatedBy = Nothing
  , storyBaseResourceSubtype = Nothing
  , storyBaseText = Nothing
  , storyBaseType = Nothing
  , storyBaseHtmlText = Nothing
  , storyBaseIsPinned = Nothing
  }

-- ** StoryBaseAllOf
-- | StoryBaseAllOf
data StoryBaseAllOf = StoryBaseAllOf
  { storyBaseAllOfText :: !(Maybe Text) -- ^ "text" - The plain text of the comment to add. Cannot be used with html_text.
  , storyBaseAllOfHtmlText :: !(Maybe Text) -- ^ "html_text" - [Opt In](#input-output-options). HTML formatted text for a comment. This will not include the name of the creator.
  , storyBaseAllOfIsPinned :: !(Maybe Bool) -- ^ "is_pinned" - *Conditional*. Whether the story should be pinned on the resource.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StoryBaseAllOf
instance A.FromJSON StoryBaseAllOf where
  parseJSON = A.withObject "StoryBaseAllOf" $ \o ->
    StoryBaseAllOf
      <$> (o .:? "text")
      <*> (o .:? "html_text")
      <*> (o .:? "is_pinned")

-- | ToJSON StoryBaseAllOf
instance A.ToJSON StoryBaseAllOf where
  toJSON StoryBaseAllOf {..} =
   _omitNulls
      [ "text" .= storyBaseAllOfText
      , "html_text" .= storyBaseAllOfHtmlText
      , "is_pinned" .= storyBaseAllOfIsPinned
      ]


-- | Construct a value of type 'StoryBaseAllOf' (by applying it's required fields, if any)
mkStoryBaseAllOf
  :: StoryBaseAllOf
mkStoryBaseAllOf =
  StoryBaseAllOf
  { storyBaseAllOfText = Nothing
  , storyBaseAllOfHtmlText = Nothing
  , storyBaseAllOfIsPinned = Nothing
  }

-- ** StoryCompact
-- | StoryCompact
data StoryCompact = StoryCompact
  { storyCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , storyCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , storyCompactCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , storyCompactCreatedBy :: !(Maybe UserCompact) -- ^ "created_by"
  , storyCompactResourceSubtype :: !(Maybe Text) -- ^ "resource_subtype" - The subtype of this resource. Different subtypes retain many of the same fields and behavior, but may render differently in Asana or represent resources with different semantic meaning.
  , storyCompactText :: !(Maybe Text) -- ^ "text" - *Create-only*. Human-readable text for the story or comment. This will not include the name of the creator. *Note: This is not guaranteed to be stable for a given type of story. For example, text for a reassignment may not always say “assigned to …” as the text for a story can both be edited and change based on the language settings of the user making the request.* Use the &#x60;resource_subtype&#x60; property to discover the action that created the story.
  , storyCompactType :: !(Maybe Text) -- ^ "type" - *Deprecated: new integrations should prefer the &#x60;resource_subtype&#x60; field.* 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StoryCompact
instance A.FromJSON StoryCompact where
  parseJSON = A.withObject "StoryCompact" $ \o ->
    StoryCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "created_at")
      <*> (o .:? "created_by")
      <*> (o .:? "resource_subtype")
      <*> (o .:? "text")
      <*> (o .:? "type")

-- | ToJSON StoryCompact
instance A.ToJSON StoryCompact where
  toJSON StoryCompact {..} =
   _omitNulls
      [ "gid" .= storyCompactGid
      , "resource_type" .= storyCompactResourceType
      , "created_at" .= storyCompactCreatedAt
      , "created_by" .= storyCompactCreatedBy
      , "resource_subtype" .= storyCompactResourceSubtype
      , "text" .= storyCompactText
      , "type" .= storyCompactType
      ]


-- | Construct a value of type 'StoryCompact' (by applying it's required fields, if any)
mkStoryCompact
  :: StoryCompact
mkStoryCompact =
  StoryCompact
  { storyCompactGid = Nothing
  , storyCompactResourceType = Nothing
  , storyCompactCreatedAt = Nothing
  , storyCompactCreatedBy = Nothing
  , storyCompactResourceSubtype = Nothing
  , storyCompactText = Nothing
  , storyCompactType = Nothing
  }

-- ** StoryCompactAllOf
-- | StoryCompactAllOf
-- A story represents an activity associated with an object in the Asana system.
data StoryCompactAllOf = StoryCompactAllOf
  { storyCompactAllOfCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , storyCompactAllOfCreatedBy :: !(Maybe UserCompact) -- ^ "created_by"
  , storyCompactAllOfResourceSubtype :: !(Maybe Text) -- ^ "resource_subtype" - The subtype of this resource. Different subtypes retain many of the same fields and behavior, but may render differently in Asana or represent resources with different semantic meaning.
  , storyCompactAllOfText :: !(Maybe Text) -- ^ "text" - *Create-only*. Human-readable text for the story or comment. This will not include the name of the creator. *Note: This is not guaranteed to be stable for a given type of story. For example, text for a reassignment may not always say “assigned to …” as the text for a story can both be edited and change based on the language settings of the user making the request.* Use the &#x60;resource_subtype&#x60; property to discover the action that created the story.
  , storyCompactAllOfType :: !(Maybe Text) -- ^ "type" - *Deprecated: new integrations should prefer the &#x60;resource_subtype&#x60; field.* 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StoryCompactAllOf
instance A.FromJSON StoryCompactAllOf where
  parseJSON = A.withObject "StoryCompactAllOf" $ \o ->
    StoryCompactAllOf
      <$> (o .:? "created_at")
      <*> (o .:? "created_by")
      <*> (o .:? "resource_subtype")
      <*> (o .:? "text")
      <*> (o .:? "type")

-- | ToJSON StoryCompactAllOf
instance A.ToJSON StoryCompactAllOf where
  toJSON StoryCompactAllOf {..} =
   _omitNulls
      [ "created_at" .= storyCompactAllOfCreatedAt
      , "created_by" .= storyCompactAllOfCreatedBy
      , "resource_subtype" .= storyCompactAllOfResourceSubtype
      , "text" .= storyCompactAllOfText
      , "type" .= storyCompactAllOfType
      ]


-- | Construct a value of type 'StoryCompactAllOf' (by applying it's required fields, if any)
mkStoryCompactAllOf
  :: StoryCompactAllOf
mkStoryCompactAllOf =
  StoryCompactAllOf
  { storyCompactAllOfCreatedAt = Nothing
  , storyCompactAllOfCreatedBy = Nothing
  , storyCompactAllOfResourceSubtype = Nothing
  , storyCompactAllOfText = Nothing
  , storyCompactAllOfType = Nothing
  }

-- ** StoryRequest
-- | StoryRequest
data StoryRequest = StoryRequest
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StoryRequest
instance A.FromJSON StoryRequest where
  parseJSON = A.withObject "StoryRequest" $ \o ->
    pure StoryRequest
      

-- | ToJSON StoryRequest
instance A.ToJSON StoryRequest where
  toJSON StoryRequest  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'StoryRequest' (by applying it's required fields, if any)
mkStoryRequest
  :: StoryRequest
mkStoryRequest =
  StoryRequest
  { 
  }

-- ** StoryResponse
-- | StoryResponse
data StoryResponse = StoryResponse
  { storyResponseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , storyResponseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , storyResponseCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , storyResponseCreatedBy :: !(Maybe UserCompact) -- ^ "created_by"
  , storyResponseResourceSubtype :: !(Maybe Text) -- ^ "resource_subtype" - The subtype of this resource. Different subtypes retain many of the same fields and behavior, but may render differently in Asana or represent resources with different semantic meaning.
  , storyResponseText :: !(Maybe Text) -- ^ "text" - The plain text of the comment to add. Cannot be used with html_text.
  , storyResponseType :: !(Maybe Text) -- ^ "type" - *Deprecated: new integrations should prefer the &#x60;resource_subtype&#x60; field.* 
  , storyResponseHtmlText :: !(Maybe Text) -- ^ "html_text" - [Opt In](#input-output-options). HTML formatted text for a comment. This will not include the name of the creator.
  , storyResponseIsPinned :: !(Maybe Bool) -- ^ "is_pinned" - *Conditional*. Whether the story should be pinned on the resource.
  , storyResponseIsEdited :: !(Maybe Bool) -- ^ "is_edited" - *Conditional*. Whether the text of the story has been edited after creation.
  , storyResponseHearted :: !(Maybe Bool) -- ^ "hearted" - *Deprecated - please use likes instead* *Conditional*. True if the story is hearted by the authorized user, false if not.
  , storyResponseHearts :: !(Maybe [Like]) -- ^ "hearts" - *Deprecated - please use likes instead*  *Conditional*. Array of likes for users who have hearted this story.
  , storyResponseNumHearts :: !(Maybe Int) -- ^ "num_hearts" - *Deprecated - please use likes instead*  *Conditional*. The number of users who have hearted this story.
  , storyResponseLiked :: !(Maybe Bool) -- ^ "liked" - *Conditional*. True if the story is liked by the authorized user, false if not.
  , storyResponseLikes :: !(Maybe [Like]) -- ^ "likes" - *Conditional*. Array of likes for users who have liked this story.
  , storyResponseNumLikes :: !(Maybe Int) -- ^ "num_likes" - *Conditional*. The number of users who have liked this story.
  , storyResponsePreviews :: !(Maybe [Preview]) -- ^ "previews" - *Conditional*. A collection of previews to be displayed in the story.  *Note: This property only exists for comment stories.*
  , storyResponseOldName :: !(Maybe Text) -- ^ "old_name" - *Conditional*&#39;
  , storyResponseNewName :: !(Maybe Text) -- ^ "new_name" - *Conditional*
  , storyResponseOldDates :: !(Maybe StoryResponseDates) -- ^ "old_dates"
  , storyResponseNewDates :: !(Maybe StoryResponseDates) -- ^ "new_dates"
  , storyResponseOldResourceSubtype :: !(Maybe Text) -- ^ "old_resource_subtype" - *Conditional*
  , storyResponseNewResourceSubtype :: !(Maybe Text) -- ^ "new_resource_subtype" - *Conditional*
  , storyResponseStory :: !(Maybe StoryCompact) -- ^ "story"
  , storyResponseAssignee :: !(Maybe UserCompact) -- ^ "assignee"
  , storyResponseFollower :: !(Maybe UserCompact) -- ^ "follower"
  , storyResponseOldSection :: !(Maybe SectionCompact) -- ^ "old_section"
  , storyResponseNewSection :: !(Maybe SectionCompact) -- ^ "new_section"
  , storyResponseTask :: !(Maybe TaskCompact) -- ^ "task"
  , storyResponseProject :: !(Maybe ProjectCompact) -- ^ "project"
  , storyResponseTag :: !(Maybe TagCompact) -- ^ "tag"
  , storyResponseCustomField :: !(Maybe CustomFieldCompact) -- ^ "custom_field"
  , storyResponseOldTextValue :: !(Maybe Text) -- ^ "old_text_value" - *Conditional*
  , storyResponseNewTextValue :: !(Maybe Text) -- ^ "new_text_value" - *Conditional*
  , storyResponseOldNumberValue :: !(Maybe Int) -- ^ "old_number_value" - *Conditional*
  , storyResponseNewNumberValue :: !(Maybe Int) -- ^ "new_number_value" - *Conditional*
  , storyResponseOldEnumValue :: !(Maybe EnumOption) -- ^ "old_enum_value"
  , storyResponseNewEnumValue :: !(Maybe EnumOption) -- ^ "new_enum_value"
  , storyResponseNewApprovalStatus :: !(Maybe Text) -- ^ "new_approval_status" - *Conditional*
  , storyResponseOldApprovalStatus :: !(Maybe Text) -- ^ "old_approval_status" - *Conditional*
  , storyResponseDuplicateOf :: !(Maybe TaskCompact) -- ^ "duplicate_of"
  , storyResponseDuplicatedFrom :: !(Maybe TaskCompact) -- ^ "duplicated_from"
  , storyResponseDependency :: !(Maybe TaskCompact) -- ^ "dependency"
  , storyResponseSource :: !(Maybe E'Source) -- ^ "source" - The component of the Asana product the user used to trigger the story.
  , storyResponseTarget :: !(Maybe A.Value) -- ^ "target" - The object this story is associated with. Currently may only be a task.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StoryResponse
instance A.FromJSON StoryResponse where
  parseJSON = A.withObject "StoryResponse" $ \o ->
    StoryResponse
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "created_at")
      <*> (o .:? "created_by")
      <*> (o .:? "resource_subtype")
      <*> (o .:? "text")
      <*> (o .:? "type")
      <*> (o .:? "html_text")
      <*> (o .:? "is_pinned")
      <*> (o .:? "is_edited")
      <*> (o .:? "hearted")
      <*> (o .:? "hearts")
      <*> (o .:? "num_hearts")
      <*> (o .:? "liked")
      <*> (o .:? "likes")
      <*> (o .:? "num_likes")
      <*> (o .:? "previews")
      <*> (o .:? "old_name")
      <*> (o .:? "new_name")
      <*> (o .:? "old_dates")
      <*> (o .:? "new_dates")
      <*> (o .:? "old_resource_subtype")
      <*> (o .:? "new_resource_subtype")
      <*> (o .:? "story")
      <*> (o .:? "assignee")
      <*> (o .:? "follower")
      <*> (o .:? "old_section")
      <*> (o .:? "new_section")
      <*> (o .:? "task")
      <*> (o .:? "project")
      <*> (o .:? "tag")
      <*> (o .:? "custom_field")
      <*> (o .:? "old_text_value")
      <*> (o .:? "new_text_value")
      <*> (o .:? "old_number_value")
      <*> (o .:? "new_number_value")
      <*> (o .:? "old_enum_value")
      <*> (o .:? "new_enum_value")
      <*> (o .:? "new_approval_status")
      <*> (o .:? "old_approval_status")
      <*> (o .:? "duplicate_of")
      <*> (o .:? "duplicated_from")
      <*> (o .:? "dependency")
      <*> (o .:? "source")
      <*> (o .:? "target")

-- | ToJSON StoryResponse
instance A.ToJSON StoryResponse where
  toJSON StoryResponse {..} =
   _omitNulls
      [ "gid" .= storyResponseGid
      , "resource_type" .= storyResponseResourceType
      , "created_at" .= storyResponseCreatedAt
      , "created_by" .= storyResponseCreatedBy
      , "resource_subtype" .= storyResponseResourceSubtype
      , "text" .= storyResponseText
      , "type" .= storyResponseType
      , "html_text" .= storyResponseHtmlText
      , "is_pinned" .= storyResponseIsPinned
      , "is_edited" .= storyResponseIsEdited
      , "hearted" .= storyResponseHearted
      , "hearts" .= storyResponseHearts
      , "num_hearts" .= storyResponseNumHearts
      , "liked" .= storyResponseLiked
      , "likes" .= storyResponseLikes
      , "num_likes" .= storyResponseNumLikes
      , "previews" .= storyResponsePreviews
      , "old_name" .= storyResponseOldName
      , "new_name" .= storyResponseNewName
      , "old_dates" .= storyResponseOldDates
      , "new_dates" .= storyResponseNewDates
      , "old_resource_subtype" .= storyResponseOldResourceSubtype
      , "new_resource_subtype" .= storyResponseNewResourceSubtype
      , "story" .= storyResponseStory
      , "assignee" .= storyResponseAssignee
      , "follower" .= storyResponseFollower
      , "old_section" .= storyResponseOldSection
      , "new_section" .= storyResponseNewSection
      , "task" .= storyResponseTask
      , "project" .= storyResponseProject
      , "tag" .= storyResponseTag
      , "custom_field" .= storyResponseCustomField
      , "old_text_value" .= storyResponseOldTextValue
      , "new_text_value" .= storyResponseNewTextValue
      , "old_number_value" .= storyResponseOldNumberValue
      , "new_number_value" .= storyResponseNewNumberValue
      , "old_enum_value" .= storyResponseOldEnumValue
      , "new_enum_value" .= storyResponseNewEnumValue
      , "new_approval_status" .= storyResponseNewApprovalStatus
      , "old_approval_status" .= storyResponseOldApprovalStatus
      , "duplicate_of" .= storyResponseDuplicateOf
      , "duplicated_from" .= storyResponseDuplicatedFrom
      , "dependency" .= storyResponseDependency
      , "source" .= storyResponseSource
      , "target" .= storyResponseTarget
      ]


-- | Construct a value of type 'StoryResponse' (by applying it's required fields, if any)
mkStoryResponse
  :: StoryResponse
mkStoryResponse =
  StoryResponse
  { storyResponseGid = Nothing
  , storyResponseResourceType = Nothing
  , storyResponseCreatedAt = Nothing
  , storyResponseCreatedBy = Nothing
  , storyResponseResourceSubtype = Nothing
  , storyResponseText = Nothing
  , storyResponseType = Nothing
  , storyResponseHtmlText = Nothing
  , storyResponseIsPinned = Nothing
  , storyResponseIsEdited = Nothing
  , storyResponseHearted = Nothing
  , storyResponseHearts = Nothing
  , storyResponseNumHearts = Nothing
  , storyResponseLiked = Nothing
  , storyResponseLikes = Nothing
  , storyResponseNumLikes = Nothing
  , storyResponsePreviews = Nothing
  , storyResponseOldName = Nothing
  , storyResponseNewName = Nothing
  , storyResponseOldDates = Nothing
  , storyResponseNewDates = Nothing
  , storyResponseOldResourceSubtype = Nothing
  , storyResponseNewResourceSubtype = Nothing
  , storyResponseStory = Nothing
  , storyResponseAssignee = Nothing
  , storyResponseFollower = Nothing
  , storyResponseOldSection = Nothing
  , storyResponseNewSection = Nothing
  , storyResponseTask = Nothing
  , storyResponseProject = Nothing
  , storyResponseTag = Nothing
  , storyResponseCustomField = Nothing
  , storyResponseOldTextValue = Nothing
  , storyResponseNewTextValue = Nothing
  , storyResponseOldNumberValue = Nothing
  , storyResponseNewNumberValue = Nothing
  , storyResponseOldEnumValue = Nothing
  , storyResponseNewEnumValue = Nothing
  , storyResponseNewApprovalStatus = Nothing
  , storyResponseOldApprovalStatus = Nothing
  , storyResponseDuplicateOf = Nothing
  , storyResponseDuplicatedFrom = Nothing
  , storyResponseDependency = Nothing
  , storyResponseSource = Nothing
  , storyResponseTarget = Nothing
  }

-- ** StoryResponseAllOf
-- | StoryResponseAllOf
data StoryResponseAllOf = StoryResponseAllOf
  { storyResponseAllOfIsEdited :: !(Maybe Bool) -- ^ "is_edited" - *Conditional*. Whether the text of the story has been edited after creation.
  , storyResponseAllOfHearted :: !(Maybe Bool) -- ^ "hearted" - *Deprecated - please use likes instead* *Conditional*. True if the story is hearted by the authorized user, false if not.
  , storyResponseAllOfHearts :: !(Maybe [Like]) -- ^ "hearts" - *Deprecated - please use likes instead*  *Conditional*. Array of likes for users who have hearted this story.
  , storyResponseAllOfNumHearts :: !(Maybe Int) -- ^ "num_hearts" - *Deprecated - please use likes instead*  *Conditional*. The number of users who have hearted this story.
  , storyResponseAllOfLiked :: !(Maybe Bool) -- ^ "liked" - *Conditional*. True if the story is liked by the authorized user, false if not.
  , storyResponseAllOfLikes :: !(Maybe [Like]) -- ^ "likes" - *Conditional*. Array of likes for users who have liked this story.
  , storyResponseAllOfNumLikes :: !(Maybe Int) -- ^ "num_likes" - *Conditional*. The number of users who have liked this story.
  , storyResponseAllOfPreviews :: !(Maybe [Preview]) -- ^ "previews" - *Conditional*. A collection of previews to be displayed in the story.  *Note: This property only exists for comment stories.*
  , storyResponseAllOfOldName :: !(Maybe Text) -- ^ "old_name" - *Conditional*&#39;
  , storyResponseAllOfNewName :: !(Maybe Text) -- ^ "new_name" - *Conditional*
  , storyResponseAllOfOldDates :: !(Maybe StoryResponseDates) -- ^ "old_dates"
  , storyResponseAllOfNewDates :: !(Maybe StoryResponseDates) -- ^ "new_dates"
  , storyResponseAllOfOldResourceSubtype :: !(Maybe Text) -- ^ "old_resource_subtype" - *Conditional*
  , storyResponseAllOfNewResourceSubtype :: !(Maybe Text) -- ^ "new_resource_subtype" - *Conditional*
  , storyResponseAllOfStory :: !(Maybe StoryCompact) -- ^ "story"
  , storyResponseAllOfAssignee :: !(Maybe UserCompact) -- ^ "assignee"
  , storyResponseAllOfFollower :: !(Maybe UserCompact) -- ^ "follower"
  , storyResponseAllOfOldSection :: !(Maybe SectionCompact) -- ^ "old_section"
  , storyResponseAllOfNewSection :: !(Maybe SectionCompact) -- ^ "new_section"
  , storyResponseAllOfTask :: !(Maybe TaskCompact) -- ^ "task"
  , storyResponseAllOfProject :: !(Maybe ProjectCompact) -- ^ "project"
  , storyResponseAllOfTag :: !(Maybe TagCompact) -- ^ "tag"
  , storyResponseAllOfCustomField :: !(Maybe CustomFieldCompact) -- ^ "custom_field"
  , storyResponseAllOfOldTextValue :: !(Maybe Text) -- ^ "old_text_value" - *Conditional*
  , storyResponseAllOfNewTextValue :: !(Maybe Text) -- ^ "new_text_value" - *Conditional*
  , storyResponseAllOfOldNumberValue :: !(Maybe Int) -- ^ "old_number_value" - *Conditional*
  , storyResponseAllOfNewNumberValue :: !(Maybe Int) -- ^ "new_number_value" - *Conditional*
  , storyResponseAllOfOldEnumValue :: !(Maybe EnumOption) -- ^ "old_enum_value"
  , storyResponseAllOfNewEnumValue :: !(Maybe EnumOption) -- ^ "new_enum_value"
  , storyResponseAllOfNewApprovalStatus :: !(Maybe Text) -- ^ "new_approval_status" - *Conditional*
  , storyResponseAllOfOldApprovalStatus :: !(Maybe Text) -- ^ "old_approval_status" - *Conditional*
  , storyResponseAllOfDuplicateOf :: !(Maybe TaskCompact) -- ^ "duplicate_of"
  , storyResponseAllOfDuplicatedFrom :: !(Maybe TaskCompact) -- ^ "duplicated_from"
  , storyResponseAllOfDependency :: !(Maybe TaskCompact) -- ^ "dependency"
  , storyResponseAllOfSource :: !(Maybe E'Source) -- ^ "source" - The component of the Asana product the user used to trigger the story.
  , storyResponseAllOfTarget :: !(Maybe A.Value) -- ^ "target" - The object this story is associated with. Currently may only be a task.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StoryResponseAllOf
instance A.FromJSON StoryResponseAllOf where
  parseJSON = A.withObject "StoryResponseAllOf" $ \o ->
    StoryResponseAllOf
      <$> (o .:? "is_edited")
      <*> (o .:? "hearted")
      <*> (o .:? "hearts")
      <*> (o .:? "num_hearts")
      <*> (o .:? "liked")
      <*> (o .:? "likes")
      <*> (o .:? "num_likes")
      <*> (o .:? "previews")
      <*> (o .:? "old_name")
      <*> (o .:? "new_name")
      <*> (o .:? "old_dates")
      <*> (o .:? "new_dates")
      <*> (o .:? "old_resource_subtype")
      <*> (o .:? "new_resource_subtype")
      <*> (o .:? "story")
      <*> (o .:? "assignee")
      <*> (o .:? "follower")
      <*> (o .:? "old_section")
      <*> (o .:? "new_section")
      <*> (o .:? "task")
      <*> (o .:? "project")
      <*> (o .:? "tag")
      <*> (o .:? "custom_field")
      <*> (o .:? "old_text_value")
      <*> (o .:? "new_text_value")
      <*> (o .:? "old_number_value")
      <*> (o .:? "new_number_value")
      <*> (o .:? "old_enum_value")
      <*> (o .:? "new_enum_value")
      <*> (o .:? "new_approval_status")
      <*> (o .:? "old_approval_status")
      <*> (o .:? "duplicate_of")
      <*> (o .:? "duplicated_from")
      <*> (o .:? "dependency")
      <*> (o .:? "source")
      <*> (o .:? "target")

-- | ToJSON StoryResponseAllOf
instance A.ToJSON StoryResponseAllOf where
  toJSON StoryResponseAllOf {..} =
   _omitNulls
      [ "is_edited" .= storyResponseAllOfIsEdited
      , "hearted" .= storyResponseAllOfHearted
      , "hearts" .= storyResponseAllOfHearts
      , "num_hearts" .= storyResponseAllOfNumHearts
      , "liked" .= storyResponseAllOfLiked
      , "likes" .= storyResponseAllOfLikes
      , "num_likes" .= storyResponseAllOfNumLikes
      , "previews" .= storyResponseAllOfPreviews
      , "old_name" .= storyResponseAllOfOldName
      , "new_name" .= storyResponseAllOfNewName
      , "old_dates" .= storyResponseAllOfOldDates
      , "new_dates" .= storyResponseAllOfNewDates
      , "old_resource_subtype" .= storyResponseAllOfOldResourceSubtype
      , "new_resource_subtype" .= storyResponseAllOfNewResourceSubtype
      , "story" .= storyResponseAllOfStory
      , "assignee" .= storyResponseAllOfAssignee
      , "follower" .= storyResponseAllOfFollower
      , "old_section" .= storyResponseAllOfOldSection
      , "new_section" .= storyResponseAllOfNewSection
      , "task" .= storyResponseAllOfTask
      , "project" .= storyResponseAllOfProject
      , "tag" .= storyResponseAllOfTag
      , "custom_field" .= storyResponseAllOfCustomField
      , "old_text_value" .= storyResponseAllOfOldTextValue
      , "new_text_value" .= storyResponseAllOfNewTextValue
      , "old_number_value" .= storyResponseAllOfOldNumberValue
      , "new_number_value" .= storyResponseAllOfNewNumberValue
      , "old_enum_value" .= storyResponseAllOfOldEnumValue
      , "new_enum_value" .= storyResponseAllOfNewEnumValue
      , "new_approval_status" .= storyResponseAllOfNewApprovalStatus
      , "old_approval_status" .= storyResponseAllOfOldApprovalStatus
      , "duplicate_of" .= storyResponseAllOfDuplicateOf
      , "duplicated_from" .= storyResponseAllOfDuplicatedFrom
      , "dependency" .= storyResponseAllOfDependency
      , "source" .= storyResponseAllOfSource
      , "target" .= storyResponseAllOfTarget
      ]


-- | Construct a value of type 'StoryResponseAllOf' (by applying it's required fields, if any)
mkStoryResponseAllOf
  :: StoryResponseAllOf
mkStoryResponseAllOf =
  StoryResponseAllOf
  { storyResponseAllOfIsEdited = Nothing
  , storyResponseAllOfHearted = Nothing
  , storyResponseAllOfHearts = Nothing
  , storyResponseAllOfNumHearts = Nothing
  , storyResponseAllOfLiked = Nothing
  , storyResponseAllOfLikes = Nothing
  , storyResponseAllOfNumLikes = Nothing
  , storyResponseAllOfPreviews = Nothing
  , storyResponseAllOfOldName = Nothing
  , storyResponseAllOfNewName = Nothing
  , storyResponseAllOfOldDates = Nothing
  , storyResponseAllOfNewDates = Nothing
  , storyResponseAllOfOldResourceSubtype = Nothing
  , storyResponseAllOfNewResourceSubtype = Nothing
  , storyResponseAllOfStory = Nothing
  , storyResponseAllOfAssignee = Nothing
  , storyResponseAllOfFollower = Nothing
  , storyResponseAllOfOldSection = Nothing
  , storyResponseAllOfNewSection = Nothing
  , storyResponseAllOfTask = Nothing
  , storyResponseAllOfProject = Nothing
  , storyResponseAllOfTag = Nothing
  , storyResponseAllOfCustomField = Nothing
  , storyResponseAllOfOldTextValue = Nothing
  , storyResponseAllOfNewTextValue = Nothing
  , storyResponseAllOfOldNumberValue = Nothing
  , storyResponseAllOfNewNumberValue = Nothing
  , storyResponseAllOfOldEnumValue = Nothing
  , storyResponseAllOfNewEnumValue = Nothing
  , storyResponseAllOfNewApprovalStatus = Nothing
  , storyResponseAllOfOldApprovalStatus = Nothing
  , storyResponseAllOfDuplicateOf = Nothing
  , storyResponseAllOfDuplicatedFrom = Nothing
  , storyResponseAllOfDependency = Nothing
  , storyResponseAllOfSource = Nothing
  , storyResponseAllOfTarget = Nothing
  }

-- ** StoryResponseDates
-- | StoryResponseDates
-- *Conditional*
data StoryResponseDates = StoryResponseDates
  { storyResponseDatesStartOn :: !(Maybe Date) -- ^ "start_on"
  , storyResponseDatesDueAt :: !(Maybe DateTime) -- ^ "due_at"
  , storyResponseDatesDueOn :: !(Maybe Date) -- ^ "due_on"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StoryResponseDates
instance A.FromJSON StoryResponseDates where
  parseJSON = A.withObject "StoryResponseDates" $ \o ->
    StoryResponseDates
      <$> (o .:? "start_on")
      <*> (o .:? "due_at")
      <*> (o .:? "due_on")

-- | ToJSON StoryResponseDates
instance A.ToJSON StoryResponseDates where
  toJSON StoryResponseDates {..} =
   _omitNulls
      [ "start_on" .= storyResponseDatesStartOn
      , "due_at" .= storyResponseDatesDueAt
      , "due_on" .= storyResponseDatesDueOn
      ]


-- | Construct a value of type 'StoryResponseDates' (by applying it's required fields, if any)
mkStoryResponseDates
  :: StoryResponseDates
mkStoryResponseDates =
  StoryResponseDates
  { storyResponseDatesStartOn = Nothing
  , storyResponseDatesDueAt = Nothing
  , storyResponseDatesDueOn = Nothing
  }

-- ** TagBase
-- | TagBase
data TagBase = TagBase
  { tagBaseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , tagBaseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , tagBaseName :: !(Maybe Text) -- ^ "name" - Name of the tag. This is generally a short sentence fragment that fits on a line in the UI for maximum readability. However, it can be longer.
  , tagBaseColor :: !(Maybe E'Color) -- ^ "color" - Color of the tag.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TagBase
instance A.FromJSON TagBase where
  parseJSON = A.withObject "TagBase" $ \o ->
    TagBase
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "color")

-- | ToJSON TagBase
instance A.ToJSON TagBase where
  toJSON TagBase {..} =
   _omitNulls
      [ "gid" .= tagBaseGid
      , "resource_type" .= tagBaseResourceType
      , "name" .= tagBaseName
      , "color" .= tagBaseColor
      ]


-- | Construct a value of type 'TagBase' (by applying it's required fields, if any)
mkTagBase
  :: TagBase
mkTagBase =
  TagBase
  { tagBaseGid = Nothing
  , tagBaseResourceType = Nothing
  , tagBaseName = Nothing
  , tagBaseColor = Nothing
  }

-- ** TagBaseAllOf
-- | TagBaseAllOf
data TagBaseAllOf = TagBaseAllOf
  { tagBaseAllOfColor :: !(Maybe E'Color) -- ^ "color" - Color of the tag.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TagBaseAllOf
instance A.FromJSON TagBaseAllOf where
  parseJSON = A.withObject "TagBaseAllOf" $ \o ->
    TagBaseAllOf
      <$> (o .:? "color")

-- | ToJSON TagBaseAllOf
instance A.ToJSON TagBaseAllOf where
  toJSON TagBaseAllOf {..} =
   _omitNulls
      [ "color" .= tagBaseAllOfColor
      ]


-- | Construct a value of type 'TagBaseAllOf' (by applying it's required fields, if any)
mkTagBaseAllOf
  :: TagBaseAllOf
mkTagBaseAllOf =
  TagBaseAllOf
  { tagBaseAllOfColor = Nothing
  }

-- ** TagCompact
-- | TagCompact
data TagCompact = TagCompact
  { tagCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , tagCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , tagCompactName :: !(Maybe Text) -- ^ "name" - Name of the tag. This is generally a short sentence fragment that fits on a line in the UI for maximum readability. However, it can be longer.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TagCompact
instance A.FromJSON TagCompact where
  parseJSON = A.withObject "TagCompact" $ \o ->
    TagCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")

-- | ToJSON TagCompact
instance A.ToJSON TagCompact where
  toJSON TagCompact {..} =
   _omitNulls
      [ "gid" .= tagCompactGid
      , "resource_type" .= tagCompactResourceType
      , "name" .= tagCompactName
      ]


-- | Construct a value of type 'TagCompact' (by applying it's required fields, if any)
mkTagCompact
  :: TagCompact
mkTagCompact =
  TagCompact
  { tagCompactGid = Nothing
  , tagCompactResourceType = Nothing
  , tagCompactName = Nothing
  }

-- ** TagCompactAllOf
-- | TagCompactAllOf
-- A *tag* is a label that can be attached to any task in Asana. It exists in a single workspace or organization.
data TagCompactAllOf = TagCompactAllOf
  { tagCompactAllOfName :: !(Maybe Text) -- ^ "name" - Name of the tag. This is generally a short sentence fragment that fits on a line in the UI for maximum readability. However, it can be longer.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TagCompactAllOf
instance A.FromJSON TagCompactAllOf where
  parseJSON = A.withObject "TagCompactAllOf" $ \o ->
    TagCompactAllOf
      <$> (o .:? "name")

-- | ToJSON TagCompactAllOf
instance A.ToJSON TagCompactAllOf where
  toJSON TagCompactAllOf {..} =
   _omitNulls
      [ "name" .= tagCompactAllOfName
      ]


-- | Construct a value of type 'TagCompactAllOf' (by applying it's required fields, if any)
mkTagCompactAllOf
  :: TagCompactAllOf
mkTagCompactAllOf =
  TagCompactAllOf
  { tagCompactAllOfName = Nothing
  }

-- ** TagRequest
-- | TagRequest
data TagRequest = TagRequest
  { tagRequestGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , tagRequestResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , tagRequestName :: !(Maybe Text) -- ^ "name" - Name of the tag. This is generally a short sentence fragment that fits on a line in the UI for maximum readability. However, it can be longer.
  , tagRequestColor :: !(Maybe E'Color) -- ^ "color" - Color of the tag.
  , tagRequestFollowers :: !(Maybe [Text]) -- ^ "followers" - An array of strings identifying users. These can either be the string \&quot;me\&quot;, an email, or the gid of a user.
  , tagRequestWorkspace :: !(Maybe Text) -- ^ "workspace" - Gid of an object.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TagRequest
instance A.FromJSON TagRequest where
  parseJSON = A.withObject "TagRequest" $ \o ->
    TagRequest
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "color")
      <*> (o .:? "followers")
      <*> (o .:? "workspace")

-- | ToJSON TagRequest
instance A.ToJSON TagRequest where
  toJSON TagRequest {..} =
   _omitNulls
      [ "gid" .= tagRequestGid
      , "resource_type" .= tagRequestResourceType
      , "name" .= tagRequestName
      , "color" .= tagRequestColor
      , "followers" .= tagRequestFollowers
      , "workspace" .= tagRequestWorkspace
      ]


-- | Construct a value of type 'TagRequest' (by applying it's required fields, if any)
mkTagRequest
  :: TagRequest
mkTagRequest =
  TagRequest
  { tagRequestGid = Nothing
  , tagRequestResourceType = Nothing
  , tagRequestName = Nothing
  , tagRequestColor = Nothing
  , tagRequestFollowers = Nothing
  , tagRequestWorkspace = Nothing
  }

-- ** TagRequestAllOf
-- | TagRequestAllOf
data TagRequestAllOf = TagRequestAllOf
  { tagRequestAllOfFollowers :: !(Maybe [Text]) -- ^ "followers" - An array of strings identifying users. These can either be the string \&quot;me\&quot;, an email, or the gid of a user.
  , tagRequestAllOfWorkspace :: !(Maybe Text) -- ^ "workspace" - Gid of an object.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TagRequestAllOf
instance A.FromJSON TagRequestAllOf where
  parseJSON = A.withObject "TagRequestAllOf" $ \o ->
    TagRequestAllOf
      <$> (o .:? "followers")
      <*> (o .:? "workspace")

-- | ToJSON TagRequestAllOf
instance A.ToJSON TagRequestAllOf where
  toJSON TagRequestAllOf {..} =
   _omitNulls
      [ "followers" .= tagRequestAllOfFollowers
      , "workspace" .= tagRequestAllOfWorkspace
      ]


-- | Construct a value of type 'TagRequestAllOf' (by applying it's required fields, if any)
mkTagRequestAllOf
  :: TagRequestAllOf
mkTagRequestAllOf =
  TagRequestAllOf
  { tagRequestAllOfFollowers = Nothing
  , tagRequestAllOfWorkspace = Nothing
  }

-- ** TagResponse
-- | TagResponse
data TagResponse = TagResponse
  { tagResponseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , tagResponseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , tagResponseName :: !(Maybe Text) -- ^ "name" - Name of the tag. This is generally a short sentence fragment that fits on a line in the UI for maximum readability. However, it can be longer.
  , tagResponseColor :: !(Maybe E'Color) -- ^ "color" - Color of the tag.
  , tagResponseFollowers :: !(Maybe [UserCompact]) -- ^ "followers" - Array of users following this tag.
  , tagResponseWorkspace :: !(Maybe WorkspaceCompact) -- ^ "workspace"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TagResponse
instance A.FromJSON TagResponse where
  parseJSON = A.withObject "TagResponse" $ \o ->
    TagResponse
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "color")
      <*> (o .:? "followers")
      <*> (o .:? "workspace")

-- | ToJSON TagResponse
instance A.ToJSON TagResponse where
  toJSON TagResponse {..} =
   _omitNulls
      [ "gid" .= tagResponseGid
      , "resource_type" .= tagResponseResourceType
      , "name" .= tagResponseName
      , "color" .= tagResponseColor
      , "followers" .= tagResponseFollowers
      , "workspace" .= tagResponseWorkspace
      ]


-- | Construct a value of type 'TagResponse' (by applying it's required fields, if any)
mkTagResponse
  :: TagResponse
mkTagResponse =
  TagResponse
  { tagResponseGid = Nothing
  , tagResponseResourceType = Nothing
  , tagResponseName = Nothing
  , tagResponseColor = Nothing
  , tagResponseFollowers = Nothing
  , tagResponseWorkspace = Nothing
  }

-- ** TagResponseAllOf
-- | TagResponseAllOf
data TagResponseAllOf = TagResponseAllOf
  { tagResponseAllOfFollowers :: !(Maybe [UserCompact]) -- ^ "followers" - Array of users following this tag.
  , tagResponseAllOfWorkspace :: !(Maybe WorkspaceCompact) -- ^ "workspace"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TagResponseAllOf
instance A.FromJSON TagResponseAllOf where
  parseJSON = A.withObject "TagResponseAllOf" $ \o ->
    TagResponseAllOf
      <$> (o .:? "followers")
      <*> (o .:? "workspace")

-- | ToJSON TagResponseAllOf
instance A.ToJSON TagResponseAllOf where
  toJSON TagResponseAllOf {..} =
   _omitNulls
      [ "followers" .= tagResponseAllOfFollowers
      , "workspace" .= tagResponseAllOfWorkspace
      ]


-- | Construct a value of type 'TagResponseAllOf' (by applying it's required fields, if any)
mkTagResponseAllOf
  :: TagResponseAllOf
mkTagResponseAllOf =
  TagResponseAllOf
  { tagResponseAllOfFollowers = Nothing
  , tagResponseAllOfWorkspace = Nothing
  }

-- ** TaskAddFollowersRequest
-- | TaskAddFollowersRequest
data TaskAddFollowersRequest = TaskAddFollowersRequest
  { taskAddFollowersRequestFollowers :: !([Text]) -- ^ /Required/ "followers" - An array of strings identifying users. These can either be the string \&quot;me\&quot;, an email, or the gid of a user.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskAddFollowersRequest
instance A.FromJSON TaskAddFollowersRequest where
  parseJSON = A.withObject "TaskAddFollowersRequest" $ \o ->
    TaskAddFollowersRequest
      <$> (o .:  "followers")

-- | ToJSON TaskAddFollowersRequest
instance A.ToJSON TaskAddFollowersRequest where
  toJSON TaskAddFollowersRequest {..} =
   _omitNulls
      [ "followers" .= taskAddFollowersRequestFollowers
      ]


-- | Construct a value of type 'TaskAddFollowersRequest' (by applying it's required fields, if any)
mkTaskAddFollowersRequest
  :: [Text] -- ^ 'taskAddFollowersRequestFollowers': An array of strings identifying users. These can either be the string \"me\", an email, or the gid of a user.
  -> TaskAddFollowersRequest
mkTaskAddFollowersRequest taskAddFollowersRequestFollowers =
  TaskAddFollowersRequest
  { taskAddFollowersRequestFollowers
  }

-- ** TaskAddProjectRequest
-- | TaskAddProjectRequest
data TaskAddProjectRequest = TaskAddProjectRequest
  { taskAddProjectRequestProject :: !(Text) -- ^ /Required/ "project" - The project to add the task to.
  , taskAddProjectRequestInsertAfter :: !(Maybe Text) -- ^ "insert_after" - A task in the project to insert the task after, or &#x60;null&#x60; to insert at the beginning of the list.
  , taskAddProjectRequestInsertBefore :: !(Maybe Text) -- ^ "insert_before" - A task in the project to insert the task before, or &#x60;null&#x60; to insert at the end of the list.
  , taskAddProjectRequestSection :: !(Maybe Text) -- ^ "section" - A section in the project to insert the task into. The task will be inserted at the bottom of the section.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskAddProjectRequest
instance A.FromJSON TaskAddProjectRequest where
  parseJSON = A.withObject "TaskAddProjectRequest" $ \o ->
    TaskAddProjectRequest
      <$> (o .:  "project")
      <*> (o .:? "insert_after")
      <*> (o .:? "insert_before")
      <*> (o .:? "section")

-- | ToJSON TaskAddProjectRequest
instance A.ToJSON TaskAddProjectRequest where
  toJSON TaskAddProjectRequest {..} =
   _omitNulls
      [ "project" .= taskAddProjectRequestProject
      , "insert_after" .= taskAddProjectRequestInsertAfter
      , "insert_before" .= taskAddProjectRequestInsertBefore
      , "section" .= taskAddProjectRequestSection
      ]


-- | Construct a value of type 'TaskAddProjectRequest' (by applying it's required fields, if any)
mkTaskAddProjectRequest
  :: Text -- ^ 'taskAddProjectRequestProject': The project to add the task to.
  -> TaskAddProjectRequest
mkTaskAddProjectRequest taskAddProjectRequestProject =
  TaskAddProjectRequest
  { taskAddProjectRequestProject
  , taskAddProjectRequestInsertAfter = Nothing
  , taskAddProjectRequestInsertBefore = Nothing
  , taskAddProjectRequestSection = Nothing
  }

-- ** TaskAddTagRequest
-- | TaskAddTagRequest
data TaskAddTagRequest = TaskAddTagRequest
  { taskAddTagRequestTag :: !(Text) -- ^ /Required/ "tag" - The tag to add to the task.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskAddTagRequest
instance A.FromJSON TaskAddTagRequest where
  parseJSON = A.withObject "TaskAddTagRequest" $ \o ->
    TaskAddTagRequest
      <$> (o .:  "tag")

-- | ToJSON TaskAddTagRequest
instance A.ToJSON TaskAddTagRequest where
  toJSON TaskAddTagRequest {..} =
   _omitNulls
      [ "tag" .= taskAddTagRequestTag
      ]


-- | Construct a value of type 'TaskAddTagRequest' (by applying it's required fields, if any)
mkTaskAddTagRequest
  :: Text -- ^ 'taskAddTagRequestTag': The tag to add to the task.
  -> TaskAddTagRequest
mkTaskAddTagRequest taskAddTagRequestTag =
  TaskAddTagRequest
  { taskAddTagRequestTag
  }

-- ** TaskBase
-- | TaskBase
data TaskBase = TaskBase
  { taskBaseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , taskBaseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , taskBaseName :: !(Maybe Text) -- ^ "name" - Name of the task. This is generally a short sentence fragment that fits on a line in the UI for maximum readability. However, it can be longer.
  , taskBaseApprovalStatus :: !(Maybe E'ApprovalStatus) -- ^ "approval_status" - *Conditional* Reflects the approval status of this task. This field is kept in sync with &#x60;completed&#x60;, meaning &#x60;pending&#x60; translates to false while &#x60;approved&#x60;, &#x60;rejected&#x60;, and &#x60;changes_requested&#x60; translate to true. If you set completed to true, this field will be set to &#x60;approved&#x60;.
  , taskBaseAssigneeStatus :: !(Maybe E'AssigneeStatus) -- ^ "assignee_status" - Scheduling status of this task for the user it is assigned to. This field can only be set if the assignee is non-null. Setting this field to \&quot;inbox\&quot; or \&quot;upcoming\&quot; inserts it at the top of the section, while the other options will insert at the bottom.
  , taskBaseCompleted :: !(Maybe Bool) -- ^ "completed" - True if the task is currently marked complete, false if not.
  , taskBaseCompletedAt :: !(Maybe DateTime) -- ^ "completed_at" - The time at which this task was completed, or null if the task is incomplete.
  , taskBaseCompletedBy :: !(Maybe UserCompact) -- ^ "completed_by"
  , taskBaseCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , taskBaseDependencies :: !(Maybe [AsanaResource]) -- ^ "dependencies" - [Opt In](#input-output-options). Array of resources referencing tasks that this task depends on. The objects contain only the gid of the dependency.
  , taskBaseDependents :: !(Maybe [AsanaResource]) -- ^ "dependents" - [Opt In](#input-output-options). Array of resources referencing tasks that depend on this task. The objects contain only the ID of the dependent.
  , taskBaseDueAt :: !(Maybe Date) -- ^ "due_at" - Date and time on which this task is due, or null if the task has no due time. This takes a UTC timestamp and should not be used together with &#x60;due_on&#x60;.
  , taskBaseDueOn :: !(Maybe Date) -- ^ "due_on" - Date on which this task is due, or null if the task has no due date.  This takes a date with &#x60;YYYY-MM-DD&#x60; format and should not be used together with due_at.
  , taskBaseExternal :: !(Maybe TaskBaseAllOfExternal) -- ^ "external"
  , taskBaseHtmlNotes :: !(Maybe Text) -- ^ "html_notes" - [Opt In](#input-output-options). The notes of the text with formatting as HTML.
  , taskBaseHearted :: !(Maybe Bool) -- ^ "hearted" - *Deprecated - please use liked instead* True if the task is hearted by the authorized user, false if not.
  , taskBaseHearts :: !(Maybe [Like]) -- ^ "hearts" - *Deprecated - please use likes instead* Array of likes for users who have hearted this task.
  , taskBaseIsRenderedAsSeparator :: !(Maybe Bool) -- ^ "is_rendered_as_separator" - [Opt In](#input-output-options). In some contexts tasks can be rendered as a visual separator; for instance, subtasks can appear similar to [sections](#asana-sections) without being true &#x60;section&#x60; objects. If a &#x60;task&#x60; object is rendered this way in any context it will have the property &#x60;is_rendered_as_separator&#x60; set to &#x60;true&#x60;.
  , taskBaseLiked :: !(Maybe Bool) -- ^ "liked" - True if the task is liked by the authorized user, false if not.
  , taskBaseLikes :: !(Maybe [Like]) -- ^ "likes" - Array of likes for users who have liked this task.
  , taskBaseMemberships :: !(Maybe [TaskBaseAllOfMemberships]) -- ^ "memberships" - *Create-only*. Array of projects this task is associated with and the section it is in. At task creation time, this array can be used to add the task to specific sections. After task creation, these associations can be modified using the &#x60;addProject&#x60; and &#x60;removeProject&#x60; endpoints. Note that over time, more types of memberships may be added to this property.
  , taskBaseModifiedAt :: !(Maybe DateTime) -- ^ "modified_at" - The time at which this task was last modified.  *Note: This does not currently reflect any changes in associations such as projects or comments that may have been added or removed from the task.*
  , taskBaseNotes :: !(Maybe Text) -- ^ "notes" - More detailed, free-form textual information associated with the task.
  , taskBaseNumHearts :: !(Maybe Int) -- ^ "num_hearts" - *Deprecated - please use likes instead* The number of users who have hearted this task.
  , taskBaseNumLikes :: !(Maybe Int) -- ^ "num_likes" - The number of users who have liked this task.
  , taskBaseNumSubtasks :: !(Maybe Int) -- ^ "num_subtasks" - [Opt In](#input-output-options). The number of subtasks on this task. 
  , taskBaseResourceSubtype :: !(Maybe E'ResourceSubtype2) -- ^ "resource_subtype" - The subtype of this resource. Different subtypes retain many of the same fields and behavior, but may render differently in Asana or represent resources with different semantic meaning. The resource_subtype &#x60;milestone&#x60; represent a single moment in time. This means tasks with this subtype cannot have a start_date.
  , taskBaseStartOn :: !(Maybe Date) -- ^ "start_on" - The day on which work begins for the task , or null if the task has no start date. This takes a date with &#x60;YYYY-MM-DD&#x60; format. *Note: &#x60;due_on&#x60; or &#x60;due_at&#x60; must be present in the request when setting or unsetting the &#x60;start_on&#x60; parameter.*
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskBase
instance A.FromJSON TaskBase where
  parseJSON = A.withObject "TaskBase" $ \o ->
    TaskBase
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "approval_status")
      <*> (o .:? "assignee_status")
      <*> (o .:? "completed")
      <*> (o .:? "completed_at")
      <*> (o .:? "completed_by")
      <*> (o .:? "created_at")
      <*> (o .:? "dependencies")
      <*> (o .:? "dependents")
      <*> (o .:? "due_at")
      <*> (o .:? "due_on")
      <*> (o .:? "external")
      <*> (o .:? "html_notes")
      <*> (o .:? "hearted")
      <*> (o .:? "hearts")
      <*> (o .:? "is_rendered_as_separator")
      <*> (o .:? "liked")
      <*> (o .:? "likes")
      <*> (o .:? "memberships")
      <*> (o .:? "modified_at")
      <*> (o .:? "notes")
      <*> (o .:? "num_hearts")
      <*> (o .:? "num_likes")
      <*> (o .:? "num_subtasks")
      <*> (o .:? "resource_subtype")
      <*> (o .:? "start_on")

-- | ToJSON TaskBase
instance A.ToJSON TaskBase where
  toJSON TaskBase {..} =
   _omitNulls
      [ "gid" .= taskBaseGid
      , "resource_type" .= taskBaseResourceType
      , "name" .= taskBaseName
      , "approval_status" .= taskBaseApprovalStatus
      , "assignee_status" .= taskBaseAssigneeStatus
      , "completed" .= taskBaseCompleted
      , "completed_at" .= taskBaseCompletedAt
      , "completed_by" .= taskBaseCompletedBy
      , "created_at" .= taskBaseCreatedAt
      , "dependencies" .= taskBaseDependencies
      , "dependents" .= taskBaseDependents
      , "due_at" .= taskBaseDueAt
      , "due_on" .= taskBaseDueOn
      , "external" .= taskBaseExternal
      , "html_notes" .= taskBaseHtmlNotes
      , "hearted" .= taskBaseHearted
      , "hearts" .= taskBaseHearts
      , "is_rendered_as_separator" .= taskBaseIsRenderedAsSeparator
      , "liked" .= taskBaseLiked
      , "likes" .= taskBaseLikes
      , "memberships" .= taskBaseMemberships
      , "modified_at" .= taskBaseModifiedAt
      , "notes" .= taskBaseNotes
      , "num_hearts" .= taskBaseNumHearts
      , "num_likes" .= taskBaseNumLikes
      , "num_subtasks" .= taskBaseNumSubtasks
      , "resource_subtype" .= taskBaseResourceSubtype
      , "start_on" .= taskBaseStartOn
      ]


-- | Construct a value of type 'TaskBase' (by applying it's required fields, if any)
mkTaskBase
  :: TaskBase
mkTaskBase =
  TaskBase
  { taskBaseGid = Nothing
  , taskBaseResourceType = Nothing
  , taskBaseName = Nothing
  , taskBaseApprovalStatus = Nothing
  , taskBaseAssigneeStatus = Nothing
  , taskBaseCompleted = Nothing
  , taskBaseCompletedAt = Nothing
  , taskBaseCompletedBy = Nothing
  , taskBaseCreatedAt = Nothing
  , taskBaseDependencies = Nothing
  , taskBaseDependents = Nothing
  , taskBaseDueAt = Nothing
  , taskBaseDueOn = Nothing
  , taskBaseExternal = Nothing
  , taskBaseHtmlNotes = Nothing
  , taskBaseHearted = Nothing
  , taskBaseHearts = Nothing
  , taskBaseIsRenderedAsSeparator = Nothing
  , taskBaseLiked = Nothing
  , taskBaseLikes = Nothing
  , taskBaseMemberships = Nothing
  , taskBaseModifiedAt = Nothing
  , taskBaseNotes = Nothing
  , taskBaseNumHearts = Nothing
  , taskBaseNumLikes = Nothing
  , taskBaseNumSubtasks = Nothing
  , taskBaseResourceSubtype = Nothing
  , taskBaseStartOn = Nothing
  }

-- ** TaskBaseAllOf
-- | TaskBaseAllOf
data TaskBaseAllOf = TaskBaseAllOf
  { taskBaseAllOfApprovalStatus :: !(Maybe E'ApprovalStatus) -- ^ "approval_status" - *Conditional* Reflects the approval status of this task. This field is kept in sync with &#x60;completed&#x60;, meaning &#x60;pending&#x60; translates to false while &#x60;approved&#x60;, &#x60;rejected&#x60;, and &#x60;changes_requested&#x60; translate to true. If you set completed to true, this field will be set to &#x60;approved&#x60;.
  , taskBaseAllOfAssigneeStatus :: !(Maybe E'AssigneeStatus) -- ^ "assignee_status" - Scheduling status of this task for the user it is assigned to. This field can only be set if the assignee is non-null. Setting this field to \&quot;inbox\&quot; or \&quot;upcoming\&quot; inserts it at the top of the section, while the other options will insert at the bottom.
  , taskBaseAllOfCompleted :: !(Maybe Bool) -- ^ "completed" - True if the task is currently marked complete, false if not.
  , taskBaseAllOfCompletedAt :: !(Maybe DateTime) -- ^ "completed_at" - The time at which this task was completed, or null if the task is incomplete.
  , taskBaseAllOfCompletedBy :: !(Maybe UserCompact) -- ^ "completed_by"
  , taskBaseAllOfCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , taskBaseAllOfDependencies :: !(Maybe [AsanaResource]) -- ^ "dependencies" - [Opt In](#input-output-options). Array of resources referencing tasks that this task depends on. The objects contain only the gid of the dependency.
  , taskBaseAllOfDependents :: !(Maybe [AsanaResource]) -- ^ "dependents" - [Opt In](#input-output-options). Array of resources referencing tasks that depend on this task. The objects contain only the ID of the dependent.
  , taskBaseAllOfDueAt :: !(Maybe Date) -- ^ "due_at" - Date and time on which this task is due, or null if the task has no due time. This takes a UTC timestamp and should not be used together with &#x60;due_on&#x60;.
  , taskBaseAllOfDueOn :: !(Maybe Date) -- ^ "due_on" - Date on which this task is due, or null if the task has no due date.  This takes a date with &#x60;YYYY-MM-DD&#x60; format and should not be used together with due_at.
  , taskBaseAllOfExternal :: !(Maybe TaskBaseAllOfExternal) -- ^ "external"
  , taskBaseAllOfHtmlNotes :: !(Maybe Text) -- ^ "html_notes" - [Opt In](#input-output-options). The notes of the text with formatting as HTML.
  , taskBaseAllOfHearted :: !(Maybe Bool) -- ^ "hearted" - *Deprecated - please use liked instead* True if the task is hearted by the authorized user, false if not.
  , taskBaseAllOfHearts :: !(Maybe [Like]) -- ^ "hearts" - *Deprecated - please use likes instead* Array of likes for users who have hearted this task.
  , taskBaseAllOfIsRenderedAsSeparator :: !(Maybe Bool) -- ^ "is_rendered_as_separator" - [Opt In](#input-output-options). In some contexts tasks can be rendered as a visual separator; for instance, subtasks can appear similar to [sections](#asana-sections) without being true &#x60;section&#x60; objects. If a &#x60;task&#x60; object is rendered this way in any context it will have the property &#x60;is_rendered_as_separator&#x60; set to &#x60;true&#x60;.
  , taskBaseAllOfLiked :: !(Maybe Bool) -- ^ "liked" - True if the task is liked by the authorized user, false if not.
  , taskBaseAllOfLikes :: !(Maybe [Like]) -- ^ "likes" - Array of likes for users who have liked this task.
  , taskBaseAllOfMemberships :: !(Maybe [TaskBaseAllOfMemberships]) -- ^ "memberships" - *Create-only*. Array of projects this task is associated with and the section it is in. At task creation time, this array can be used to add the task to specific sections. After task creation, these associations can be modified using the &#x60;addProject&#x60; and &#x60;removeProject&#x60; endpoints. Note that over time, more types of memberships may be added to this property.
  , taskBaseAllOfModifiedAt :: !(Maybe DateTime) -- ^ "modified_at" - The time at which this task was last modified.  *Note: This does not currently reflect any changes in associations such as projects or comments that may have been added or removed from the task.*
  , taskBaseAllOfName :: !(Maybe Text) -- ^ "name" - Name of the task. This is generally a short sentence fragment that fits on a line in the UI for maximum readability. However, it can be longer.
  , taskBaseAllOfNotes :: !(Maybe Text) -- ^ "notes" - More detailed, free-form textual information associated with the task.
  , taskBaseAllOfNumHearts :: !(Maybe Int) -- ^ "num_hearts" - *Deprecated - please use likes instead* The number of users who have hearted this task.
  , taskBaseAllOfNumLikes :: !(Maybe Int) -- ^ "num_likes" - The number of users who have liked this task.
  , taskBaseAllOfNumSubtasks :: !(Maybe Int) -- ^ "num_subtasks" - [Opt In](#input-output-options). The number of subtasks on this task. 
  , taskBaseAllOfResourceSubtype :: !(Maybe E'ResourceSubtype2) -- ^ "resource_subtype" - The subtype of this resource. Different subtypes retain many of the same fields and behavior, but may render differently in Asana or represent resources with different semantic meaning. The resource_subtype &#x60;milestone&#x60; represent a single moment in time. This means tasks with this subtype cannot have a start_date.
  , taskBaseAllOfStartOn :: !(Maybe Date) -- ^ "start_on" - The day on which work begins for the task , or null if the task has no start date. This takes a date with &#x60;YYYY-MM-DD&#x60; format. *Note: &#x60;due_on&#x60; or &#x60;due_at&#x60; must be present in the request when setting or unsetting the &#x60;start_on&#x60; parameter.*
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskBaseAllOf
instance A.FromJSON TaskBaseAllOf where
  parseJSON = A.withObject "TaskBaseAllOf" $ \o ->
    TaskBaseAllOf
      <$> (o .:? "approval_status")
      <*> (o .:? "assignee_status")
      <*> (o .:? "completed")
      <*> (o .:? "completed_at")
      <*> (o .:? "completed_by")
      <*> (o .:? "created_at")
      <*> (o .:? "dependencies")
      <*> (o .:? "dependents")
      <*> (o .:? "due_at")
      <*> (o .:? "due_on")
      <*> (o .:? "external")
      <*> (o .:? "html_notes")
      <*> (o .:? "hearted")
      <*> (o .:? "hearts")
      <*> (o .:? "is_rendered_as_separator")
      <*> (o .:? "liked")
      <*> (o .:? "likes")
      <*> (o .:? "memberships")
      <*> (o .:? "modified_at")
      <*> (o .:? "name")
      <*> (o .:? "notes")
      <*> (o .:? "num_hearts")
      <*> (o .:? "num_likes")
      <*> (o .:? "num_subtasks")
      <*> (o .:? "resource_subtype")
      <*> (o .:? "start_on")

-- | ToJSON TaskBaseAllOf
instance A.ToJSON TaskBaseAllOf where
  toJSON TaskBaseAllOf {..} =
   _omitNulls
      [ "approval_status" .= taskBaseAllOfApprovalStatus
      , "assignee_status" .= taskBaseAllOfAssigneeStatus
      , "completed" .= taskBaseAllOfCompleted
      , "completed_at" .= taskBaseAllOfCompletedAt
      , "completed_by" .= taskBaseAllOfCompletedBy
      , "created_at" .= taskBaseAllOfCreatedAt
      , "dependencies" .= taskBaseAllOfDependencies
      , "dependents" .= taskBaseAllOfDependents
      , "due_at" .= taskBaseAllOfDueAt
      , "due_on" .= taskBaseAllOfDueOn
      , "external" .= taskBaseAllOfExternal
      , "html_notes" .= taskBaseAllOfHtmlNotes
      , "hearted" .= taskBaseAllOfHearted
      , "hearts" .= taskBaseAllOfHearts
      , "is_rendered_as_separator" .= taskBaseAllOfIsRenderedAsSeparator
      , "liked" .= taskBaseAllOfLiked
      , "likes" .= taskBaseAllOfLikes
      , "memberships" .= taskBaseAllOfMemberships
      , "modified_at" .= taskBaseAllOfModifiedAt
      , "name" .= taskBaseAllOfName
      , "notes" .= taskBaseAllOfNotes
      , "num_hearts" .= taskBaseAllOfNumHearts
      , "num_likes" .= taskBaseAllOfNumLikes
      , "num_subtasks" .= taskBaseAllOfNumSubtasks
      , "resource_subtype" .= taskBaseAllOfResourceSubtype
      , "start_on" .= taskBaseAllOfStartOn
      ]


-- | Construct a value of type 'TaskBaseAllOf' (by applying it's required fields, if any)
mkTaskBaseAllOf
  :: TaskBaseAllOf
mkTaskBaseAllOf =
  TaskBaseAllOf
  { taskBaseAllOfApprovalStatus = Nothing
  , taskBaseAllOfAssigneeStatus = Nothing
  , taskBaseAllOfCompleted = Nothing
  , taskBaseAllOfCompletedAt = Nothing
  , taskBaseAllOfCompletedBy = Nothing
  , taskBaseAllOfCreatedAt = Nothing
  , taskBaseAllOfDependencies = Nothing
  , taskBaseAllOfDependents = Nothing
  , taskBaseAllOfDueAt = Nothing
  , taskBaseAllOfDueOn = Nothing
  , taskBaseAllOfExternal = Nothing
  , taskBaseAllOfHtmlNotes = Nothing
  , taskBaseAllOfHearted = Nothing
  , taskBaseAllOfHearts = Nothing
  , taskBaseAllOfIsRenderedAsSeparator = Nothing
  , taskBaseAllOfLiked = Nothing
  , taskBaseAllOfLikes = Nothing
  , taskBaseAllOfMemberships = Nothing
  , taskBaseAllOfModifiedAt = Nothing
  , taskBaseAllOfName = Nothing
  , taskBaseAllOfNotes = Nothing
  , taskBaseAllOfNumHearts = Nothing
  , taskBaseAllOfNumLikes = Nothing
  , taskBaseAllOfNumSubtasks = Nothing
  , taskBaseAllOfResourceSubtype = Nothing
  , taskBaseAllOfStartOn = Nothing
  }

-- ** TaskBaseAllOfExternal
-- | TaskBaseAllOfExternal
-- *OAuth Required*. *Conditional*. This field is returned only if external values are set or included by using [Opt In] (#input-output-options). The external field allows you to store app-specific metadata on tasks, including a gid that can be used to retrieve tasks and a data blob that can store app-specific character strings. Note that you will need to authenticate with Oauth to access or modify this data. Once an external gid is set, you can use the notation `external:custom_gid` to reference your object anywhere in the API where you may use the original object gid. See the page on Custom External Data for more details.
data TaskBaseAllOfExternal = TaskBaseAllOfExternal
  { taskBaseAllOfExternalGid :: !(Maybe Text) -- ^ "gid"
  , taskBaseAllOfExternalData :: !(Maybe Text) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskBaseAllOfExternal
instance A.FromJSON TaskBaseAllOfExternal where
  parseJSON = A.withObject "TaskBaseAllOfExternal" $ \o ->
    TaskBaseAllOfExternal
      <$> (o .:? "gid")
      <*> (o .:? "data")

-- | ToJSON TaskBaseAllOfExternal
instance A.ToJSON TaskBaseAllOfExternal where
  toJSON TaskBaseAllOfExternal {..} =
   _omitNulls
      [ "gid" .= taskBaseAllOfExternalGid
      , "data" .= taskBaseAllOfExternalData
      ]


-- | Construct a value of type 'TaskBaseAllOfExternal' (by applying it's required fields, if any)
mkTaskBaseAllOfExternal
  :: TaskBaseAllOfExternal
mkTaskBaseAllOfExternal =
  TaskBaseAllOfExternal
  { taskBaseAllOfExternalGid = Nothing
  , taskBaseAllOfExternalData = Nothing
  }

-- ** TaskBaseAllOfMemberships
-- | TaskBaseAllOfMemberships
data TaskBaseAllOfMemberships = TaskBaseAllOfMemberships
  { taskBaseAllOfMembershipsProject :: !(Maybe ProjectCompact) -- ^ "project"
  , taskBaseAllOfMembershipsSection :: !(Maybe SectionCompact) -- ^ "section"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskBaseAllOfMemberships
instance A.FromJSON TaskBaseAllOfMemberships where
  parseJSON = A.withObject "TaskBaseAllOfMemberships" $ \o ->
    TaskBaseAllOfMemberships
      <$> (o .:? "project")
      <*> (o .:? "section")

-- | ToJSON TaskBaseAllOfMemberships
instance A.ToJSON TaskBaseAllOfMemberships where
  toJSON TaskBaseAllOfMemberships {..} =
   _omitNulls
      [ "project" .= taskBaseAllOfMembershipsProject
      , "section" .= taskBaseAllOfMembershipsSection
      ]


-- | Construct a value of type 'TaskBaseAllOfMemberships' (by applying it's required fields, if any)
mkTaskBaseAllOfMemberships
  :: TaskBaseAllOfMemberships
mkTaskBaseAllOfMemberships =
  TaskBaseAllOfMemberships
  { taskBaseAllOfMembershipsProject = Nothing
  , taskBaseAllOfMembershipsSection = Nothing
  }

-- ** TaskCompact
-- | TaskCompact
data TaskCompact = TaskCompact
  { taskCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , taskCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , taskCompactName :: !(Maybe Text) -- ^ "name" - The name of the task.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskCompact
instance A.FromJSON TaskCompact where
  parseJSON = A.withObject "TaskCompact" $ \o ->
    TaskCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")

-- | ToJSON TaskCompact
instance A.ToJSON TaskCompact where
  toJSON TaskCompact {..} =
   _omitNulls
      [ "gid" .= taskCompactGid
      , "resource_type" .= taskCompactResourceType
      , "name" .= taskCompactName
      ]


-- | Construct a value of type 'TaskCompact' (by applying it's required fields, if any)
mkTaskCompact
  :: TaskCompact
mkTaskCompact =
  TaskCompact
  { taskCompactGid = Nothing
  , taskCompactResourceType = Nothing
  , taskCompactName = Nothing
  }

-- ** TaskCompactAllOf
-- | TaskCompactAllOf
-- The *task* is the basic object around which many operations in Asana are centered.
data TaskCompactAllOf = TaskCompactAllOf
  { taskCompactAllOfName :: !(Maybe Text) -- ^ "name" - The name of the task.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskCompactAllOf
instance A.FromJSON TaskCompactAllOf where
  parseJSON = A.withObject "TaskCompactAllOf" $ \o ->
    TaskCompactAllOf
      <$> (o .:? "name")

-- | ToJSON TaskCompactAllOf
instance A.ToJSON TaskCompactAllOf where
  toJSON TaskCompactAllOf {..} =
   _omitNulls
      [ "name" .= taskCompactAllOfName
      ]


-- | Construct a value of type 'TaskCompactAllOf' (by applying it's required fields, if any)
mkTaskCompactAllOf
  :: TaskCompactAllOf
mkTaskCompactAllOf =
  TaskCompactAllOf
  { taskCompactAllOfName = Nothing
  }

-- ** TaskCountResponse
-- | TaskCountResponse
-- A response object returned from the task count endpoint.
data TaskCountResponse = TaskCountResponse
  { taskCountResponseNumTasks :: !(Maybe Int) -- ^ "num_tasks" - The number of tasks in a project.
  , taskCountResponseNumIncompleteTasks :: !(Maybe Int) -- ^ "num_incomplete_tasks" - The number of incomplete tasks in a project.
  , taskCountResponseNumCompletedTasks :: !(Maybe Int) -- ^ "num_completed_tasks" - The number of completed tasks in a project.
  , taskCountResponseNumMilestones :: !(Maybe Int) -- ^ "num_milestones" - The number of milestones in a project.
  , taskCountResponseNumIncompleteMilestones :: !(Maybe Int) -- ^ "num_incomplete_milestones" - The number of incomplete milestones in a project.
  , taskCountResponseNumCompletedMilestones :: !(Maybe Int) -- ^ "num_completed_milestones" - The number of completed milestones in a project.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskCountResponse
instance A.FromJSON TaskCountResponse where
  parseJSON = A.withObject "TaskCountResponse" $ \o ->
    TaskCountResponse
      <$> (o .:? "num_tasks")
      <*> (o .:? "num_incomplete_tasks")
      <*> (o .:? "num_completed_tasks")
      <*> (o .:? "num_milestones")
      <*> (o .:? "num_incomplete_milestones")
      <*> (o .:? "num_completed_milestones")

-- | ToJSON TaskCountResponse
instance A.ToJSON TaskCountResponse where
  toJSON TaskCountResponse {..} =
   _omitNulls
      [ "num_tasks" .= taskCountResponseNumTasks
      , "num_incomplete_tasks" .= taskCountResponseNumIncompleteTasks
      , "num_completed_tasks" .= taskCountResponseNumCompletedTasks
      , "num_milestones" .= taskCountResponseNumMilestones
      , "num_incomplete_milestones" .= taskCountResponseNumIncompleteMilestones
      , "num_completed_milestones" .= taskCountResponseNumCompletedMilestones
      ]


-- | Construct a value of type 'TaskCountResponse' (by applying it's required fields, if any)
mkTaskCountResponse
  :: TaskCountResponse
mkTaskCountResponse =
  TaskCountResponse
  { taskCountResponseNumTasks = Nothing
  , taskCountResponseNumIncompleteTasks = Nothing
  , taskCountResponseNumCompletedTasks = Nothing
  , taskCountResponseNumMilestones = Nothing
  , taskCountResponseNumIncompleteMilestones = Nothing
  , taskCountResponseNumCompletedMilestones = Nothing
  }

-- ** TaskDuplicateRequest
-- | TaskDuplicateRequest
data TaskDuplicateRequest = TaskDuplicateRequest
  { taskDuplicateRequestName :: !(Maybe Text) -- ^ "name" - The name of the new task.
  , taskDuplicateRequestInclude :: !(Maybe E'Include2) -- ^ "include" - The fields that will be duplicated to the new task.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskDuplicateRequest
instance A.FromJSON TaskDuplicateRequest where
  parseJSON = A.withObject "TaskDuplicateRequest" $ \o ->
    TaskDuplicateRequest
      <$> (o .:? "name")
      <*> (o .:? "include")

-- | ToJSON TaskDuplicateRequest
instance A.ToJSON TaskDuplicateRequest where
  toJSON TaskDuplicateRequest {..} =
   _omitNulls
      [ "name" .= taskDuplicateRequestName
      , "include" .= taskDuplicateRequestInclude
      ]


-- | Construct a value of type 'TaskDuplicateRequest' (by applying it's required fields, if any)
mkTaskDuplicateRequest
  :: TaskDuplicateRequest
mkTaskDuplicateRequest =
  TaskDuplicateRequest
  { taskDuplicateRequestName = Nothing
  , taskDuplicateRequestInclude = Nothing
  }

-- ** TaskRemoveFollowersRequest
-- | TaskRemoveFollowersRequest
data TaskRemoveFollowersRequest = TaskRemoveFollowersRequest
  { taskRemoveFollowersRequestFollowers :: !([Text]) -- ^ /Required/ "followers" - An array of strings identifying users. These can either be the string \&quot;me\&quot;, an email, or the gid of a user.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskRemoveFollowersRequest
instance A.FromJSON TaskRemoveFollowersRequest where
  parseJSON = A.withObject "TaskRemoveFollowersRequest" $ \o ->
    TaskRemoveFollowersRequest
      <$> (o .:  "followers")

-- | ToJSON TaskRemoveFollowersRequest
instance A.ToJSON TaskRemoveFollowersRequest where
  toJSON TaskRemoveFollowersRequest {..} =
   _omitNulls
      [ "followers" .= taskRemoveFollowersRequestFollowers
      ]


-- | Construct a value of type 'TaskRemoveFollowersRequest' (by applying it's required fields, if any)
mkTaskRemoveFollowersRequest
  :: [Text] -- ^ 'taskRemoveFollowersRequestFollowers': An array of strings identifying users. These can either be the string \"me\", an email, or the gid of a user.
  -> TaskRemoveFollowersRequest
mkTaskRemoveFollowersRequest taskRemoveFollowersRequestFollowers =
  TaskRemoveFollowersRequest
  { taskRemoveFollowersRequestFollowers
  }

-- ** TaskRemoveProjectRequest
-- | TaskRemoveProjectRequest
data TaskRemoveProjectRequest = TaskRemoveProjectRequest
  { taskRemoveProjectRequestProject :: !(Text) -- ^ /Required/ "project" - The project to remove the task from.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskRemoveProjectRequest
instance A.FromJSON TaskRemoveProjectRequest where
  parseJSON = A.withObject "TaskRemoveProjectRequest" $ \o ->
    TaskRemoveProjectRequest
      <$> (o .:  "project")

-- | ToJSON TaskRemoveProjectRequest
instance A.ToJSON TaskRemoveProjectRequest where
  toJSON TaskRemoveProjectRequest {..} =
   _omitNulls
      [ "project" .= taskRemoveProjectRequestProject
      ]


-- | Construct a value of type 'TaskRemoveProjectRequest' (by applying it's required fields, if any)
mkTaskRemoveProjectRequest
  :: Text -- ^ 'taskRemoveProjectRequestProject': The project to remove the task from.
  -> TaskRemoveProjectRequest
mkTaskRemoveProjectRequest taskRemoveProjectRequestProject =
  TaskRemoveProjectRequest
  { taskRemoveProjectRequestProject
  }

-- ** TaskRemoveTagRequest
-- | TaskRemoveTagRequest
data TaskRemoveTagRequest = TaskRemoveTagRequest
  { taskRemoveTagRequestTag :: !(Text) -- ^ /Required/ "tag" - The tag to remove from the task.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskRemoveTagRequest
instance A.FromJSON TaskRemoveTagRequest where
  parseJSON = A.withObject "TaskRemoveTagRequest" $ \o ->
    TaskRemoveTagRequest
      <$> (o .:  "tag")

-- | ToJSON TaskRemoveTagRequest
instance A.ToJSON TaskRemoveTagRequest where
  toJSON TaskRemoveTagRequest {..} =
   _omitNulls
      [ "tag" .= taskRemoveTagRequestTag
      ]


-- | Construct a value of type 'TaskRemoveTagRequest' (by applying it's required fields, if any)
mkTaskRemoveTagRequest
  :: Text -- ^ 'taskRemoveTagRequestTag': The tag to remove from the task.
  -> TaskRemoveTagRequest
mkTaskRemoveTagRequest taskRemoveTagRequestTag =
  TaskRemoveTagRequest
  { taskRemoveTagRequestTag
  }

-- ** TaskRequest
-- | TaskRequest
data TaskRequest = TaskRequest
  { taskRequestGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , taskRequestResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , taskRequestName :: !(Maybe Text) -- ^ "name" - Name of the task. This is generally a short sentence fragment that fits on a line in the UI for maximum readability. However, it can be longer.
  , taskRequestApprovalStatus :: !(Maybe E'ApprovalStatus) -- ^ "approval_status" - *Conditional* Reflects the approval status of this task. This field is kept in sync with &#x60;completed&#x60;, meaning &#x60;pending&#x60; translates to false while &#x60;approved&#x60;, &#x60;rejected&#x60;, and &#x60;changes_requested&#x60; translate to true. If you set completed to true, this field will be set to &#x60;approved&#x60;.
  , taskRequestAssigneeStatus :: !(Maybe E'AssigneeStatus) -- ^ "assignee_status" - Scheduling status of this task for the user it is assigned to. This field can only be set if the assignee is non-null. Setting this field to \&quot;inbox\&quot; or \&quot;upcoming\&quot; inserts it at the top of the section, while the other options will insert at the bottom.
  , taskRequestCompleted :: !(Maybe Bool) -- ^ "completed" - True if the task is currently marked complete, false if not.
  , taskRequestCompletedAt :: !(Maybe DateTime) -- ^ "completed_at" - The time at which this task was completed, or null if the task is incomplete.
  , taskRequestCompletedBy :: !(Maybe UserCompact) -- ^ "completed_by"
  , taskRequestCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , taskRequestDependencies :: !(Maybe [AsanaResource]) -- ^ "dependencies" - [Opt In](#input-output-options). Array of resources referencing tasks that this task depends on. The objects contain only the gid of the dependency.
  , taskRequestDependents :: !(Maybe [AsanaResource]) -- ^ "dependents" - [Opt In](#input-output-options). Array of resources referencing tasks that depend on this task. The objects contain only the ID of the dependent.
  , taskRequestDueAt :: !(Maybe Date) -- ^ "due_at" - Date and time on which this task is due, or null if the task has no due time. This takes a UTC timestamp and should not be used together with &#x60;due_on&#x60;.
  , taskRequestDueOn :: !(Maybe Date) -- ^ "due_on" - Date on which this task is due, or null if the task has no due date.  This takes a date with &#x60;YYYY-MM-DD&#x60; format and should not be used together with due_at.
  , taskRequestExternal :: !(Maybe TaskBaseAllOfExternal) -- ^ "external"
  , taskRequestHtmlNotes :: !(Maybe Text) -- ^ "html_notes" - [Opt In](#input-output-options). The notes of the text with formatting as HTML.
  , taskRequestHearted :: !(Maybe Bool) -- ^ "hearted" - *Deprecated - please use liked instead* True if the task is hearted by the authorized user, false if not.
  , taskRequestHearts :: !(Maybe [Like]) -- ^ "hearts" - *Deprecated - please use likes instead* Array of likes for users who have hearted this task.
  , taskRequestIsRenderedAsSeparator :: !(Maybe Bool) -- ^ "is_rendered_as_separator" - [Opt In](#input-output-options). In some contexts tasks can be rendered as a visual separator; for instance, subtasks can appear similar to [sections](#asana-sections) without being true &#x60;section&#x60; objects. If a &#x60;task&#x60; object is rendered this way in any context it will have the property &#x60;is_rendered_as_separator&#x60; set to &#x60;true&#x60;.
  , taskRequestLiked :: !(Maybe Bool) -- ^ "liked" - True if the task is liked by the authorized user, false if not.
  , taskRequestLikes :: !(Maybe [Like]) -- ^ "likes" - Array of likes for users who have liked this task.
  , taskRequestMemberships :: !(Maybe [TaskBaseAllOfMemberships]) -- ^ "memberships" - *Create-only*. Array of projects this task is associated with and the section it is in. At task creation time, this array can be used to add the task to specific sections. After task creation, these associations can be modified using the &#x60;addProject&#x60; and &#x60;removeProject&#x60; endpoints. Note that over time, more types of memberships may be added to this property.
  , taskRequestModifiedAt :: !(Maybe DateTime) -- ^ "modified_at" - The time at which this task was last modified.  *Note: This does not currently reflect any changes in associations such as projects or comments that may have been added or removed from the task.*
  , taskRequestNotes :: !(Maybe Text) -- ^ "notes" - More detailed, free-form textual information associated with the task.
  , taskRequestNumHearts :: !(Maybe Int) -- ^ "num_hearts" - *Deprecated - please use likes instead* The number of users who have hearted this task.
  , taskRequestNumLikes :: !(Maybe Int) -- ^ "num_likes" - The number of users who have liked this task.
  , taskRequestNumSubtasks :: !(Maybe Int) -- ^ "num_subtasks" - [Opt In](#input-output-options). The number of subtasks on this task. 
  , taskRequestResourceSubtype :: !(Maybe E'ResourceSubtype2) -- ^ "resource_subtype" - The subtype of this resource. Different subtypes retain many of the same fields and behavior, but may render differently in Asana or represent resources with different semantic meaning. The resource_subtype &#x60;milestone&#x60; represent a single moment in time. This means tasks with this subtype cannot have a start_date.
  , taskRequestStartOn :: !(Maybe Date) -- ^ "start_on" - The day on which work begins for the task , or null if the task has no start date. This takes a date with &#x60;YYYY-MM-DD&#x60; format. *Note: &#x60;due_on&#x60; or &#x60;due_at&#x60; must be present in the request when setting or unsetting the &#x60;start_on&#x60; parameter.*
  , taskRequestAssignee :: !(Maybe Text) -- ^ "assignee" - Gid of a user.
  , taskRequestCustomFields :: !(Maybe (Map.Map String Text)) -- ^ "custom_fields" - An object where each key is a Custom Field gid and each value is an enum gid, string, or number.
  , taskRequestFollowers :: !(Maybe [Text]) -- ^ "followers" - *Create-Only* An array of strings identifying users. These can either be the string \&quot;me\&quot;, an email, or the gid of a user. In order to change followers on an existing task use &#x60;addFollowers&#x60; and &#x60;removeFollowers&#x60;.
  , taskRequestParent :: !(Maybe Text) -- ^ "parent" - Gid of a task.
  , taskRequestProjects :: !(Maybe [Text]) -- ^ "projects" - *Create-Only* Array of project gids. In order to change projects on an existing task use &#x60;addProject&#x60; and &#x60;removeProject&#x60;.
  , taskRequestTags :: !(Maybe [Text]) -- ^ "tags" - *Create-Only* Array of tag gids. In order to change tags on an existing task use &#x60;addTag&#x60; and &#x60;removeTag&#x60;.
  , taskRequestWorkspace :: !(Maybe Text) -- ^ "workspace" - Gid of a workspace.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskRequest
instance A.FromJSON TaskRequest where
  parseJSON = A.withObject "TaskRequest" $ \o ->
    TaskRequest
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "approval_status")
      <*> (o .:? "assignee_status")
      <*> (o .:? "completed")
      <*> (o .:? "completed_at")
      <*> (o .:? "completed_by")
      <*> (o .:? "created_at")
      <*> (o .:? "dependencies")
      <*> (o .:? "dependents")
      <*> (o .:? "due_at")
      <*> (o .:? "due_on")
      <*> (o .:? "external")
      <*> (o .:? "html_notes")
      <*> (o .:? "hearted")
      <*> (o .:? "hearts")
      <*> (o .:? "is_rendered_as_separator")
      <*> (o .:? "liked")
      <*> (o .:? "likes")
      <*> (o .:? "memberships")
      <*> (o .:? "modified_at")
      <*> (o .:? "notes")
      <*> (o .:? "num_hearts")
      <*> (o .:? "num_likes")
      <*> (o .:? "num_subtasks")
      <*> (o .:? "resource_subtype")
      <*> (o .:? "start_on")
      <*> (o .:? "assignee")
      <*> (o .:? "custom_fields")
      <*> (o .:? "followers")
      <*> (o .:? "parent")
      <*> (o .:? "projects")
      <*> (o .:? "tags")
      <*> (o .:? "workspace")

-- | ToJSON TaskRequest
instance A.ToJSON TaskRequest where
  toJSON TaskRequest {..} =
   _omitNulls
      [ "gid" .= taskRequestGid
      , "resource_type" .= taskRequestResourceType
      , "name" .= taskRequestName
      , "approval_status" .= taskRequestApprovalStatus
      , "assignee_status" .= taskRequestAssigneeStatus
      , "completed" .= taskRequestCompleted
      , "completed_at" .= taskRequestCompletedAt
      , "completed_by" .= taskRequestCompletedBy
      , "created_at" .= taskRequestCreatedAt
      , "dependencies" .= taskRequestDependencies
      , "dependents" .= taskRequestDependents
      , "due_at" .= taskRequestDueAt
      , "due_on" .= taskRequestDueOn
      , "external" .= taskRequestExternal
      , "html_notes" .= taskRequestHtmlNotes
      , "hearted" .= taskRequestHearted
      , "hearts" .= taskRequestHearts
      , "is_rendered_as_separator" .= taskRequestIsRenderedAsSeparator
      , "liked" .= taskRequestLiked
      , "likes" .= taskRequestLikes
      , "memberships" .= taskRequestMemberships
      , "modified_at" .= taskRequestModifiedAt
      , "notes" .= taskRequestNotes
      , "num_hearts" .= taskRequestNumHearts
      , "num_likes" .= taskRequestNumLikes
      , "num_subtasks" .= taskRequestNumSubtasks
      , "resource_subtype" .= taskRequestResourceSubtype
      , "start_on" .= taskRequestStartOn
      , "assignee" .= taskRequestAssignee
      , "custom_fields" .= taskRequestCustomFields
      , "followers" .= taskRequestFollowers
      , "parent" .= taskRequestParent
      , "projects" .= taskRequestProjects
      , "tags" .= taskRequestTags
      , "workspace" .= taskRequestWorkspace
      ]


-- | Construct a value of type 'TaskRequest' (by applying it's required fields, if any)
mkTaskRequest
  :: TaskRequest
mkTaskRequest =
  TaskRequest
  { taskRequestGid = Nothing
  , taskRequestResourceType = Nothing
  , taskRequestName = Nothing
  , taskRequestApprovalStatus = Nothing
  , taskRequestAssigneeStatus = Nothing
  , taskRequestCompleted = Nothing
  , taskRequestCompletedAt = Nothing
  , taskRequestCompletedBy = Nothing
  , taskRequestCreatedAt = Nothing
  , taskRequestDependencies = Nothing
  , taskRequestDependents = Nothing
  , taskRequestDueAt = Nothing
  , taskRequestDueOn = Nothing
  , taskRequestExternal = Nothing
  , taskRequestHtmlNotes = Nothing
  , taskRequestHearted = Nothing
  , taskRequestHearts = Nothing
  , taskRequestIsRenderedAsSeparator = Nothing
  , taskRequestLiked = Nothing
  , taskRequestLikes = Nothing
  , taskRequestMemberships = Nothing
  , taskRequestModifiedAt = Nothing
  , taskRequestNotes = Nothing
  , taskRequestNumHearts = Nothing
  , taskRequestNumLikes = Nothing
  , taskRequestNumSubtasks = Nothing
  , taskRequestResourceSubtype = Nothing
  , taskRequestStartOn = Nothing
  , taskRequestAssignee = Nothing
  , taskRequestCustomFields = Nothing
  , taskRequestFollowers = Nothing
  , taskRequestParent = Nothing
  , taskRequestProjects = Nothing
  , taskRequestTags = Nothing
  , taskRequestWorkspace = Nothing
  }

-- ** TaskRequestAllOf
-- | TaskRequestAllOf
data TaskRequestAllOf = TaskRequestAllOf
  { taskRequestAllOfAssignee :: !(Maybe Text) -- ^ "assignee" - Gid of a user.
  , taskRequestAllOfCustomFields :: !(Maybe (Map.Map String Text)) -- ^ "custom_fields" - An object where each key is a Custom Field gid and each value is an enum gid, string, or number.
  , taskRequestAllOfFollowers :: !(Maybe [Text]) -- ^ "followers" - *Create-Only* An array of strings identifying users. These can either be the string \&quot;me\&quot;, an email, or the gid of a user. In order to change followers on an existing task use &#x60;addFollowers&#x60; and &#x60;removeFollowers&#x60;.
  , taskRequestAllOfParent :: !(Maybe Text) -- ^ "parent" - Gid of a task.
  , taskRequestAllOfProjects :: !(Maybe [Text]) -- ^ "projects" - *Create-Only* Array of project gids. In order to change projects on an existing task use &#x60;addProject&#x60; and &#x60;removeProject&#x60;.
  , taskRequestAllOfTags :: !(Maybe [Text]) -- ^ "tags" - *Create-Only* Array of tag gids. In order to change tags on an existing task use &#x60;addTag&#x60; and &#x60;removeTag&#x60;.
  , taskRequestAllOfWorkspace :: !(Maybe Text) -- ^ "workspace" - Gid of a workspace.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskRequestAllOf
instance A.FromJSON TaskRequestAllOf where
  parseJSON = A.withObject "TaskRequestAllOf" $ \o ->
    TaskRequestAllOf
      <$> (o .:? "assignee")
      <*> (o .:? "custom_fields")
      <*> (o .:? "followers")
      <*> (o .:? "parent")
      <*> (o .:? "projects")
      <*> (o .:? "tags")
      <*> (o .:? "workspace")

-- | ToJSON TaskRequestAllOf
instance A.ToJSON TaskRequestAllOf where
  toJSON TaskRequestAllOf {..} =
   _omitNulls
      [ "assignee" .= taskRequestAllOfAssignee
      , "custom_fields" .= taskRequestAllOfCustomFields
      , "followers" .= taskRequestAllOfFollowers
      , "parent" .= taskRequestAllOfParent
      , "projects" .= taskRequestAllOfProjects
      , "tags" .= taskRequestAllOfTags
      , "workspace" .= taskRequestAllOfWorkspace
      ]


-- | Construct a value of type 'TaskRequestAllOf' (by applying it's required fields, if any)
mkTaskRequestAllOf
  :: TaskRequestAllOf
mkTaskRequestAllOf =
  TaskRequestAllOf
  { taskRequestAllOfAssignee = Nothing
  , taskRequestAllOfCustomFields = Nothing
  , taskRequestAllOfFollowers = Nothing
  , taskRequestAllOfParent = Nothing
  , taskRequestAllOfProjects = Nothing
  , taskRequestAllOfTags = Nothing
  , taskRequestAllOfWorkspace = Nothing
  }

-- ** TaskResponse
-- | TaskResponse
data TaskResponse = TaskResponse
  { taskResponseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , taskResponseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , taskResponseName :: !(Maybe Text) -- ^ "name" - Name of the task. This is generally a short sentence fragment that fits on a line in the UI for maximum readability. However, it can be longer.
  , taskResponseApprovalStatus :: !(Maybe E'ApprovalStatus) -- ^ "approval_status" - *Conditional* Reflects the approval status of this task. This field is kept in sync with &#x60;completed&#x60;, meaning &#x60;pending&#x60; translates to false while &#x60;approved&#x60;, &#x60;rejected&#x60;, and &#x60;changes_requested&#x60; translate to true. If you set completed to true, this field will be set to &#x60;approved&#x60;.
  , taskResponseAssigneeStatus :: !(Maybe E'AssigneeStatus) -- ^ "assignee_status" - Scheduling status of this task for the user it is assigned to. This field can only be set if the assignee is non-null. Setting this field to \&quot;inbox\&quot; or \&quot;upcoming\&quot; inserts it at the top of the section, while the other options will insert at the bottom.
  , taskResponseCompleted :: !(Maybe Bool) -- ^ "completed" - True if the task is currently marked complete, false if not.
  , taskResponseCompletedAt :: !(Maybe DateTime) -- ^ "completed_at" - The time at which this task was completed, or null if the task is incomplete.
  , taskResponseCompletedBy :: !(Maybe UserCompact) -- ^ "completed_by"
  , taskResponseCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , taskResponseDependencies :: !(Maybe [AsanaResource]) -- ^ "dependencies" - [Opt In](#input-output-options). Array of resources referencing tasks that this task depends on. The objects contain only the gid of the dependency.
  , taskResponseDependents :: !(Maybe [AsanaResource]) -- ^ "dependents" - [Opt In](#input-output-options). Array of resources referencing tasks that depend on this task. The objects contain only the ID of the dependent.
  , taskResponseDueAt :: !(Maybe DateTime) -- ^ "due_at" - Date and time on which this task is due, or null if the task has no due time. This takes a UTC timestamp and should not be used together with &#x60;due_on&#x60;.
  , taskResponseDueOn :: !(Maybe Date) -- ^ "due_on" - Date on which this task is due, or null if the task has no due date.  This takes a date with &#x60;YYYY-MM-DD&#x60; format and should not be used together with due_at.
  , taskResponseExternal :: !(Maybe TaskBaseAllOfExternal) -- ^ "external"
  , taskResponseHtmlNotes :: !(Maybe Text) -- ^ "html_notes" - [Opt In](#input-output-options). The notes of the text with formatting as HTML.
  , taskResponseHearted :: !(Maybe Bool) -- ^ "hearted" - *Deprecated - please use liked instead* True if the task is hearted by the authorized user, false if not.
  , taskResponseHearts :: !(Maybe [Like]) -- ^ "hearts" - *Deprecated - please use likes instead* Array of likes for users who have hearted this task.
  , taskResponseIsRenderedAsSeparator :: !(Maybe Bool) -- ^ "is_rendered_as_separator" - [Opt In](#input-output-options). In some contexts tasks can be rendered as a visual separator; for instance, subtasks can appear similar to [sections](#asana-sections) without being true &#x60;section&#x60; objects. If a &#x60;task&#x60; object is rendered this way in any context it will have the property &#x60;is_rendered_as_separator&#x60; set to &#x60;true&#x60;.
  , taskResponseLiked :: !(Maybe Bool) -- ^ "liked" - True if the task is liked by the authorized user, false if not.
  , taskResponseLikes :: !(Maybe [Like]) -- ^ "likes" - Array of likes for users who have liked this task.
  , taskResponseMemberships :: !(Maybe [TaskBaseAllOfMemberships]) -- ^ "memberships" - *Create-only*. Array of projects this task is associated with and the section it is in. At task creation time, this array can be used to add the task to specific sections. After task creation, these associations can be modified using the &#x60;addProject&#x60; and &#x60;removeProject&#x60; endpoints. Note that over time, more types of memberships may be added to this property.
  , taskResponseModifiedAt :: !(Maybe DateTime) -- ^ "modified_at" - The time at which this task was last modified.  *Note: This does not currently reflect any changes in associations such as projects or comments that may have been added or removed from the task.*
  , taskResponseNotes :: !(Maybe Text) -- ^ "notes" - More detailed, free-form textual information associated with the task.
  , taskResponseNumHearts :: !(Maybe Int) -- ^ "num_hearts" - *Deprecated - please use likes instead* The number of users who have hearted this task.
  , taskResponseNumLikes :: !(Maybe Int) -- ^ "num_likes" - The number of users who have liked this task.
  , taskResponseNumSubtasks :: !(Maybe Int) -- ^ "num_subtasks" - [Opt In](#input-output-options). The number of subtasks on this task. 
  , taskResponseResourceSubtype :: !(Maybe E'ResourceSubtype2) -- ^ "resource_subtype" - The subtype of this resource. Different subtypes retain many of the same fields and behavior, but may render differently in Asana or represent resources with different semantic meaning. The resource_subtype &#x60;milestone&#x60; represent a single moment in time. This means tasks with this subtype cannot have a start_date.
  , taskResponseStartOn :: !(Maybe Date) -- ^ "start_on" - The day on which work begins for the task , or null if the task has no start date. This takes a date with &#x60;YYYY-MM-DD&#x60; format. *Note: &#x60;due_on&#x60; or &#x60;due_at&#x60; must be present in the request when setting or unsetting the &#x60;start_on&#x60; parameter.*
  , taskResponseAssignee :: !(Maybe UserCompact) -- ^ "assignee"
  , taskResponseCustomFields :: !(Maybe [CustomFieldResponse]) -- ^ "custom_fields" - Array of custom field values applied to the task. These represent the custom field values recorded on this project for a particular custom field. For example, these custom field values will contain an &#x60;enum_value&#x60; property for custom fields of type &#x60;enum&#x60;, a &#x60;text_value&#x60; property for custom fields of type &#x60;text&#x60;, and so on. Please note that the &#x60;gid&#x60; returned on each custom field value *is identical* to the &#x60;gid&#x60; of the custom field, which allows referencing the custom field metadata through the &#x60;/custom_fields/custom_field-gid&#x60; endpoint.
  , taskResponseFollowers :: !(Maybe [UserCompact]) -- ^ "followers" - Array of users following this task.
  , taskResponseParent :: !(Maybe TaskCompact) -- ^ "parent"
  , taskResponseProjects :: !(Maybe [ProjectCompact]) -- ^ "projects" - *Create-only.* Array of projects this task is associated with. At task creation time, this array can be used to add the task to many projects at once. After task creation, these associations can be modified using the addProject and removeProject endpoints.
  , taskResponseTags :: !(Maybe [TagCompact]) -- ^ "tags" - Array of tags associated with this task. In order to change tags on an existing task use &#x60;addTag&#x60; and &#x60;removeTag&#x60;.
  , taskResponseWorkspace :: !(Maybe WorkspaceCompact) -- ^ "workspace"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskResponse
instance A.FromJSON TaskResponse where
  parseJSON = A.withObject "TaskResponse" $ \o ->
    TaskResponse
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "approval_status")
      <*> (o .:? "assignee_status")
      <*> (o .:? "completed")
      <*> (o .:? "completed_at")
      <*> (o .:? "completed_by")
      <*> (o .:? "created_at")
      <*> (o .:? "dependencies")
      <*> (o .:? "dependents")
      <*> (o .:? "due_at")
      <*> (o .:? "due_on")
      <*> (o .:? "external")
      <*> (o .:? "html_notes")
      <*> (o .:? "hearted")
      <*> (o .:? "hearts")
      <*> (o .:? "is_rendered_as_separator")
      <*> (o .:? "liked")
      <*> (o .:? "likes")
      <*> (o .:? "memberships")
      <*> (o .:? "modified_at")
      <*> (o .:? "notes")
      <*> (o .:? "num_hearts")
      <*> (o .:? "num_likes")
      <*> (o .:? "num_subtasks")
      <*> (o .:? "resource_subtype")
      <*> (o .:? "start_on")
      <*> (o .:? "assignee")
      <*> (o .:? "custom_fields")
      <*> (o .:? "followers")
      <*> (o .:? "parent")
      <*> (o .:? "projects")
      <*> (o .:? "tags")
      <*> (o .:? "workspace")

-- | ToJSON TaskResponse
instance A.ToJSON TaskResponse where
  toJSON TaskResponse {..} =
   _omitNulls
      [ "gid" .= taskResponseGid
      , "resource_type" .= taskResponseResourceType
      , "name" .= taskResponseName
      , "approval_status" .= taskResponseApprovalStatus
      , "assignee_status" .= taskResponseAssigneeStatus
      , "completed" .= taskResponseCompleted
      , "completed_at" .= taskResponseCompletedAt
      , "completed_by" .= taskResponseCompletedBy
      , "created_at" .= taskResponseCreatedAt
      , "dependencies" .= taskResponseDependencies
      , "dependents" .= taskResponseDependents
      , "due_at" .= taskResponseDueAt
      , "due_on" .= taskResponseDueOn
      , "external" .= taskResponseExternal
      , "html_notes" .= taskResponseHtmlNotes
      , "hearted" .= taskResponseHearted
      , "hearts" .= taskResponseHearts
      , "is_rendered_as_separator" .= taskResponseIsRenderedAsSeparator
      , "liked" .= taskResponseLiked
      , "likes" .= taskResponseLikes
      , "memberships" .= taskResponseMemberships
      , "modified_at" .= taskResponseModifiedAt
      , "notes" .= taskResponseNotes
      , "num_hearts" .= taskResponseNumHearts
      , "num_likes" .= taskResponseNumLikes
      , "num_subtasks" .= taskResponseNumSubtasks
      , "resource_subtype" .= taskResponseResourceSubtype
      , "start_on" .= taskResponseStartOn
      , "assignee" .= taskResponseAssignee
      , "custom_fields" .= taskResponseCustomFields
      , "followers" .= taskResponseFollowers
      , "parent" .= taskResponseParent
      , "projects" .= taskResponseProjects
      , "tags" .= taskResponseTags
      , "workspace" .= taskResponseWorkspace
      ]


-- | Construct a value of type 'TaskResponse' (by applying it's required fields, if any)
mkTaskResponse
  :: TaskResponse
mkTaskResponse =
  TaskResponse
  { taskResponseGid = Nothing
  , taskResponseResourceType = Nothing
  , taskResponseName = Nothing
  , taskResponseApprovalStatus = Nothing
  , taskResponseAssigneeStatus = Nothing
  , taskResponseCompleted = Nothing
  , taskResponseCompletedAt = Nothing
  , taskResponseCompletedBy = Nothing
  , taskResponseCreatedAt = Nothing
  , taskResponseDependencies = Nothing
  , taskResponseDependents = Nothing
  , taskResponseDueAt = Nothing
  , taskResponseDueOn = Nothing
  , taskResponseExternal = Nothing
  , taskResponseHtmlNotes = Nothing
  , taskResponseHearted = Nothing
  , taskResponseHearts = Nothing
  , taskResponseIsRenderedAsSeparator = Nothing
  , taskResponseLiked = Nothing
  , taskResponseLikes = Nothing
  , taskResponseMemberships = Nothing
  , taskResponseModifiedAt = Nothing
  , taskResponseNotes = Nothing
  , taskResponseNumHearts = Nothing
  , taskResponseNumLikes = Nothing
  , taskResponseNumSubtasks = Nothing
  , taskResponseResourceSubtype = Nothing
  , taskResponseStartOn = Nothing
  , taskResponseAssignee = Nothing
  , taskResponseCustomFields = Nothing
  , taskResponseFollowers = Nothing
  , taskResponseParent = Nothing
  , taskResponseProjects = Nothing
  , taskResponseTags = Nothing
  , taskResponseWorkspace = Nothing
  }

-- ** TaskResponseAllOf
-- | TaskResponseAllOf
data TaskResponseAllOf = TaskResponseAllOf
  { taskResponseAllOfAssignee :: !(Maybe UserCompact) -- ^ "assignee"
  , taskResponseAllOfCustomFields :: !(Maybe [CustomFieldResponse]) -- ^ "custom_fields" - Array of custom field values applied to the task. These represent the custom field values recorded on this project for a particular custom field. For example, these custom field values will contain an &#x60;enum_value&#x60; property for custom fields of type &#x60;enum&#x60;, a &#x60;text_value&#x60; property for custom fields of type &#x60;text&#x60;, and so on. Please note that the &#x60;gid&#x60; returned on each custom field value *is identical* to the &#x60;gid&#x60; of the custom field, which allows referencing the custom field metadata through the &#x60;/custom_fields/custom_field-gid&#x60; endpoint.
  , taskResponseAllOfFollowers :: !(Maybe [UserCompact]) -- ^ "followers" - Array of users following this task.
  , taskResponseAllOfParent :: !(Maybe TaskCompact) -- ^ "parent"
  , taskResponseAllOfProjects :: !(Maybe [ProjectCompact]) -- ^ "projects" - *Create-only.* Array of projects this task is associated with. At task creation time, this array can be used to add the task to many projects at once. After task creation, these associations can be modified using the addProject and removeProject endpoints.
  , taskResponseAllOfTags :: !(Maybe [TagCompact]) -- ^ "tags" - Array of tags associated with this task. In order to change tags on an existing task use &#x60;addTag&#x60; and &#x60;removeTag&#x60;.
  , taskResponseAllOfWorkspace :: !(Maybe WorkspaceCompact) -- ^ "workspace"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskResponseAllOf
instance A.FromJSON TaskResponseAllOf where
  parseJSON = A.withObject "TaskResponseAllOf" $ \o ->
    TaskResponseAllOf
      <$> (o .:? "assignee")
      <*> (o .:? "custom_fields")
      <*> (o .:? "followers")
      <*> (o .:? "parent")
      <*> (o .:? "projects")
      <*> (o .:? "tags")
      <*> (o .:? "workspace")

-- | ToJSON TaskResponseAllOf
instance A.ToJSON TaskResponseAllOf where
  toJSON TaskResponseAllOf {..} =
   _omitNulls
      [ "assignee" .= taskResponseAllOfAssignee
      , "custom_fields" .= taskResponseAllOfCustomFields
      , "followers" .= taskResponseAllOfFollowers
      , "parent" .= taskResponseAllOfParent
      , "projects" .= taskResponseAllOfProjects
      , "tags" .= taskResponseAllOfTags
      , "workspace" .= taskResponseAllOfWorkspace
      ]


-- | Construct a value of type 'TaskResponseAllOf' (by applying it's required fields, if any)
mkTaskResponseAllOf
  :: TaskResponseAllOf
mkTaskResponseAllOf =
  TaskResponseAllOf
  { taskResponseAllOfAssignee = Nothing
  , taskResponseAllOfCustomFields = Nothing
  , taskResponseAllOfFollowers = Nothing
  , taskResponseAllOfParent = Nothing
  , taskResponseAllOfProjects = Nothing
  , taskResponseAllOfTags = Nothing
  , taskResponseAllOfWorkspace = Nothing
  }

-- ** TaskSetParentRequest
-- | TaskSetParentRequest
data TaskSetParentRequest = TaskSetParentRequest
  { taskSetParentRequestParent :: !(Text) -- ^ /Required/ "parent" - The new parent of the task, or &#x60;null&#x60; for no parent.
  , taskSetParentRequestInsertAfter :: !(Maybe Text) -- ^ "insert_after" - A subtask of the parent to insert the task after, or &#x60;null&#x60; to insert at the beginning of the list.
  , taskSetParentRequestInsertBefore :: !(Maybe Text) -- ^ "insert_before" - A subtask of the parent to insert the task before, or &#x60;null&#x60; to insert at the end of the list.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSetParentRequest
instance A.FromJSON TaskSetParentRequest where
  parseJSON = A.withObject "TaskSetParentRequest" $ \o ->
    TaskSetParentRequest
      <$> (o .:  "parent")
      <*> (o .:? "insert_after")
      <*> (o .:? "insert_before")

-- | ToJSON TaskSetParentRequest
instance A.ToJSON TaskSetParentRequest where
  toJSON TaskSetParentRequest {..} =
   _omitNulls
      [ "parent" .= taskSetParentRequestParent
      , "insert_after" .= taskSetParentRequestInsertAfter
      , "insert_before" .= taskSetParentRequestInsertBefore
      ]


-- | Construct a value of type 'TaskSetParentRequest' (by applying it's required fields, if any)
mkTaskSetParentRequest
  :: Text -- ^ 'taskSetParentRequestParent': The new parent of the task, or `null` for no parent.
  -> TaskSetParentRequest
mkTaskSetParentRequest taskSetParentRequestParent =
  TaskSetParentRequest
  { taskSetParentRequestParent
  , taskSetParentRequestInsertAfter = Nothing
  , taskSetParentRequestInsertBefore = Nothing
  }

-- ** TeamAddUserRequest
-- | TeamAddUserRequest
-- A user identification object for specification with the addUser/removeUser endpoints.
data TeamAddUserRequest = TeamAddUserRequest
  { teamAddUserRequestUser :: !(Maybe Text) -- ^ "user" - A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TeamAddUserRequest
instance A.FromJSON TeamAddUserRequest where
  parseJSON = A.withObject "TeamAddUserRequest" $ \o ->
    TeamAddUserRequest
      <$> (o .:? "user")

-- | ToJSON TeamAddUserRequest
instance A.ToJSON TeamAddUserRequest where
  toJSON TeamAddUserRequest {..} =
   _omitNulls
      [ "user" .= teamAddUserRequestUser
      ]


-- | Construct a value of type 'TeamAddUserRequest' (by applying it's required fields, if any)
mkTeamAddUserRequest
  :: TeamAddUserRequest
mkTeamAddUserRequest =
  TeamAddUserRequest
  { teamAddUserRequestUser = Nothing
  }

-- ** TeamBase
-- | TeamBase
data TeamBase = TeamBase
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TeamBase
instance A.FromJSON TeamBase where
  parseJSON = A.withObject "TeamBase" $ \o ->
    pure TeamBase
      

-- | ToJSON TeamBase
instance A.ToJSON TeamBase where
  toJSON TeamBase  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'TeamBase' (by applying it's required fields, if any)
mkTeamBase
  :: TeamBase
mkTeamBase =
  TeamBase
  { 
  }

-- ** TeamCompact
-- | TeamCompact
data TeamCompact = TeamCompact
  { teamCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , teamCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , teamCompactName :: !(Maybe Text) -- ^ "name" - The name of the team.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TeamCompact
instance A.FromJSON TeamCompact where
  parseJSON = A.withObject "TeamCompact" $ \o ->
    TeamCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")

-- | ToJSON TeamCompact
instance A.ToJSON TeamCompact where
  toJSON TeamCompact {..} =
   _omitNulls
      [ "gid" .= teamCompactGid
      , "resource_type" .= teamCompactResourceType
      , "name" .= teamCompactName
      ]


-- | Construct a value of type 'TeamCompact' (by applying it's required fields, if any)
mkTeamCompact
  :: TeamCompact
mkTeamCompact =
  TeamCompact
  { teamCompactGid = Nothing
  , teamCompactResourceType = Nothing
  , teamCompactName = Nothing
  }

-- ** TeamCompactAllOf
-- | TeamCompactAllOf
-- A *team* is used to group related projects and people together within an organization. Each project in an organization is associated with a team.
data TeamCompactAllOf = TeamCompactAllOf
  { teamCompactAllOfName :: !(Maybe Text) -- ^ "name" - The name of the team.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TeamCompactAllOf
instance A.FromJSON TeamCompactAllOf where
  parseJSON = A.withObject "TeamCompactAllOf" $ \o ->
    TeamCompactAllOf
      <$> (o .:? "name")

-- | ToJSON TeamCompactAllOf
instance A.ToJSON TeamCompactAllOf where
  toJSON TeamCompactAllOf {..} =
   _omitNulls
      [ "name" .= teamCompactAllOfName
      ]


-- | Construct a value of type 'TeamCompactAllOf' (by applying it's required fields, if any)
mkTeamCompactAllOf
  :: TeamCompactAllOf
mkTeamCompactAllOf =
  TeamCompactAllOf
  { teamCompactAllOfName = Nothing
  }

-- ** TeamMembershipBase
-- | TeamMembershipBase
data TeamMembershipBase = TeamMembershipBase
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TeamMembershipBase
instance A.FromJSON TeamMembershipBase where
  parseJSON = A.withObject "TeamMembershipBase" $ \o ->
    pure TeamMembershipBase
      

-- | ToJSON TeamMembershipBase
instance A.ToJSON TeamMembershipBase where
  toJSON TeamMembershipBase  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'TeamMembershipBase' (by applying it's required fields, if any)
mkTeamMembershipBase
  :: TeamMembershipBase
mkTeamMembershipBase =
  TeamMembershipBase
  { 
  }

-- ** TeamMembershipCompact
-- | TeamMembershipCompact
data TeamMembershipCompact = TeamMembershipCompact
  { teamMembershipCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , teamMembershipCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , teamMembershipCompactUser :: !(Maybe UserCompact) -- ^ "user"
  , teamMembershipCompactTeam :: !(Maybe TeamCompact) -- ^ "team"
  , teamMembershipCompactIsGuest :: !(Maybe Bool) -- ^ "is_guest" - Describes if the user is a guest in the team.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TeamMembershipCompact
instance A.FromJSON TeamMembershipCompact where
  parseJSON = A.withObject "TeamMembershipCompact" $ \o ->
    TeamMembershipCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "user")
      <*> (o .:? "team")
      <*> (o .:? "is_guest")

-- | ToJSON TeamMembershipCompact
instance A.ToJSON TeamMembershipCompact where
  toJSON TeamMembershipCompact {..} =
   _omitNulls
      [ "gid" .= teamMembershipCompactGid
      , "resource_type" .= teamMembershipCompactResourceType
      , "user" .= teamMembershipCompactUser
      , "team" .= teamMembershipCompactTeam
      , "is_guest" .= teamMembershipCompactIsGuest
      ]


-- | Construct a value of type 'TeamMembershipCompact' (by applying it's required fields, if any)
mkTeamMembershipCompact
  :: TeamMembershipCompact
mkTeamMembershipCompact =
  TeamMembershipCompact
  { teamMembershipCompactGid = Nothing
  , teamMembershipCompactResourceType = Nothing
  , teamMembershipCompactUser = Nothing
  , teamMembershipCompactTeam = Nothing
  , teamMembershipCompactIsGuest = Nothing
  }

-- ** TeamMembershipCompactAllOf
-- | TeamMembershipCompactAllOf
-- This object represents a user's connection to a team.
data TeamMembershipCompactAllOf = TeamMembershipCompactAllOf
  { teamMembershipCompactAllOfUser :: !(Maybe UserCompact) -- ^ "user"
  , teamMembershipCompactAllOfTeam :: !(Maybe TeamCompact) -- ^ "team"
  , teamMembershipCompactAllOfIsGuest :: !(Maybe Bool) -- ^ "is_guest" - Describes if the user is a guest in the team.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TeamMembershipCompactAllOf
instance A.FromJSON TeamMembershipCompactAllOf where
  parseJSON = A.withObject "TeamMembershipCompactAllOf" $ \o ->
    TeamMembershipCompactAllOf
      <$> (o .:? "user")
      <*> (o .:? "team")
      <*> (o .:? "is_guest")

-- | ToJSON TeamMembershipCompactAllOf
instance A.ToJSON TeamMembershipCompactAllOf where
  toJSON TeamMembershipCompactAllOf {..} =
   _omitNulls
      [ "user" .= teamMembershipCompactAllOfUser
      , "team" .= teamMembershipCompactAllOfTeam
      , "is_guest" .= teamMembershipCompactAllOfIsGuest
      ]


-- | Construct a value of type 'TeamMembershipCompactAllOf' (by applying it's required fields, if any)
mkTeamMembershipCompactAllOf
  :: TeamMembershipCompactAllOf
mkTeamMembershipCompactAllOf =
  TeamMembershipCompactAllOf
  { teamMembershipCompactAllOfUser = Nothing
  , teamMembershipCompactAllOfTeam = Nothing
  , teamMembershipCompactAllOfIsGuest = Nothing
  }

-- ** TeamMembershipResponse
-- | TeamMembershipResponse
data TeamMembershipResponse = TeamMembershipResponse
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TeamMembershipResponse
instance A.FromJSON TeamMembershipResponse where
  parseJSON = A.withObject "TeamMembershipResponse" $ \o ->
    pure TeamMembershipResponse
      

-- | ToJSON TeamMembershipResponse
instance A.ToJSON TeamMembershipResponse where
  toJSON TeamMembershipResponse  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'TeamMembershipResponse' (by applying it's required fields, if any)
mkTeamMembershipResponse
  :: TeamMembershipResponse
mkTeamMembershipResponse =
  TeamMembershipResponse
  { 
  }

-- ** TeamRemoveUserRequest
-- | TeamRemoveUserRequest
-- A user identification object for specification with the addUser/removeUser endpoints.
data TeamRemoveUserRequest = TeamRemoveUserRequest
  { teamRemoveUserRequestUser :: !(Maybe Text) -- ^ "user" - A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TeamRemoveUserRequest
instance A.FromJSON TeamRemoveUserRequest where
  parseJSON = A.withObject "TeamRemoveUserRequest" $ \o ->
    TeamRemoveUserRequest
      <$> (o .:? "user")

-- | ToJSON TeamRemoveUserRequest
instance A.ToJSON TeamRemoveUserRequest where
  toJSON TeamRemoveUserRequest {..} =
   _omitNulls
      [ "user" .= teamRemoveUserRequestUser
      ]


-- | Construct a value of type 'TeamRemoveUserRequest' (by applying it's required fields, if any)
mkTeamRemoveUserRequest
  :: TeamRemoveUserRequest
mkTeamRemoveUserRequest =
  TeamRemoveUserRequest
  { teamRemoveUserRequestUser = Nothing
  }

-- ** TeamRequest
-- | TeamRequest
data TeamRequest = TeamRequest
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TeamRequest
instance A.FromJSON TeamRequest where
  parseJSON = A.withObject "TeamRequest" $ \o ->
    pure TeamRequest
      

-- | ToJSON TeamRequest
instance A.ToJSON TeamRequest where
  toJSON TeamRequest  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'TeamRequest' (by applying it's required fields, if any)
mkTeamRequest
  :: TeamRequest
mkTeamRequest =
  TeamRequest
  { 
  }

-- ** TeamResponse
-- | TeamResponse
data TeamResponse = TeamResponse
  { teamResponseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , teamResponseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , teamResponseName :: !(Maybe Text) -- ^ "name" - The name of the team.
  , teamResponseDescription :: !(Maybe Text) -- ^ "description" - [Opt In](#input-output-options). The description of the team. 
  , teamResponseHtmlDescription :: !(Maybe Text) -- ^ "html_description" - [Opt In](#input-output-options). The description of the team with formatting as HTML. 
  , teamResponseOrganization :: !(Maybe WorkspaceCompact) -- ^ "organization"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TeamResponse
instance A.FromJSON TeamResponse where
  parseJSON = A.withObject "TeamResponse" $ \o ->
    TeamResponse
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "description")
      <*> (o .:? "html_description")
      <*> (o .:? "organization")

-- | ToJSON TeamResponse
instance A.ToJSON TeamResponse where
  toJSON TeamResponse {..} =
   _omitNulls
      [ "gid" .= teamResponseGid
      , "resource_type" .= teamResponseResourceType
      , "name" .= teamResponseName
      , "description" .= teamResponseDescription
      , "html_description" .= teamResponseHtmlDescription
      , "organization" .= teamResponseOrganization
      ]


-- | Construct a value of type 'TeamResponse' (by applying it's required fields, if any)
mkTeamResponse
  :: TeamResponse
mkTeamResponse =
  TeamResponse
  { teamResponseGid = Nothing
  , teamResponseResourceType = Nothing
  , teamResponseName = Nothing
  , teamResponseDescription = Nothing
  , teamResponseHtmlDescription = Nothing
  , teamResponseOrganization = Nothing
  }

-- ** TeamResponseAllOf
-- | TeamResponseAllOf
data TeamResponseAllOf = TeamResponseAllOf
  { teamResponseAllOfDescription :: !(Maybe Text) -- ^ "description" - [Opt In](#input-output-options). The description of the team. 
  , teamResponseAllOfHtmlDescription :: !(Maybe Text) -- ^ "html_description" - [Opt In](#input-output-options). The description of the team with formatting as HTML. 
  , teamResponseAllOfOrganization :: !(Maybe WorkspaceCompact) -- ^ "organization"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TeamResponseAllOf
instance A.FromJSON TeamResponseAllOf where
  parseJSON = A.withObject "TeamResponseAllOf" $ \o ->
    TeamResponseAllOf
      <$> (o .:? "description")
      <*> (o .:? "html_description")
      <*> (o .:? "organization")

-- | ToJSON TeamResponseAllOf
instance A.ToJSON TeamResponseAllOf where
  toJSON TeamResponseAllOf {..} =
   _omitNulls
      [ "description" .= teamResponseAllOfDescription
      , "html_description" .= teamResponseAllOfHtmlDescription
      , "organization" .= teamResponseAllOfOrganization
      ]


-- | Construct a value of type 'TeamResponseAllOf' (by applying it's required fields, if any)
mkTeamResponseAllOf
  :: TeamResponseAllOf
mkTeamResponseAllOf =
  TeamResponseAllOf
  { teamResponseAllOfDescription = Nothing
  , teamResponseAllOfHtmlDescription = Nothing
  , teamResponseAllOfOrganization = Nothing
  }

-- ** UserBase
-- | UserBase
data UserBase = UserBase
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserBase
instance A.FromJSON UserBase where
  parseJSON = A.withObject "UserBase" $ \o ->
    pure UserBase
      

-- | ToJSON UserBase
instance A.ToJSON UserBase where
  toJSON UserBase  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'UserBase' (by applying it's required fields, if any)
mkUserBase
  :: UserBase
mkUserBase =
  UserBase
  { 
  }

-- ** UserCompact
-- | UserCompact
data UserCompact = UserCompact
  { userCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , userCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , userCompactName :: !(Maybe Text) -- ^ "name" - *Read-only except when same user as requester*. The user’s name.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserCompact
instance A.FromJSON UserCompact where
  parseJSON = A.withObject "UserCompact" $ \o ->
    UserCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")

-- | ToJSON UserCompact
instance A.ToJSON UserCompact where
  toJSON UserCompact {..} =
   _omitNulls
      [ "gid" .= userCompactGid
      , "resource_type" .= userCompactResourceType
      , "name" .= userCompactName
      ]


-- | Construct a value of type 'UserCompact' (by applying it's required fields, if any)
mkUserCompact
  :: UserCompact
mkUserCompact =
  UserCompact
  { userCompactGid = Nothing
  , userCompactResourceType = Nothing
  , userCompactName = Nothing
  }

-- ** UserCompactAllOf
-- | UserCompactAllOf
-- A *user* object represents an account in Asana that can be given access to various workspaces, projects, and tasks.
data UserCompactAllOf = UserCompactAllOf
  { userCompactAllOfName :: !(Maybe Text) -- ^ "name" - *Read-only except when same user as requester*. The user’s name.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserCompactAllOf
instance A.FromJSON UserCompactAllOf where
  parseJSON = A.withObject "UserCompactAllOf" $ \o ->
    UserCompactAllOf
      <$> (o .:? "name")

-- | ToJSON UserCompactAllOf
instance A.ToJSON UserCompactAllOf where
  toJSON UserCompactAllOf {..} =
   _omitNulls
      [ "name" .= userCompactAllOfName
      ]


-- | Construct a value of type 'UserCompactAllOf' (by applying it's required fields, if any)
mkUserCompactAllOf
  :: UserCompactAllOf
mkUserCompactAllOf =
  UserCompactAllOf
  { userCompactAllOfName = Nothing
  }

-- ** UserRequest
-- | UserRequest
data UserRequest = UserRequest
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserRequest
instance A.FromJSON UserRequest where
  parseJSON = A.withObject "UserRequest" $ \o ->
    pure UserRequest
      

-- | ToJSON UserRequest
instance A.ToJSON UserRequest where
  toJSON UserRequest  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'UserRequest' (by applying it's required fields, if any)
mkUserRequest
  :: UserRequest
mkUserRequest =
  UserRequest
  { 
  }

-- ** UserResponse
-- | UserResponse
data UserResponse = UserResponse
  { userResponseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , userResponseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , userResponseName :: !(Maybe Text) -- ^ "name" - *Read-only except when same user as requester*. The user’s name.
  , userResponseEmail :: !(Maybe Text) -- ^ "email" - The user&#39;s email address.
  , userResponsePhoto :: !(Maybe UserResponseAllOfPhoto) -- ^ "photo"
  , userResponseWorkspaces :: !(Maybe [WorkspaceCompact]) -- ^ "workspaces" - Workspaces and organizations this user may access. Note\\: The API will only return workspaces and organizations that also contain the authenticated user.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserResponse
instance A.FromJSON UserResponse where
  parseJSON = A.withObject "UserResponse" $ \o ->
    UserResponse
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "email")
      <*> (o .:? "photo")
      <*> (o .:? "workspaces")

-- | ToJSON UserResponse
instance A.ToJSON UserResponse where
  toJSON UserResponse {..} =
   _omitNulls
      [ "gid" .= userResponseGid
      , "resource_type" .= userResponseResourceType
      , "name" .= userResponseName
      , "email" .= userResponseEmail
      , "photo" .= userResponsePhoto
      , "workspaces" .= userResponseWorkspaces
      ]


-- | Construct a value of type 'UserResponse' (by applying it's required fields, if any)
mkUserResponse
  :: UserResponse
mkUserResponse =
  UserResponse
  { userResponseGid = Nothing
  , userResponseResourceType = Nothing
  , userResponseName = Nothing
  , userResponseEmail = Nothing
  , userResponsePhoto = Nothing
  , userResponseWorkspaces = Nothing
  }

-- ** UserResponseAllOf
-- | UserResponseAllOf
data UserResponseAllOf = UserResponseAllOf
  { userResponseAllOfEmail :: !(Maybe Text) -- ^ "email" - The user&#39;s email address.
  , userResponseAllOfPhoto :: !(Maybe UserResponseAllOfPhoto) -- ^ "photo"
  , userResponseAllOfWorkspaces :: !(Maybe [WorkspaceCompact]) -- ^ "workspaces" - Workspaces and organizations this user may access. Note\\: The API will only return workspaces and organizations that also contain the authenticated user.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserResponseAllOf
instance A.FromJSON UserResponseAllOf where
  parseJSON = A.withObject "UserResponseAllOf" $ \o ->
    UserResponseAllOf
      <$> (o .:? "email")
      <*> (o .:? "photo")
      <*> (o .:? "workspaces")

-- | ToJSON UserResponseAllOf
instance A.ToJSON UserResponseAllOf where
  toJSON UserResponseAllOf {..} =
   _omitNulls
      [ "email" .= userResponseAllOfEmail
      , "photo" .= userResponseAllOfPhoto
      , "workspaces" .= userResponseAllOfWorkspaces
      ]


-- | Construct a value of type 'UserResponseAllOf' (by applying it's required fields, if any)
mkUserResponseAllOf
  :: UserResponseAllOf
mkUserResponseAllOf =
  UserResponseAllOf
  { userResponseAllOfEmail = Nothing
  , userResponseAllOfPhoto = Nothing
  , userResponseAllOfWorkspaces = Nothing
  }

-- ** UserResponseAllOfPhoto
-- | UserResponseAllOfPhoto
-- A map of the user’s profile photo in various sizes, or null if no photo is set. Sizes provided are 21, 27, 36, 60, and 128. Images are in PNG format.
data UserResponseAllOfPhoto = UserResponseAllOfPhoto
  { userResponseAllOfPhotoImage21x21 :: !(Maybe Text) -- ^ "image_21x21"
  , userResponseAllOfPhotoImage27x27 :: !(Maybe Text) -- ^ "image_27x27"
  , userResponseAllOfPhotoImage36x36 :: !(Maybe Text) -- ^ "image_36x36"
  , userResponseAllOfPhotoImage60x60 :: !(Maybe Text) -- ^ "image_60x60"
  , userResponseAllOfPhotoImage128x128 :: !(Maybe Text) -- ^ "image_128x128"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserResponseAllOfPhoto
instance A.FromJSON UserResponseAllOfPhoto where
  parseJSON = A.withObject "UserResponseAllOfPhoto" $ \o ->
    UserResponseAllOfPhoto
      <$> (o .:? "image_21x21")
      <*> (o .:? "image_27x27")
      <*> (o .:? "image_36x36")
      <*> (o .:? "image_60x60")
      <*> (o .:? "image_128x128")

-- | ToJSON UserResponseAllOfPhoto
instance A.ToJSON UserResponseAllOfPhoto where
  toJSON UserResponseAllOfPhoto {..} =
   _omitNulls
      [ "image_21x21" .= userResponseAllOfPhotoImage21x21
      , "image_27x27" .= userResponseAllOfPhotoImage27x27
      , "image_36x36" .= userResponseAllOfPhotoImage36x36
      , "image_60x60" .= userResponseAllOfPhotoImage60x60
      , "image_128x128" .= userResponseAllOfPhotoImage128x128
      ]


-- | Construct a value of type 'UserResponseAllOfPhoto' (by applying it's required fields, if any)
mkUserResponseAllOfPhoto
  :: UserResponseAllOfPhoto
mkUserResponseAllOfPhoto =
  UserResponseAllOfPhoto
  { userResponseAllOfPhotoImage21x21 = Nothing
  , userResponseAllOfPhotoImage27x27 = Nothing
  , userResponseAllOfPhotoImage36x36 = Nothing
  , userResponseAllOfPhotoImage60x60 = Nothing
  , userResponseAllOfPhotoImage128x128 = Nothing
  }

-- ** UserTaskListBase
-- | UserTaskListBase
data UserTaskListBase = UserTaskListBase
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserTaskListBase
instance A.FromJSON UserTaskListBase where
  parseJSON = A.withObject "UserTaskListBase" $ \o ->
    pure UserTaskListBase
      

-- | ToJSON UserTaskListBase
instance A.ToJSON UserTaskListBase where
  toJSON UserTaskListBase  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'UserTaskListBase' (by applying it's required fields, if any)
mkUserTaskListBase
  :: UserTaskListBase
mkUserTaskListBase =
  UserTaskListBase
  { 
  }

-- ** UserTaskListCompact
-- | UserTaskListCompact
data UserTaskListCompact = UserTaskListCompact
  { userTaskListCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , userTaskListCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , userTaskListCompactName :: !(Maybe Text) -- ^ "name" - The name of the user task list.
  , userTaskListCompactOwner :: !(Maybe UserCompact) -- ^ "owner" - The owner of the user task list, i.e. the person whose My Tasks is represented by this resource.
  , userTaskListCompactWorkspace :: !(Maybe WorkspaceCompact) -- ^ "workspace" - The workspace in which the user task list is located.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserTaskListCompact
instance A.FromJSON UserTaskListCompact where
  parseJSON = A.withObject "UserTaskListCompact" $ \o ->
    UserTaskListCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "owner")
      <*> (o .:? "workspace")

-- | ToJSON UserTaskListCompact
instance A.ToJSON UserTaskListCompact where
  toJSON UserTaskListCompact {..} =
   _omitNulls
      [ "gid" .= userTaskListCompactGid
      , "resource_type" .= userTaskListCompactResourceType
      , "name" .= userTaskListCompactName
      , "owner" .= userTaskListCompactOwner
      , "workspace" .= userTaskListCompactWorkspace
      ]


-- | Construct a value of type 'UserTaskListCompact' (by applying it's required fields, if any)
mkUserTaskListCompact
  :: UserTaskListCompact
mkUserTaskListCompact =
  UserTaskListCompact
  { userTaskListCompactGid = Nothing
  , userTaskListCompactResourceType = Nothing
  , userTaskListCompactName = Nothing
  , userTaskListCompactOwner = Nothing
  , userTaskListCompactWorkspace = Nothing
  }

-- ** UserTaskListCompactAllOf
-- | UserTaskListCompactAllOf
-- A user task list represents the tasks assigned to a particular user. It provides API access to a user’s “My Tasks” view in Asana.
data UserTaskListCompactAllOf = UserTaskListCompactAllOf
  { userTaskListCompactAllOfName :: !(Maybe Text) -- ^ "name" - The name of the user task list.
  , userTaskListCompactAllOfOwner :: !(Maybe UserCompact) -- ^ "owner" - The owner of the user task list, i.e. the person whose My Tasks is represented by this resource.
  , userTaskListCompactAllOfWorkspace :: !(Maybe WorkspaceCompact) -- ^ "workspace" - The workspace in which the user task list is located.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserTaskListCompactAllOf
instance A.FromJSON UserTaskListCompactAllOf where
  parseJSON = A.withObject "UserTaskListCompactAllOf" $ \o ->
    UserTaskListCompactAllOf
      <$> (o .:? "name")
      <*> (o .:? "owner")
      <*> (o .:? "workspace")

-- | ToJSON UserTaskListCompactAllOf
instance A.ToJSON UserTaskListCompactAllOf where
  toJSON UserTaskListCompactAllOf {..} =
   _omitNulls
      [ "name" .= userTaskListCompactAllOfName
      , "owner" .= userTaskListCompactAllOfOwner
      , "workspace" .= userTaskListCompactAllOfWorkspace
      ]


-- | Construct a value of type 'UserTaskListCompactAllOf' (by applying it's required fields, if any)
mkUserTaskListCompactAllOf
  :: UserTaskListCompactAllOf
mkUserTaskListCompactAllOf =
  UserTaskListCompactAllOf
  { userTaskListCompactAllOfName = Nothing
  , userTaskListCompactAllOfOwner = Nothing
  , userTaskListCompactAllOfWorkspace = Nothing
  }

-- ** UserTaskListRequest
-- | UserTaskListRequest
data UserTaskListRequest = UserTaskListRequest
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserTaskListRequest
instance A.FromJSON UserTaskListRequest where
  parseJSON = A.withObject "UserTaskListRequest" $ \o ->
    pure UserTaskListRequest
      

-- | ToJSON UserTaskListRequest
instance A.ToJSON UserTaskListRequest where
  toJSON UserTaskListRequest  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'UserTaskListRequest' (by applying it's required fields, if any)
mkUserTaskListRequest
  :: UserTaskListRequest
mkUserTaskListRequest =
  UserTaskListRequest
  { 
  }

-- ** UserTaskListResponse
-- | UserTaskListResponse
data UserTaskListResponse = UserTaskListResponse
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserTaskListResponse
instance A.FromJSON UserTaskListResponse where
  parseJSON = A.withObject "UserTaskListResponse" $ \o ->
    pure UserTaskListResponse
      

-- | ToJSON UserTaskListResponse
instance A.ToJSON UserTaskListResponse where
  toJSON UserTaskListResponse  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'UserTaskListResponse' (by applying it's required fields, if any)
mkUserTaskListResponse
  :: UserTaskListResponse
mkUserTaskListResponse =
  UserTaskListResponse
  { 
  }

-- ** WebhookCompact
-- | WebhookCompact
data WebhookCompact = WebhookCompact
  { webhookCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , webhookCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , webhookCompactActive :: !(Maybe Bool) -- ^ "active" - If true, the webhook will send events - if false it is considered inactive and will not generate events.
  , webhookCompactResource :: !(Maybe AsanaNamedResource) -- ^ "resource"
  , webhookCompactTarget :: !(Maybe Text) -- ^ "target" - The URL to receive the HTTP POST.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebhookCompact
instance A.FromJSON WebhookCompact where
  parseJSON = A.withObject "WebhookCompact" $ \o ->
    WebhookCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "active")
      <*> (o .:? "resource")
      <*> (o .:? "target")

-- | ToJSON WebhookCompact
instance A.ToJSON WebhookCompact where
  toJSON WebhookCompact {..} =
   _omitNulls
      [ "gid" .= webhookCompactGid
      , "resource_type" .= webhookCompactResourceType
      , "active" .= webhookCompactActive
      , "resource" .= webhookCompactResource
      , "target" .= webhookCompactTarget
      ]


-- | Construct a value of type 'WebhookCompact' (by applying it's required fields, if any)
mkWebhookCompact
  :: WebhookCompact
mkWebhookCompact =
  WebhookCompact
  { webhookCompactGid = Nothing
  , webhookCompactResourceType = Nothing
  , webhookCompactActive = Nothing
  , webhookCompactResource = Nothing
  , webhookCompactTarget = Nothing
  }

-- ** WebhookCompactAllOf
-- | WebhookCompactAllOf
-- Webhook objects represent the state of an active subscription for a server to be updated with information from Asana. This schema represents the subscription itself, not the objects that are sent to the server. For information on those please refer to the [Event](#tocS_Event) schema.  
data WebhookCompactAllOf = WebhookCompactAllOf
  { webhookCompactAllOfActive :: !(Maybe Bool) -- ^ "active" - If true, the webhook will send events - if false it is considered inactive and will not generate events.
  , webhookCompactAllOfResource :: !(Maybe AsanaNamedResource) -- ^ "resource"
  , webhookCompactAllOfTarget :: !(Maybe Text) -- ^ "target" - The URL to receive the HTTP POST.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebhookCompactAllOf
instance A.FromJSON WebhookCompactAllOf where
  parseJSON = A.withObject "WebhookCompactAllOf" $ \o ->
    WebhookCompactAllOf
      <$> (o .:? "active")
      <*> (o .:? "resource")
      <*> (o .:? "target")

-- | ToJSON WebhookCompactAllOf
instance A.ToJSON WebhookCompactAllOf where
  toJSON WebhookCompactAllOf {..} =
   _omitNulls
      [ "active" .= webhookCompactAllOfActive
      , "resource" .= webhookCompactAllOfResource
      , "target" .= webhookCompactAllOfTarget
      ]


-- | Construct a value of type 'WebhookCompactAllOf' (by applying it's required fields, if any)
mkWebhookCompactAllOf
  :: WebhookCompactAllOf
mkWebhookCompactAllOf =
  WebhookCompactAllOf
  { webhookCompactAllOfActive = Nothing
  , webhookCompactAllOfResource = Nothing
  , webhookCompactAllOfTarget = Nothing
  }

-- ** WebhookFilter
-- | WebhookFilter
-- A WebhookFilter can be passed on creation of a webhook in order to filter the types of actions that trigger delivery of an [Event](#tocS_Event)
data WebhookFilter = WebhookFilter
  { webhookFilterResourceType :: !(Maybe Text) -- ^ "resource_type" - The type of the resource which created the event when modified; for example, to filter to changes on regular tasks this field should be set to &#x60;task&#x60;.
  , webhookFilterResourceSubtype :: !(Maybe Text) -- ^ "resource_subtype" - The resource subtype of the resource that the filter applies to. This should be set to the same value as is returned on the &#x60;resource_subtype&#x60; field on the resources themselves.
  , webhookFilterAction :: !(Maybe Text) -- ^ "action" - The type of change on the **resource** to pass through the filter. For more information refer to &#x60;Event.action&#x60; in the [Event](#tocS_Event) schema. This can be one of &#x60;changed&#x60;, &#x60;added&#x60;, &#x60;removed&#x60;, &#x60;deleted&#x60;, and &#x60;undeleted&#x60; depending on the nature of what has occurred on the resource.
  , webhookFilterFields :: !(Maybe [Text]) -- ^ "fields" - *Conditional.* A whitelist of fields for events which will pass the filter when the resource is changed. These can be any combination of the fields on the resources themselves. This field is only valid for &#x60;action&#x60; of type &#x60;changed&#x60;
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebhookFilter
instance A.FromJSON WebhookFilter where
  parseJSON = A.withObject "WebhookFilter" $ \o ->
    WebhookFilter
      <$> (o .:? "resource_type")
      <*> (o .:? "resource_subtype")
      <*> (o .:? "action")
      <*> (o .:? "fields")

-- | ToJSON WebhookFilter
instance A.ToJSON WebhookFilter where
  toJSON WebhookFilter {..} =
   _omitNulls
      [ "resource_type" .= webhookFilterResourceType
      , "resource_subtype" .= webhookFilterResourceSubtype
      , "action" .= webhookFilterAction
      , "fields" .= webhookFilterFields
      ]


-- | Construct a value of type 'WebhookFilter' (by applying it's required fields, if any)
mkWebhookFilter
  :: WebhookFilter
mkWebhookFilter =
  WebhookFilter
  { webhookFilterResourceType = Nothing
  , webhookFilterResourceSubtype = Nothing
  , webhookFilterAction = Nothing
  , webhookFilterFields = Nothing
  }

-- ** WebhookRequest
-- | WebhookRequest
data WebhookRequest = WebhookRequest
  { webhookRequestResource :: !(Text) -- ^ /Required/ "resource" - A resource ID to subscribe to. Many Asana resources are valid to create webhooks on, but higher-level resources require filters.
  , webhookRequestTarget :: !(Text) -- ^ /Required/ "target" - The URL to receive the HTTP POST. The full URL will be used to deliver events from this webhook (including parameters) which allows encoding of application-specific state when the webhook is created.
  , webhookRequestFilters :: !(Maybe [WebhookFilter]) -- ^ "filters" - An array of WebhookFilter objects to specify a whitelist of filters to apply to events from this webhook. If a webhook event passes any of the filters the event will be delivered; otherwise no event will be sent to the receiving server.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebhookRequest
instance A.FromJSON WebhookRequest where
  parseJSON = A.withObject "WebhookRequest" $ \o ->
    WebhookRequest
      <$> (o .:  "resource")
      <*> (o .:  "target")
      <*> (o .:? "filters")

-- | ToJSON WebhookRequest
instance A.ToJSON WebhookRequest where
  toJSON WebhookRequest {..} =
   _omitNulls
      [ "resource" .= webhookRequestResource
      , "target" .= webhookRequestTarget
      , "filters" .= webhookRequestFilters
      ]


-- | Construct a value of type 'WebhookRequest' (by applying it's required fields, if any)
mkWebhookRequest
  :: Text -- ^ 'webhookRequestResource': A resource ID to subscribe to. Many Asana resources are valid to create webhooks on, but higher-level resources require filters.
  -> Text -- ^ 'webhookRequestTarget': The URL to receive the HTTP POST. The full URL will be used to deliver events from this webhook (including parameters) which allows encoding of application-specific state when the webhook is created.
  -> WebhookRequest
mkWebhookRequest webhookRequestResource webhookRequestTarget =
  WebhookRequest
  { webhookRequestResource
  , webhookRequestTarget
  , webhookRequestFilters = Nothing
  }

-- ** WebhookResponse
-- | WebhookResponse
data WebhookResponse = WebhookResponse
  { webhookResponseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , webhookResponseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , webhookResponseActive :: !(Maybe Bool) -- ^ "active" - If true, the webhook will send events - if false it is considered inactive and will not generate events.
  , webhookResponseResource :: !(Maybe AsanaNamedResource) -- ^ "resource"
  , webhookResponseTarget :: !(Maybe Text) -- ^ "target" - The URL to receive the HTTP POST.
  , webhookResponseCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , webhookResponseLastFailureAt :: !(Maybe DateTime) -- ^ "last_failure_at" - The timestamp when the webhook last received an error when sending an event to the target.
  , webhookResponseLastFailureContent :: !(Maybe Text) -- ^ "last_failure_content" - The contents of the last error response sent to the webhook when attempting to deliver events to the target.
  , webhookResponseLastSuccessAt :: !(Maybe DateTime) -- ^ "last_success_at" - The timestamp when the webhook last successfully sent an event to the target.
  , webhookResponseFilters :: !(Maybe [WebhookFilter]) -- ^ "filters" - Whitelist of filters to apply to events from this webhook. If a webhook event passes any of the filters the event will be delivered; otherwise no event will be sent to the receiving server.  
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebhookResponse
instance A.FromJSON WebhookResponse where
  parseJSON = A.withObject "WebhookResponse" $ \o ->
    WebhookResponse
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "active")
      <*> (o .:? "resource")
      <*> (o .:? "target")
      <*> (o .:? "created_at")
      <*> (o .:? "last_failure_at")
      <*> (o .:? "last_failure_content")
      <*> (o .:? "last_success_at")
      <*> (o .:? "filters")

-- | ToJSON WebhookResponse
instance A.ToJSON WebhookResponse where
  toJSON WebhookResponse {..} =
   _omitNulls
      [ "gid" .= webhookResponseGid
      , "resource_type" .= webhookResponseResourceType
      , "active" .= webhookResponseActive
      , "resource" .= webhookResponseResource
      , "target" .= webhookResponseTarget
      , "created_at" .= webhookResponseCreatedAt
      , "last_failure_at" .= webhookResponseLastFailureAt
      , "last_failure_content" .= webhookResponseLastFailureContent
      , "last_success_at" .= webhookResponseLastSuccessAt
      , "filters" .= webhookResponseFilters
      ]


-- | Construct a value of type 'WebhookResponse' (by applying it's required fields, if any)
mkWebhookResponse
  :: WebhookResponse
mkWebhookResponse =
  WebhookResponse
  { webhookResponseGid = Nothing
  , webhookResponseResourceType = Nothing
  , webhookResponseActive = Nothing
  , webhookResponseResource = Nothing
  , webhookResponseTarget = Nothing
  , webhookResponseCreatedAt = Nothing
  , webhookResponseLastFailureAt = Nothing
  , webhookResponseLastFailureContent = Nothing
  , webhookResponseLastSuccessAt = Nothing
  , webhookResponseFilters = Nothing
  }

-- ** WebhookResponseAllOf
-- | WebhookResponseAllOf
data WebhookResponseAllOf = WebhookResponseAllOf
  { webhookResponseAllOfCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - The time at which this resource was created.
  , webhookResponseAllOfLastFailureAt :: !(Maybe DateTime) -- ^ "last_failure_at" - The timestamp when the webhook last received an error when sending an event to the target.
  , webhookResponseAllOfLastFailureContent :: !(Maybe Text) -- ^ "last_failure_content" - The contents of the last error response sent to the webhook when attempting to deliver events to the target.
  , webhookResponseAllOfLastSuccessAt :: !(Maybe DateTime) -- ^ "last_success_at" - The timestamp when the webhook last successfully sent an event to the target.
  , webhookResponseAllOfFilters :: !(Maybe [WebhookFilter]) -- ^ "filters" - Whitelist of filters to apply to events from this webhook. If a webhook event passes any of the filters the event will be delivered; otherwise no event will be sent to the receiving server.  
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebhookResponseAllOf
instance A.FromJSON WebhookResponseAllOf where
  parseJSON = A.withObject "WebhookResponseAllOf" $ \o ->
    WebhookResponseAllOf
      <$> (o .:? "created_at")
      <*> (o .:? "last_failure_at")
      <*> (o .:? "last_failure_content")
      <*> (o .:? "last_success_at")
      <*> (o .:? "filters")

-- | ToJSON WebhookResponseAllOf
instance A.ToJSON WebhookResponseAllOf where
  toJSON WebhookResponseAllOf {..} =
   _omitNulls
      [ "created_at" .= webhookResponseAllOfCreatedAt
      , "last_failure_at" .= webhookResponseAllOfLastFailureAt
      , "last_failure_content" .= webhookResponseAllOfLastFailureContent
      , "last_success_at" .= webhookResponseAllOfLastSuccessAt
      , "filters" .= webhookResponseAllOfFilters
      ]


-- | Construct a value of type 'WebhookResponseAllOf' (by applying it's required fields, if any)
mkWebhookResponseAllOf
  :: WebhookResponseAllOf
mkWebhookResponseAllOf =
  WebhookResponseAllOf
  { webhookResponseAllOfCreatedAt = Nothing
  , webhookResponseAllOfLastFailureAt = Nothing
  , webhookResponseAllOfLastFailureContent = Nothing
  , webhookResponseAllOfLastSuccessAt = Nothing
  , webhookResponseAllOfFilters = Nothing
  }

-- ** WorkspaceAddUserRequest
-- | WorkspaceAddUserRequest
-- A user identification object for specification with the addUser/removeUser endpoints.
data WorkspaceAddUserRequest = WorkspaceAddUserRequest
  { workspaceAddUserRequestUser :: !(Maybe Text) -- ^ "user" - A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkspaceAddUserRequest
instance A.FromJSON WorkspaceAddUserRequest where
  parseJSON = A.withObject "WorkspaceAddUserRequest" $ \o ->
    WorkspaceAddUserRequest
      <$> (o .:? "user")

-- | ToJSON WorkspaceAddUserRequest
instance A.ToJSON WorkspaceAddUserRequest where
  toJSON WorkspaceAddUserRequest {..} =
   _omitNulls
      [ "user" .= workspaceAddUserRequestUser
      ]


-- | Construct a value of type 'WorkspaceAddUserRequest' (by applying it's required fields, if any)
mkWorkspaceAddUserRequest
  :: WorkspaceAddUserRequest
mkWorkspaceAddUserRequest =
  WorkspaceAddUserRequest
  { workspaceAddUserRequestUser = Nothing
  }

-- ** WorkspaceBase
-- | WorkspaceBase
data WorkspaceBase = WorkspaceBase
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkspaceBase
instance A.FromJSON WorkspaceBase where
  parseJSON = A.withObject "WorkspaceBase" $ \o ->
    pure WorkspaceBase
      

-- | ToJSON WorkspaceBase
instance A.ToJSON WorkspaceBase where
  toJSON WorkspaceBase  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'WorkspaceBase' (by applying it's required fields, if any)
mkWorkspaceBase
  :: WorkspaceBase
mkWorkspaceBase =
  WorkspaceBase
  { 
  }

-- ** WorkspaceCompact
-- | WorkspaceCompact
data WorkspaceCompact = WorkspaceCompact
  { workspaceCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , workspaceCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , workspaceCompactName :: !(Maybe Text) -- ^ "name" - The name of the workspace.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkspaceCompact
instance A.FromJSON WorkspaceCompact where
  parseJSON = A.withObject "WorkspaceCompact" $ \o ->
    WorkspaceCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")

-- | ToJSON WorkspaceCompact
instance A.ToJSON WorkspaceCompact where
  toJSON WorkspaceCompact {..} =
   _omitNulls
      [ "gid" .= workspaceCompactGid
      , "resource_type" .= workspaceCompactResourceType
      , "name" .= workspaceCompactName
      ]


-- | Construct a value of type 'WorkspaceCompact' (by applying it's required fields, if any)
mkWorkspaceCompact
  :: WorkspaceCompact
mkWorkspaceCompact =
  WorkspaceCompact
  { workspaceCompactGid = Nothing
  , workspaceCompactResourceType = Nothing
  , workspaceCompactName = Nothing
  }

-- ** WorkspaceCompactAllOf
-- | WorkspaceCompactAllOf
-- A *workspace* is the highest-level organizational unit in Asana. All projects and tasks have an associated workspace.
data WorkspaceCompactAllOf = WorkspaceCompactAllOf
  { workspaceCompactAllOfName :: !(Maybe Text) -- ^ "name" - The name of the workspace.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkspaceCompactAllOf
instance A.FromJSON WorkspaceCompactAllOf where
  parseJSON = A.withObject "WorkspaceCompactAllOf" $ \o ->
    WorkspaceCompactAllOf
      <$> (o .:? "name")

-- | ToJSON WorkspaceCompactAllOf
instance A.ToJSON WorkspaceCompactAllOf where
  toJSON WorkspaceCompactAllOf {..} =
   _omitNulls
      [ "name" .= workspaceCompactAllOfName
      ]


-- | Construct a value of type 'WorkspaceCompactAllOf' (by applying it's required fields, if any)
mkWorkspaceCompactAllOf
  :: WorkspaceCompactAllOf
mkWorkspaceCompactAllOf =
  WorkspaceCompactAllOf
  { workspaceCompactAllOfName = Nothing
  }

-- ** WorkspaceMembershipBase
-- | WorkspaceMembershipBase
data WorkspaceMembershipBase = WorkspaceMembershipBase
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkspaceMembershipBase
instance A.FromJSON WorkspaceMembershipBase where
  parseJSON = A.withObject "WorkspaceMembershipBase" $ \o ->
    pure WorkspaceMembershipBase
      

-- | ToJSON WorkspaceMembershipBase
instance A.ToJSON WorkspaceMembershipBase where
  toJSON WorkspaceMembershipBase  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'WorkspaceMembershipBase' (by applying it's required fields, if any)
mkWorkspaceMembershipBase
  :: WorkspaceMembershipBase
mkWorkspaceMembershipBase =
  WorkspaceMembershipBase
  { 
  }

-- ** WorkspaceMembershipCompact
-- | WorkspaceMembershipCompact
data WorkspaceMembershipCompact = WorkspaceMembershipCompact
  { workspaceMembershipCompactGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , workspaceMembershipCompactResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , workspaceMembershipCompactUser :: !(Maybe UserCompact) -- ^ "user"
  , workspaceMembershipCompactWorkspace :: !(Maybe WorkspaceCompact) -- ^ "workspace"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkspaceMembershipCompact
instance A.FromJSON WorkspaceMembershipCompact where
  parseJSON = A.withObject "WorkspaceMembershipCompact" $ \o ->
    WorkspaceMembershipCompact
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "user")
      <*> (o .:? "workspace")

-- | ToJSON WorkspaceMembershipCompact
instance A.ToJSON WorkspaceMembershipCompact where
  toJSON WorkspaceMembershipCompact {..} =
   _omitNulls
      [ "gid" .= workspaceMembershipCompactGid
      , "resource_type" .= workspaceMembershipCompactResourceType
      , "user" .= workspaceMembershipCompactUser
      , "workspace" .= workspaceMembershipCompactWorkspace
      ]


-- | Construct a value of type 'WorkspaceMembershipCompact' (by applying it's required fields, if any)
mkWorkspaceMembershipCompact
  :: WorkspaceMembershipCompact
mkWorkspaceMembershipCompact =
  WorkspaceMembershipCompact
  { workspaceMembershipCompactGid = Nothing
  , workspaceMembershipCompactResourceType = Nothing
  , workspaceMembershipCompactUser = Nothing
  , workspaceMembershipCompactWorkspace = Nothing
  }

-- ** WorkspaceMembershipCompactAllOf
-- | WorkspaceMembershipCompactAllOf
-- This object determines if a user is a member of a workspace.
data WorkspaceMembershipCompactAllOf = WorkspaceMembershipCompactAllOf
  { workspaceMembershipCompactAllOfUser :: !(Maybe UserCompact) -- ^ "user"
  , workspaceMembershipCompactAllOfWorkspace :: !(Maybe WorkspaceCompact) -- ^ "workspace"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkspaceMembershipCompactAllOf
instance A.FromJSON WorkspaceMembershipCompactAllOf where
  parseJSON = A.withObject "WorkspaceMembershipCompactAllOf" $ \o ->
    WorkspaceMembershipCompactAllOf
      <$> (o .:? "user")
      <*> (o .:? "workspace")

-- | ToJSON WorkspaceMembershipCompactAllOf
instance A.ToJSON WorkspaceMembershipCompactAllOf where
  toJSON WorkspaceMembershipCompactAllOf {..} =
   _omitNulls
      [ "user" .= workspaceMembershipCompactAllOfUser
      , "workspace" .= workspaceMembershipCompactAllOfWorkspace
      ]


-- | Construct a value of type 'WorkspaceMembershipCompactAllOf' (by applying it's required fields, if any)
mkWorkspaceMembershipCompactAllOf
  :: WorkspaceMembershipCompactAllOf
mkWorkspaceMembershipCompactAllOf =
  WorkspaceMembershipCompactAllOf
  { workspaceMembershipCompactAllOfUser = Nothing
  , workspaceMembershipCompactAllOfWorkspace = Nothing
  }

-- ** WorkspaceMembershipRequest
-- | WorkspaceMembershipRequest
data WorkspaceMembershipRequest = WorkspaceMembershipRequest
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkspaceMembershipRequest
instance A.FromJSON WorkspaceMembershipRequest where
  parseJSON = A.withObject "WorkspaceMembershipRequest" $ \o ->
    pure WorkspaceMembershipRequest
      

-- | ToJSON WorkspaceMembershipRequest
instance A.ToJSON WorkspaceMembershipRequest where
  toJSON WorkspaceMembershipRequest  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'WorkspaceMembershipRequest' (by applying it's required fields, if any)
mkWorkspaceMembershipRequest
  :: WorkspaceMembershipRequest
mkWorkspaceMembershipRequest =
  WorkspaceMembershipRequest
  { 
  }

-- ** WorkspaceMembershipResponse
-- | WorkspaceMembershipResponse
data WorkspaceMembershipResponse = WorkspaceMembershipResponse
  { workspaceMembershipResponseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , workspaceMembershipResponseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , workspaceMembershipResponseUser :: !(Maybe UserCompact) -- ^ "user"
  , workspaceMembershipResponseWorkspace :: !(Maybe WorkspaceCompact) -- ^ "workspace"
  , workspaceMembershipResponseUserTaskList :: !(Maybe UserTaskListCompact) -- ^ "user_task_list"
  , workspaceMembershipResponseIsActive :: !(Maybe Bool) -- ^ "is_active" - Reflects if this user still a member of the workspace.
  , workspaceMembershipResponseIsAdmin :: !(Maybe Bool) -- ^ "is_admin" - Reflects if this user is an admin of the workspace.
  , workspaceMembershipResponseIsGuest :: !(Maybe Bool) -- ^ "is_guest" - Reflects if this user is a guest of the workspace.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkspaceMembershipResponse
instance A.FromJSON WorkspaceMembershipResponse where
  parseJSON = A.withObject "WorkspaceMembershipResponse" $ \o ->
    WorkspaceMembershipResponse
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "user")
      <*> (o .:? "workspace")
      <*> (o .:? "user_task_list")
      <*> (o .:? "is_active")
      <*> (o .:? "is_admin")
      <*> (o .:? "is_guest")

-- | ToJSON WorkspaceMembershipResponse
instance A.ToJSON WorkspaceMembershipResponse where
  toJSON WorkspaceMembershipResponse {..} =
   _omitNulls
      [ "gid" .= workspaceMembershipResponseGid
      , "resource_type" .= workspaceMembershipResponseResourceType
      , "user" .= workspaceMembershipResponseUser
      , "workspace" .= workspaceMembershipResponseWorkspace
      , "user_task_list" .= workspaceMembershipResponseUserTaskList
      , "is_active" .= workspaceMembershipResponseIsActive
      , "is_admin" .= workspaceMembershipResponseIsAdmin
      , "is_guest" .= workspaceMembershipResponseIsGuest
      ]


-- | Construct a value of type 'WorkspaceMembershipResponse' (by applying it's required fields, if any)
mkWorkspaceMembershipResponse
  :: WorkspaceMembershipResponse
mkWorkspaceMembershipResponse =
  WorkspaceMembershipResponse
  { workspaceMembershipResponseGid = Nothing
  , workspaceMembershipResponseResourceType = Nothing
  , workspaceMembershipResponseUser = Nothing
  , workspaceMembershipResponseWorkspace = Nothing
  , workspaceMembershipResponseUserTaskList = Nothing
  , workspaceMembershipResponseIsActive = Nothing
  , workspaceMembershipResponseIsAdmin = Nothing
  , workspaceMembershipResponseIsGuest = Nothing
  }

-- ** WorkspaceMembershipResponseAllOf
-- | WorkspaceMembershipResponseAllOf
data WorkspaceMembershipResponseAllOf = WorkspaceMembershipResponseAllOf
  { workspaceMembershipResponseAllOfUserTaskList :: !(Maybe UserTaskListCompact) -- ^ "user_task_list"
  , workspaceMembershipResponseAllOfIsActive :: !(Maybe Bool) -- ^ "is_active" - Reflects if this user still a member of the workspace.
  , workspaceMembershipResponseAllOfIsAdmin :: !(Maybe Bool) -- ^ "is_admin" - Reflects if this user is an admin of the workspace.
  , workspaceMembershipResponseAllOfIsGuest :: !(Maybe Bool) -- ^ "is_guest" - Reflects if this user is a guest of the workspace.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkspaceMembershipResponseAllOf
instance A.FromJSON WorkspaceMembershipResponseAllOf where
  parseJSON = A.withObject "WorkspaceMembershipResponseAllOf" $ \o ->
    WorkspaceMembershipResponseAllOf
      <$> (o .:? "user_task_list")
      <*> (o .:? "is_active")
      <*> (o .:? "is_admin")
      <*> (o .:? "is_guest")

-- | ToJSON WorkspaceMembershipResponseAllOf
instance A.ToJSON WorkspaceMembershipResponseAllOf where
  toJSON WorkspaceMembershipResponseAllOf {..} =
   _omitNulls
      [ "user_task_list" .= workspaceMembershipResponseAllOfUserTaskList
      , "is_active" .= workspaceMembershipResponseAllOfIsActive
      , "is_admin" .= workspaceMembershipResponseAllOfIsAdmin
      , "is_guest" .= workspaceMembershipResponseAllOfIsGuest
      ]


-- | Construct a value of type 'WorkspaceMembershipResponseAllOf' (by applying it's required fields, if any)
mkWorkspaceMembershipResponseAllOf
  :: WorkspaceMembershipResponseAllOf
mkWorkspaceMembershipResponseAllOf =
  WorkspaceMembershipResponseAllOf
  { workspaceMembershipResponseAllOfUserTaskList = Nothing
  , workspaceMembershipResponseAllOfIsActive = Nothing
  , workspaceMembershipResponseAllOfIsAdmin = Nothing
  , workspaceMembershipResponseAllOfIsGuest = Nothing
  }

-- ** WorkspaceRemoveUserRequest
-- | WorkspaceRemoveUserRequest
-- A user identification object for specification with the addUser/removeUser endpoints.
data WorkspaceRemoveUserRequest = WorkspaceRemoveUserRequest
  { workspaceRemoveUserRequestUser :: !(Maybe Text) -- ^ "user" - A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkspaceRemoveUserRequest
instance A.FromJSON WorkspaceRemoveUserRequest where
  parseJSON = A.withObject "WorkspaceRemoveUserRequest" $ \o ->
    WorkspaceRemoveUserRequest
      <$> (o .:? "user")

-- | ToJSON WorkspaceRemoveUserRequest
instance A.ToJSON WorkspaceRemoveUserRequest where
  toJSON WorkspaceRemoveUserRequest {..} =
   _omitNulls
      [ "user" .= workspaceRemoveUserRequestUser
      ]


-- | Construct a value of type 'WorkspaceRemoveUserRequest' (by applying it's required fields, if any)
mkWorkspaceRemoveUserRequest
  :: WorkspaceRemoveUserRequest
mkWorkspaceRemoveUserRequest =
  WorkspaceRemoveUserRequest
  { workspaceRemoveUserRequestUser = Nothing
  }

-- ** WorkspaceRequest
-- | WorkspaceRequest
data WorkspaceRequest = WorkspaceRequest
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkspaceRequest
instance A.FromJSON WorkspaceRequest where
  parseJSON = A.withObject "WorkspaceRequest" $ \o ->
    pure WorkspaceRequest
      

-- | ToJSON WorkspaceRequest
instance A.ToJSON WorkspaceRequest where
  toJSON WorkspaceRequest  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'WorkspaceRequest' (by applying it's required fields, if any)
mkWorkspaceRequest
  :: WorkspaceRequest
mkWorkspaceRequest =
  WorkspaceRequest
  { 
  }

-- ** WorkspaceResponse
-- | WorkspaceResponse
data WorkspaceResponse = WorkspaceResponse
  { workspaceResponseGid :: !(Maybe Text) -- ^ "gid" - Globally unique identifier of the resource, as a string.
  , workspaceResponseResourceType :: !(Maybe Text) -- ^ "resource_type" - The base type of this resource.
  , workspaceResponseName :: !(Maybe Text) -- ^ "name" - The name of the workspace.
  , workspaceResponseEmailDomains :: !(Maybe [Text]) -- ^ "email_domains" - The email domains that are associated with this workspace.
  , workspaceResponseIsOrganization :: !(Maybe Bool) -- ^ "is_organization" - Whether the workspace is an *organization*.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkspaceResponse
instance A.FromJSON WorkspaceResponse where
  parseJSON = A.withObject "WorkspaceResponse" $ \o ->
    WorkspaceResponse
      <$> (o .:? "gid")
      <*> (o .:? "resource_type")
      <*> (o .:? "name")
      <*> (o .:? "email_domains")
      <*> (o .:? "is_organization")

-- | ToJSON WorkspaceResponse
instance A.ToJSON WorkspaceResponse where
  toJSON WorkspaceResponse {..} =
   _omitNulls
      [ "gid" .= workspaceResponseGid
      , "resource_type" .= workspaceResponseResourceType
      , "name" .= workspaceResponseName
      , "email_domains" .= workspaceResponseEmailDomains
      , "is_organization" .= workspaceResponseIsOrganization
      ]


-- | Construct a value of type 'WorkspaceResponse' (by applying it's required fields, if any)
mkWorkspaceResponse
  :: WorkspaceResponse
mkWorkspaceResponse =
  WorkspaceResponse
  { workspaceResponseGid = Nothing
  , workspaceResponseResourceType = Nothing
  , workspaceResponseName = Nothing
  , workspaceResponseEmailDomains = Nothing
  , workspaceResponseIsOrganization = Nothing
  }

-- ** WorkspaceResponseAllOf
-- | WorkspaceResponseAllOf
data WorkspaceResponseAllOf = WorkspaceResponseAllOf
  { workspaceResponseAllOfEmailDomains :: !(Maybe [Text]) -- ^ "email_domains" - The email domains that are associated with this workspace.
  , workspaceResponseAllOfIsOrganization :: !(Maybe Bool) -- ^ "is_organization" - Whether the workspace is an *organization*.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkspaceResponseAllOf
instance A.FromJSON WorkspaceResponseAllOf where
  parseJSON = A.withObject "WorkspaceResponseAllOf" $ \o ->
    WorkspaceResponseAllOf
      <$> (o .:? "email_domains")
      <*> (o .:? "is_organization")

-- | ToJSON WorkspaceResponseAllOf
instance A.ToJSON WorkspaceResponseAllOf where
  toJSON WorkspaceResponseAllOf {..} =
   _omitNulls
      [ "email_domains" .= workspaceResponseAllOfEmailDomains
      , "is_organization" .= workspaceResponseAllOfIsOrganization
      ]


-- | Construct a value of type 'WorkspaceResponseAllOf' (by applying it's required fields, if any)
mkWorkspaceResponseAllOf
  :: WorkspaceResponseAllOf
mkWorkspaceResponseAllOf =
  WorkspaceResponseAllOf
  { workspaceResponseAllOfEmailDomains = Nothing
  , workspaceResponseAllOfIsOrganization = Nothing
  }


-- * Enums


-- ** E'ApprovalStatus

-- | Enum of 'Text' . 
-- *Conditional* Reflects the approval status of this task. This field is kept in sync with `completed`, meaning `pending` translates to false while `approved`, `rejected`, and `changes_requested` translate to true. If you set completed to true, this field will be set to `approved`.
data E'ApprovalStatus
  = E'ApprovalStatus'Pending -- ^ @"pending"@
  | E'ApprovalStatus'Approved -- ^ @"approved"@
  | E'ApprovalStatus'Rejected -- ^ @"rejected"@
  | E'ApprovalStatus'Changes_requested -- ^ @"changes_requested"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ApprovalStatus where toJSON = A.toJSON . fromE'ApprovalStatus
instance A.FromJSON E'ApprovalStatus where parseJSON o = P.either P.fail (pure . P.id) . toE'ApprovalStatus =<< A.parseJSON o
instance WH.ToHttpApiData E'ApprovalStatus where toQueryParam = WH.toQueryParam . fromE'ApprovalStatus
instance WH.FromHttpApiData E'ApprovalStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ApprovalStatus
instance MimeRender MimeMultipartFormData E'ApprovalStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ApprovalStatus' enum
fromE'ApprovalStatus :: E'ApprovalStatus -> Text
fromE'ApprovalStatus = \case
  E'ApprovalStatus'Pending -> "pending"
  E'ApprovalStatus'Approved -> "approved"
  E'ApprovalStatus'Rejected -> "rejected"
  E'ApprovalStatus'Changes_requested -> "changes_requested"

-- | parse 'E'ApprovalStatus' enum
toE'ApprovalStatus :: Text -> P.Either String E'ApprovalStatus
toE'ApprovalStatus = \case
  "pending" -> P.Right E'ApprovalStatus'Pending
  "approved" -> P.Right E'ApprovalStatus'Approved
  "rejected" -> P.Right E'ApprovalStatus'Rejected
  "changes_requested" -> P.Right E'ApprovalStatus'Changes_requested
  s -> P.Left $ "toE'ApprovalStatus: enum parse failure: " P.++ P.show s


-- ** E'AssigneeStatus

-- | Enum of 'Text' . 
-- Scheduling status of this task for the user it is assigned to. This field can only be set if the assignee is non-null. Setting this field to \"inbox\" or \"upcoming\" inserts it at the top of the section, while the other options will insert at the bottom.
data E'AssigneeStatus
  = E'AssigneeStatus'Today -- ^ @"today"@
  | E'AssigneeStatus'Upcoming -- ^ @"upcoming"@
  | E'AssigneeStatus'Later -- ^ @"later"@
  | E'AssigneeStatus'New -- ^ @"new"@
  | E'AssigneeStatus'Inbox -- ^ @"inbox"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AssigneeStatus where toJSON = A.toJSON . fromE'AssigneeStatus
instance A.FromJSON E'AssigneeStatus where parseJSON o = P.either P.fail (pure . P.id) . toE'AssigneeStatus =<< A.parseJSON o
instance WH.ToHttpApiData E'AssigneeStatus where toQueryParam = WH.toQueryParam . fromE'AssigneeStatus
instance WH.FromHttpApiData E'AssigneeStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AssigneeStatus
instance MimeRender MimeMultipartFormData E'AssigneeStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AssigneeStatus' enum
fromE'AssigneeStatus :: E'AssigneeStatus -> Text
fromE'AssigneeStatus = \case
  E'AssigneeStatus'Today -> "today"
  E'AssigneeStatus'Upcoming -> "upcoming"
  E'AssigneeStatus'Later -> "later"
  E'AssigneeStatus'New -> "new"
  E'AssigneeStatus'Inbox -> "inbox"

-- | parse 'E'AssigneeStatus' enum
toE'AssigneeStatus :: Text -> P.Either String E'AssigneeStatus
toE'AssigneeStatus = \case
  "today" -> P.Right E'AssigneeStatus'Today
  "upcoming" -> P.Right E'AssigneeStatus'Upcoming
  "later" -> P.Right E'AssigneeStatus'Later
  "new" -> P.Right E'AssigneeStatus'New
  "inbox" -> P.Right E'AssigneeStatus'Inbox
  s -> P.Left $ "toE'AssigneeStatus: enum parse failure: " P.++ P.show s


-- ** E'AssigneeStatus2

-- | Enum of 'Text'
data E'AssigneeStatus2
  = E'AssigneeStatus2'Inbox -- ^ @"inbox"@
  | E'AssigneeStatus2'Today -- ^ @"today"@
  | E'AssigneeStatus2'Upcoming -- ^ @"upcoming"@
  | E'AssigneeStatus2'Later -- ^ @"later"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AssigneeStatus2 where toJSON = A.toJSON . fromE'AssigneeStatus2
instance A.FromJSON E'AssigneeStatus2 where parseJSON o = P.either P.fail (pure . P.id) . toE'AssigneeStatus2 =<< A.parseJSON o
instance WH.ToHttpApiData E'AssigneeStatus2 where toQueryParam = WH.toQueryParam . fromE'AssigneeStatus2
instance WH.FromHttpApiData E'AssigneeStatus2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AssigneeStatus2
instance MimeRender MimeMultipartFormData E'AssigneeStatus2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AssigneeStatus2' enum
fromE'AssigneeStatus2 :: E'AssigneeStatus2 -> Text
fromE'AssigneeStatus2 = \case
  E'AssigneeStatus2'Inbox -> "inbox"
  E'AssigneeStatus2'Today -> "today"
  E'AssigneeStatus2'Upcoming -> "upcoming"
  E'AssigneeStatus2'Later -> "later"

-- | parse 'E'AssigneeStatus2' enum
toE'AssigneeStatus2 :: Text -> P.Either String E'AssigneeStatus2
toE'AssigneeStatus2 = \case
  "inbox" -> P.Right E'AssigneeStatus2'Inbox
  "today" -> P.Right E'AssigneeStatus2'Today
  "upcoming" -> P.Right E'AssigneeStatus2'Upcoming
  "later" -> P.Right E'AssigneeStatus2'Later
  s -> P.Left $ "toE'AssigneeStatus2: enum parse failure: " P.++ P.show s


-- ** E'Color

-- | Enum of 'Text' . 
-- Color of the portfolio.
data E'Color
  = E'Color'Dark_pink -- ^ @"dark-pink"@
  | E'Color'Dark_green -- ^ @"dark-green"@
  | E'Color'Dark_blue -- ^ @"dark-blue"@
  | E'Color'Dark_red -- ^ @"dark-red"@
  | E'Color'Dark_teal -- ^ @"dark-teal"@
  | E'Color'Dark_brown -- ^ @"dark-brown"@
  | E'Color'Dark_orange -- ^ @"dark-orange"@
  | E'Color'Dark_purple -- ^ @"dark-purple"@
  | E'Color'Dark_warm_gray -- ^ @"dark-warm-gray"@
  | E'Color'Light_pink -- ^ @"light-pink"@
  | E'Color'Light_green -- ^ @"light-green"@
  | E'Color'Light_blue -- ^ @"light-blue"@
  | E'Color'Light_red -- ^ @"light-red"@
  | E'Color'Light_teal -- ^ @"light-teal"@
  | E'Color'Light_brown -- ^ @"light-brown"@
  | E'Color'Light_orange -- ^ @"light-orange"@
  | E'Color'Light_purple -- ^ @"light-purple"@
  | E'Color'Light_warm_gray -- ^ @"light-warm-gray"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Color where toJSON = A.toJSON . fromE'Color
instance A.FromJSON E'Color where parseJSON o = P.either P.fail (pure . P.id) . toE'Color =<< A.parseJSON o
instance WH.ToHttpApiData E'Color where toQueryParam = WH.toQueryParam . fromE'Color
instance WH.FromHttpApiData E'Color where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Color
instance MimeRender MimeMultipartFormData E'Color where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Color' enum
fromE'Color :: E'Color -> Text
fromE'Color = \case
  E'Color'Dark_pink -> "dark-pink"
  E'Color'Dark_green -> "dark-green"
  E'Color'Dark_blue -> "dark-blue"
  E'Color'Dark_red -> "dark-red"
  E'Color'Dark_teal -> "dark-teal"
  E'Color'Dark_brown -> "dark-brown"
  E'Color'Dark_orange -> "dark-orange"
  E'Color'Dark_purple -> "dark-purple"
  E'Color'Dark_warm_gray -> "dark-warm-gray"
  E'Color'Light_pink -> "light-pink"
  E'Color'Light_green -> "light-green"
  E'Color'Light_blue -> "light-blue"
  E'Color'Light_red -> "light-red"
  E'Color'Light_teal -> "light-teal"
  E'Color'Light_brown -> "light-brown"
  E'Color'Light_orange -> "light-orange"
  E'Color'Light_purple -> "light-purple"
  E'Color'Light_warm_gray -> "light-warm-gray"

-- | parse 'E'Color' enum
toE'Color :: Text -> P.Either String E'Color
toE'Color = \case
  "dark-pink" -> P.Right E'Color'Dark_pink
  "dark-green" -> P.Right E'Color'Dark_green
  "dark-blue" -> P.Right E'Color'Dark_blue
  "dark-red" -> P.Right E'Color'Dark_red
  "dark-teal" -> P.Right E'Color'Dark_teal
  "dark-brown" -> P.Right E'Color'Dark_brown
  "dark-orange" -> P.Right E'Color'Dark_orange
  "dark-purple" -> P.Right E'Color'Dark_purple
  "dark-warm-gray" -> P.Right E'Color'Dark_warm_gray
  "light-pink" -> P.Right E'Color'Light_pink
  "light-green" -> P.Right E'Color'Light_green
  "light-blue" -> P.Right E'Color'Light_blue
  "light-red" -> P.Right E'Color'Light_red
  "light-teal" -> P.Right E'Color'Light_teal
  "light-brown" -> P.Right E'Color'Light_brown
  "light-orange" -> P.Right E'Color'Light_orange
  "light-purple" -> P.Right E'Color'Light_purple
  "light-warm-gray" -> P.Right E'Color'Light_warm_gray
  s -> P.Left $ "toE'Color: enum parse failure: " P.++ P.show s


-- ** E'Color2

-- | Enum of 'Text' . 
-- The color associated with the status update.
data E'Color2
  = E'Color2'Green -- ^ @"green"@
  | E'Color2'Yellow -- ^ @"yellow"@
  | E'Color2'Red -- ^ @"red"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Color2 where toJSON = A.toJSON . fromE'Color2
instance A.FromJSON E'Color2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Color2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Color2 where toQueryParam = WH.toQueryParam . fromE'Color2
instance WH.FromHttpApiData E'Color2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Color2
instance MimeRender MimeMultipartFormData E'Color2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Color2' enum
fromE'Color2 :: E'Color2 -> Text
fromE'Color2 = \case
  E'Color2'Green -> "green"
  E'Color2'Yellow -> "yellow"
  E'Color2'Red -> "red"

-- | parse 'E'Color2' enum
toE'Color2 :: Text -> P.Either String E'Color2
toE'Color2 = \case
  "green" -> P.Right E'Color2'Green
  "yellow" -> P.Right E'Color2'Yellow
  "red" -> P.Right E'Color2'Red
  s -> P.Left $ "toE'Color2: enum parse failure: " P.++ P.show s


-- ** E'CustomLabelPosition

-- | Enum of 'Text' . 
-- Only relevant for custom fields with `custom` format. This depicts where to place the custom label. This will be null if the `format` is not `custom`.
data E'CustomLabelPosition
  = E'CustomLabelPosition'Prefix -- ^ @"prefix"@
  | E'CustomLabelPosition'Suffix -- ^ @"suffix"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'CustomLabelPosition where toJSON = A.toJSON . fromE'CustomLabelPosition
instance A.FromJSON E'CustomLabelPosition where parseJSON o = P.either P.fail (pure . P.id) . toE'CustomLabelPosition =<< A.parseJSON o
instance WH.ToHttpApiData E'CustomLabelPosition where toQueryParam = WH.toQueryParam . fromE'CustomLabelPosition
instance WH.FromHttpApiData E'CustomLabelPosition where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'CustomLabelPosition
instance MimeRender MimeMultipartFormData E'CustomLabelPosition where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'CustomLabelPosition' enum
fromE'CustomLabelPosition :: E'CustomLabelPosition -> Text
fromE'CustomLabelPosition = \case
  E'CustomLabelPosition'Prefix -> "prefix"
  E'CustomLabelPosition'Suffix -> "suffix"

-- | parse 'E'CustomLabelPosition' enum
toE'CustomLabelPosition :: Text -> P.Either String E'CustomLabelPosition
toE'CustomLabelPosition = \case
  "prefix" -> P.Right E'CustomLabelPosition'Prefix
  "suffix" -> P.Right E'CustomLabelPosition'Suffix
  s -> P.Left $ "toE'CustomLabelPosition: enum parse failure: " P.++ P.show s


-- ** E'DefaultView

-- | Enum of 'Text' . 
-- The default view (list, board, calendar, or timeline) of a project.
data E'DefaultView
  = E'DefaultView'List -- ^ @"list"@
  | E'DefaultView'Board -- ^ @"board"@
  | E'DefaultView'Calendar -- ^ @"calendar"@
  | E'DefaultView'Timeline -- ^ @"timeline"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'DefaultView where toJSON = A.toJSON . fromE'DefaultView
instance A.FromJSON E'DefaultView where parseJSON o = P.either P.fail (pure . P.id) . toE'DefaultView =<< A.parseJSON o
instance WH.ToHttpApiData E'DefaultView where toQueryParam = WH.toQueryParam . fromE'DefaultView
instance WH.FromHttpApiData E'DefaultView where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'DefaultView
instance MimeRender MimeMultipartFormData E'DefaultView where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'DefaultView' enum
fromE'DefaultView :: E'DefaultView -> Text
fromE'DefaultView = \case
  E'DefaultView'List -> "list"
  E'DefaultView'Board -> "board"
  E'DefaultView'Calendar -> "calendar"
  E'DefaultView'Timeline -> "timeline"

-- | parse 'E'DefaultView' enum
toE'DefaultView :: Text -> P.Either String E'DefaultView
toE'DefaultView = \case
  "list" -> P.Right E'DefaultView'List
  "board" -> P.Right E'DefaultView'Board
  "calendar" -> P.Right E'DefaultView'Calendar
  "timeline" -> P.Right E'DefaultView'Timeline
  s -> P.Left $ "toE'DefaultView: enum parse failure: " P.++ P.show s


-- ** E'Format

-- | Enum of 'Text' . 
-- The format of this custom field.
data E'Format
  = E'Format'Currency -- ^ @"currency"@
  | E'Format'Identifier -- ^ @"identifier"@
  | E'Format'Percentage -- ^ @"percentage"@
  | E'Format'Custom -- ^ @"custom"@
  | E'Format'None -- ^ @"none"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Format where toJSON = A.toJSON . fromE'Format
instance A.FromJSON E'Format where parseJSON o = P.either P.fail (pure . P.id) . toE'Format =<< A.parseJSON o
instance WH.ToHttpApiData E'Format where toQueryParam = WH.toQueryParam . fromE'Format
instance WH.FromHttpApiData E'Format where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Format
instance MimeRender MimeMultipartFormData E'Format where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Format' enum
fromE'Format :: E'Format -> Text
fromE'Format = \case
  E'Format'Currency -> "currency"
  E'Format'Identifier -> "identifier"
  E'Format'Percentage -> "percentage"
  E'Format'Custom -> "custom"
  E'Format'None -> "none"

-- | parse 'E'Format' enum
toE'Format :: Text -> P.Either String E'Format
toE'Format = \case
  "currency" -> P.Right E'Format'Currency
  "identifier" -> P.Right E'Format'Identifier
  "percentage" -> P.Right E'Format'Percentage
  "custom" -> P.Right E'Format'Custom
  "none" -> P.Right E'Format'None
  s -> P.Left $ "toE'Format: enum parse failure: " P.++ P.show s


-- ** E'Include

-- | Enum of 'Text' . 
-- The elements that will be duplicated to the new project. Tasks are always included.
data E'Include
  = E'Include'Members -- ^ @"members"@
  | E'Include'Notes -- ^ @"notes"@
  | E'Include'Task_notes -- ^ @"task_notes"@
  | E'Include'Task_assignee -- ^ @"task_assignee"@
  | E'Include'Task_subtasks -- ^ @"task_subtasks"@
  | E'Include'Task_attachments -- ^ @"task_attachments"@
  | E'Include'Task_dates -- ^ @"task_dates"@
  | E'Include'Task_dependencies -- ^ @"task_dependencies"@
  | E'Include'Task_followers -- ^ @"task_followers"@
  | E'Include'Task_tags -- ^ @"task_tags"@
  | E'Include'Task_projects -- ^ @"task_projects"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Include where toJSON = A.toJSON . fromE'Include
instance A.FromJSON E'Include where parseJSON o = P.either P.fail (pure . P.id) . toE'Include =<< A.parseJSON o
instance WH.ToHttpApiData E'Include where toQueryParam = WH.toQueryParam . fromE'Include
instance WH.FromHttpApiData E'Include where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Include
instance MimeRender MimeMultipartFormData E'Include where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Include' enum
fromE'Include :: E'Include -> Text
fromE'Include = \case
  E'Include'Members -> "members"
  E'Include'Notes -> "notes"
  E'Include'Task_notes -> "task_notes"
  E'Include'Task_assignee -> "task_assignee"
  E'Include'Task_subtasks -> "task_subtasks"
  E'Include'Task_attachments -> "task_attachments"
  E'Include'Task_dates -> "task_dates"
  E'Include'Task_dependencies -> "task_dependencies"
  E'Include'Task_followers -> "task_followers"
  E'Include'Task_tags -> "task_tags"
  E'Include'Task_projects -> "task_projects"

-- | parse 'E'Include' enum
toE'Include :: Text -> P.Either String E'Include
toE'Include = \case
  "members" -> P.Right E'Include'Members
  "notes" -> P.Right E'Include'Notes
  "task_notes" -> P.Right E'Include'Task_notes
  "task_assignee" -> P.Right E'Include'Task_assignee
  "task_subtasks" -> P.Right E'Include'Task_subtasks
  "task_attachments" -> P.Right E'Include'Task_attachments
  "task_dates" -> P.Right E'Include'Task_dates
  "task_dependencies" -> P.Right E'Include'Task_dependencies
  "task_followers" -> P.Right E'Include'Task_followers
  "task_tags" -> P.Right E'Include'Task_tags
  "task_projects" -> P.Right E'Include'Task_projects
  s -> P.Left $ "toE'Include: enum parse failure: " P.++ P.show s


-- ** E'Include2

-- | Enum of 'Text' . 
-- The fields that will be duplicated to the new task.
data E'Include2
  = E'Include2'Notes -- ^ @"notes"@
  | E'Include2'Assignee -- ^ @"assignee"@
  | E'Include2'Subtasks -- ^ @"subtasks"@
  | E'Include2'Attachments -- ^ @"attachments"@
  | E'Include2'Tags -- ^ @"tags"@
  | E'Include2'Followers -- ^ @"followers"@
  | E'Include2'Projects -- ^ @"projects"@
  | E'Include2'Dates -- ^ @"dates"@
  | E'Include2'Dependencies -- ^ @"dependencies"@
  | E'Include2'Parent -- ^ @"parent"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Include2 where toJSON = A.toJSON . fromE'Include2
instance A.FromJSON E'Include2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Include2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Include2 where toQueryParam = WH.toQueryParam . fromE'Include2
instance WH.FromHttpApiData E'Include2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Include2
instance MimeRender MimeMultipartFormData E'Include2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Include2' enum
fromE'Include2 :: E'Include2 -> Text
fromE'Include2 = \case
  E'Include2'Notes -> "notes"
  E'Include2'Assignee -> "assignee"
  E'Include2'Subtasks -> "subtasks"
  E'Include2'Attachments -> "attachments"
  E'Include2'Tags -> "tags"
  E'Include2'Followers -> "followers"
  E'Include2'Projects -> "projects"
  E'Include2'Dates -> "dates"
  E'Include2'Dependencies -> "dependencies"
  E'Include2'Parent -> "parent"

-- | parse 'E'Include2' enum
toE'Include2 :: Text -> P.Either String E'Include2
toE'Include2 = \case
  "notes" -> P.Right E'Include2'Notes
  "assignee" -> P.Right E'Include2'Assignee
  "subtasks" -> P.Right E'Include2'Subtasks
  "attachments" -> P.Right E'Include2'Attachments
  "tags" -> P.Right E'Include2'Tags
  "followers" -> P.Right E'Include2'Followers
  "projects" -> P.Right E'Include2'Projects
  "dates" -> P.Right E'Include2'Dates
  "dependencies" -> P.Right E'Include2'Dependencies
  "parent" -> P.Right E'Include2'Parent
  s -> P.Left $ "toE'Include2: enum parse failure: " P.++ P.show s


-- ** E'Method

-- | Enum of 'Text' . 
-- The HTTP method you wish to emulate for the action.
data E'Method
  = E'Method'Get -- ^ @"get"@
  | E'Method'Post -- ^ @"post"@
  | E'Method'Put -- ^ @"put"@
  | E'Method'Delete -- ^ @"delete"@
  | E'Method'Patch -- ^ @"patch"@
  | E'Method'Head -- ^ @"head"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Method where toJSON = A.toJSON . fromE'Method
instance A.FromJSON E'Method where parseJSON o = P.either P.fail (pure . P.id) . toE'Method =<< A.parseJSON o
instance WH.ToHttpApiData E'Method where toQueryParam = WH.toQueryParam . fromE'Method
instance WH.FromHttpApiData E'Method where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Method
instance MimeRender MimeMultipartFormData E'Method where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Method' enum
fromE'Method :: E'Method -> Text
fromE'Method = \case
  E'Method'Get -> "get"
  E'Method'Post -> "post"
  E'Method'Put -> "put"
  E'Method'Delete -> "delete"
  E'Method'Patch -> "patch"
  E'Method'Head -> "head"

-- | parse 'E'Method' enum
toE'Method :: Text -> P.Either String E'Method
toE'Method = \case
  "get" -> P.Right E'Method'Get
  "post" -> P.Right E'Method'Post
  "put" -> P.Right E'Method'Put
  "delete" -> P.Right E'Method'Delete
  "patch" -> P.Right E'Method'Patch
  "head" -> P.Right E'Method'Head
  s -> P.Left $ "toE'Method: enum parse failure: " P.++ P.show s


-- ** E'ResourceSubtype

-- | Enum of 'Text' . 
-- The type of the custom field. Must be one of the given values. 
data E'ResourceSubtype
  = E'ResourceSubtype'Text -- ^ @"text"@
  | E'ResourceSubtype'Enum -- ^ @"enum"@
  | E'ResourceSubtype'Number -- ^ @"number"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ResourceSubtype where toJSON = A.toJSON . fromE'ResourceSubtype
instance A.FromJSON E'ResourceSubtype where parseJSON o = P.either P.fail (pure . P.id) . toE'ResourceSubtype =<< A.parseJSON o
instance WH.ToHttpApiData E'ResourceSubtype where toQueryParam = WH.toQueryParam . fromE'ResourceSubtype
instance WH.FromHttpApiData E'ResourceSubtype where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ResourceSubtype
instance MimeRender MimeMultipartFormData E'ResourceSubtype where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ResourceSubtype' enum
fromE'ResourceSubtype :: E'ResourceSubtype -> Text
fromE'ResourceSubtype = \case
  E'ResourceSubtype'Text -> "text"
  E'ResourceSubtype'Enum -> "enum"
  E'ResourceSubtype'Number -> "number"

-- | parse 'E'ResourceSubtype' enum
toE'ResourceSubtype :: Text -> P.Either String E'ResourceSubtype
toE'ResourceSubtype = \case
  "text" -> P.Right E'ResourceSubtype'Text
  "enum" -> P.Right E'ResourceSubtype'Enum
  "number" -> P.Right E'ResourceSubtype'Number
  s -> P.Left $ "toE'ResourceSubtype: enum parse failure: " P.++ P.show s


-- ** E'ResourceSubtype2

-- | Enum of 'Text' . 
-- The subtype of this resource. Different subtypes retain many of the same fields and behavior, but may render differently in Asana or represent resources with different semantic meaning. The resource_subtype `milestone` represent a single moment in time. This means tasks with this subtype cannot have a start_date.
data E'ResourceSubtype2
  = E'ResourceSubtype2'Default_task -- ^ @"default_task"@
  | E'ResourceSubtype2'Milestone -- ^ @"milestone"@
  | E'ResourceSubtype2'Section -- ^ @"section"@
  | E'ResourceSubtype2'Approval -- ^ @"approval"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ResourceSubtype2 where toJSON = A.toJSON . fromE'ResourceSubtype2
instance A.FromJSON E'ResourceSubtype2 where parseJSON o = P.either P.fail (pure . P.id) . toE'ResourceSubtype2 =<< A.parseJSON o
instance WH.ToHttpApiData E'ResourceSubtype2 where toQueryParam = WH.toQueryParam . fromE'ResourceSubtype2
instance WH.FromHttpApiData E'ResourceSubtype2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ResourceSubtype2
instance MimeRender MimeMultipartFormData E'ResourceSubtype2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ResourceSubtype2' enum
fromE'ResourceSubtype2 :: E'ResourceSubtype2 -> Text
fromE'ResourceSubtype2 = \case
  E'ResourceSubtype2'Default_task -> "default_task"
  E'ResourceSubtype2'Milestone -> "milestone"
  E'ResourceSubtype2'Section -> "section"
  E'ResourceSubtype2'Approval -> "approval"

-- | parse 'E'ResourceSubtype2' enum
toE'ResourceSubtype2 :: Text -> P.Either String E'ResourceSubtype2
toE'ResourceSubtype2 = \case
  "default_task" -> P.Right E'ResourceSubtype2'Default_task
  "milestone" -> P.Right E'ResourceSubtype2'Milestone
  "section" -> P.Right E'ResourceSubtype2'Section
  "approval" -> P.Right E'ResourceSubtype2'Approval
  s -> P.Left $ "toE'ResourceSubtype2: enum parse failure: " P.++ P.show s


-- ** E'ResourceSubtype3

-- | Enum of 'Text'
data E'ResourceSubtype3
  = E'ResourceSubtype3'Default_task -- ^ @"default_task"@
  | E'ResourceSubtype3'Milestone -- ^ @"milestone"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ResourceSubtype3 where toJSON = A.toJSON . fromE'ResourceSubtype3
instance A.FromJSON E'ResourceSubtype3 where parseJSON o = P.either P.fail (pure . P.id) . toE'ResourceSubtype3 =<< A.parseJSON o
instance WH.ToHttpApiData E'ResourceSubtype3 where toQueryParam = WH.toQueryParam . fromE'ResourceSubtype3
instance WH.FromHttpApiData E'ResourceSubtype3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ResourceSubtype3
instance MimeRender MimeMultipartFormData E'ResourceSubtype3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ResourceSubtype3' enum
fromE'ResourceSubtype3 :: E'ResourceSubtype3 -> Text
fromE'ResourceSubtype3 = \case
  E'ResourceSubtype3'Default_task -> "default_task"
  E'ResourceSubtype3'Milestone -> "milestone"

-- | parse 'E'ResourceSubtype3' enum
toE'ResourceSubtype3 :: Text -> P.Either String E'ResourceSubtype3
toE'ResourceSubtype3 = \case
  "default_task" -> P.Right E'ResourceSubtype3'Default_task
  "milestone" -> P.Right E'ResourceSubtype3'Milestone
  s -> P.Left $ "toE'ResourceSubtype3: enum parse failure: " P.++ P.show s


-- ** E'ResourceType

-- | Enum of 'Text'
data E'ResourceType
  = E'ResourceType'Custom_field -- ^ @"custom_field"@
  | E'ResourceType'Portfolio -- ^ @"portfolio"@
  | E'ResourceType'Project -- ^ @"project"@
  | E'ResourceType'Tag -- ^ @"tag"@
  | E'ResourceType'Task -- ^ @"task"@
  | E'ResourceType'User -- ^ @"user"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ResourceType where toJSON = A.toJSON . fromE'ResourceType
instance A.FromJSON E'ResourceType where parseJSON o = P.either P.fail (pure . P.id) . toE'ResourceType =<< A.parseJSON o
instance WH.ToHttpApiData E'ResourceType where toQueryParam = WH.toQueryParam . fromE'ResourceType
instance WH.FromHttpApiData E'ResourceType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ResourceType
instance MimeRender MimeMultipartFormData E'ResourceType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ResourceType' enum
fromE'ResourceType :: E'ResourceType -> Text
fromE'ResourceType = \case
  E'ResourceType'Custom_field -> "custom_field"
  E'ResourceType'Portfolio -> "portfolio"
  E'ResourceType'Project -> "project"
  E'ResourceType'Tag -> "tag"
  E'ResourceType'Task -> "task"
  E'ResourceType'User -> "user"

-- | parse 'E'ResourceType' enum
toE'ResourceType :: Text -> P.Either String E'ResourceType
toE'ResourceType = \case
  "custom_field" -> P.Right E'ResourceType'Custom_field
  "portfolio" -> P.Right E'ResourceType'Portfolio
  "project" -> P.Right E'ResourceType'Project
  "tag" -> P.Right E'ResourceType'Tag
  "task" -> P.Right E'ResourceType'Task
  "user" -> P.Right E'ResourceType'User
  s -> P.Left $ "toE'ResourceType: enum parse failure: " P.++ P.show s


-- ** E'ResourceType2

-- | Enum of 'Text'
data E'ResourceType2
  = E'ResourceType2'Portfolio -- ^ @"portfolio"@
  | E'ResourceType2'Project -- ^ @"project"@
  | E'ResourceType2'Tag -- ^ @"tag"@
  | E'ResourceType2'Task -- ^ @"task"@
  | E'ResourceType2'User -- ^ @"user"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ResourceType2 where toJSON = A.toJSON . fromE'ResourceType2
instance A.FromJSON E'ResourceType2 where parseJSON o = P.either P.fail (pure . P.id) . toE'ResourceType2 =<< A.parseJSON o
instance WH.ToHttpApiData E'ResourceType2 where toQueryParam = WH.toQueryParam . fromE'ResourceType2
instance WH.FromHttpApiData E'ResourceType2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ResourceType2
instance MimeRender MimeMultipartFormData E'ResourceType2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ResourceType2' enum
fromE'ResourceType2 :: E'ResourceType2 -> Text
fromE'ResourceType2 = \case
  E'ResourceType2'Portfolio -> "portfolio"
  E'ResourceType2'Project -> "project"
  E'ResourceType2'Tag -> "tag"
  E'ResourceType2'Task -> "task"
  E'ResourceType2'User -> "user"

-- | parse 'E'ResourceType2' enum
toE'ResourceType2 :: Text -> P.Either String E'ResourceType2
toE'ResourceType2 = \case
  "portfolio" -> P.Right E'ResourceType2'Portfolio
  "project" -> P.Right E'ResourceType2'Project
  "tag" -> P.Right E'ResourceType2'Tag
  "task" -> P.Right E'ResourceType2'Task
  "user" -> P.Right E'ResourceType2'User
  s -> P.Left $ "toE'ResourceType2: enum parse failure: " P.++ P.show s


-- ** E'SortBy

-- | Enum of 'Text'
data E'SortBy
  = E'SortBy'Due_date -- ^ @"due_date"@
  | E'SortBy'Created_at -- ^ @"created_at"@
  | E'SortBy'Completed_at -- ^ @"completed_at"@
  | E'SortBy'Likes -- ^ @"likes"@
  | E'SortBy'Modified_at -- ^ @"modified_at"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'SortBy where toJSON = A.toJSON . fromE'SortBy
instance A.FromJSON E'SortBy where parseJSON o = P.either P.fail (pure . P.id) . toE'SortBy =<< A.parseJSON o
instance WH.ToHttpApiData E'SortBy where toQueryParam = WH.toQueryParam . fromE'SortBy
instance WH.FromHttpApiData E'SortBy where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'SortBy
instance MimeRender MimeMultipartFormData E'SortBy where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'SortBy' enum
fromE'SortBy :: E'SortBy -> Text
fromE'SortBy = \case
  E'SortBy'Due_date -> "due_date"
  E'SortBy'Created_at -> "created_at"
  E'SortBy'Completed_at -> "completed_at"
  E'SortBy'Likes -> "likes"
  E'SortBy'Modified_at -> "modified_at"

-- | parse 'E'SortBy' enum
toE'SortBy :: Text -> P.Either String E'SortBy
toE'SortBy = \case
  "due_date" -> P.Right E'SortBy'Due_date
  "created_at" -> P.Right E'SortBy'Created_at
  "completed_at" -> P.Right E'SortBy'Completed_at
  "likes" -> P.Right E'SortBy'Likes
  "modified_at" -> P.Right E'SortBy'Modified_at
  s -> P.Left $ "toE'SortBy: enum parse failure: " P.++ P.show s


-- ** E'Source

-- | Enum of 'Text' . 
-- The component of the Asana product the user used to trigger the story.
data E'Source
  = E'Source'Web -- ^ @"web"@
  | E'Source'Email -- ^ @"email"@
  | E'Source'Mobile -- ^ @"mobile"@
  | E'Source'Api -- ^ @"api"@
  | E'Source'Unknown -- ^ @"unknown"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Source where toJSON = A.toJSON . fromE'Source
instance A.FromJSON E'Source where parseJSON o = P.either P.fail (pure . P.id) . toE'Source =<< A.parseJSON o
instance WH.ToHttpApiData E'Source where toQueryParam = WH.toQueryParam . fromE'Source
instance WH.FromHttpApiData E'Source where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Source
instance MimeRender MimeMultipartFormData E'Source where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Source' enum
fromE'Source :: E'Source -> Text
fromE'Source = \case
  E'Source'Web -> "web"
  E'Source'Email -> "email"
  E'Source'Mobile -> "mobile"
  E'Source'Api -> "api"
  E'Source'Unknown -> "unknown"

-- | parse 'E'Source' enum
toE'Source :: Text -> P.Either String E'Source
toE'Source = \case
  "web" -> P.Right E'Source'Web
  "email" -> P.Right E'Source'Email
  "mobile" -> P.Right E'Source'Mobile
  "api" -> P.Right E'Source'Api
  "unknown" -> P.Right E'Source'Unknown
  s -> P.Left $ "toE'Source: enum parse failure: " P.++ P.show s


-- ** E'State

-- | Enum of 'Text' . 
-- The current state of the export.
data E'State
  = E'State'Pending -- ^ @"pending"@
  | E'State'Started -- ^ @"started"@
  | E'State'Finished -- ^ @"finished"@
  | E'State'Error -- ^ @"error"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State where toJSON = A.toJSON . fromE'State
instance A.FromJSON E'State where parseJSON o = P.either P.fail (pure . P.id) . toE'State =<< A.parseJSON o
instance WH.ToHttpApiData E'State where toQueryParam = WH.toQueryParam . fromE'State
instance WH.FromHttpApiData E'State where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State
instance MimeRender MimeMultipartFormData E'State where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State' enum
fromE'State :: E'State -> Text
fromE'State = \case
  E'State'Pending -> "pending"
  E'State'Started -> "started"
  E'State'Finished -> "finished"
  E'State'Error -> "error"

-- | parse 'E'State' enum
toE'State :: Text -> P.Either String E'State
toE'State = \case
  "pending" -> P.Right E'State'Pending
  "started" -> P.Right E'State'Started
  "finished" -> P.Right E'State'Finished
  "error" -> P.Right E'State'Error
  s -> P.Left $ "toE'State: enum parse failure: " P.++ P.show s


-- ** E'Status

-- | Enum of 'Text'
data E'Status
  = E'Status'Not_started -- ^ @"not_started"@
  | E'Status'In_progress -- ^ @"in_progress"@
  | E'Status'Completed -- ^ @"completed"@
  | E'Status'Failed -- ^ @"failed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where toJSON = A.toJSON . fromE'Status
instance A.FromJSON E'Status where parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o
instance WH.ToHttpApiData E'Status where toQueryParam = WH.toQueryParam . fromE'Status
instance WH.FromHttpApiData E'Status where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status
instance MimeRender MimeMultipartFormData E'Status where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'Not_started -> "not_started"
  E'Status'In_progress -> "in_progress"
  E'Status'Completed -> "completed"
  E'Status'Failed -> "failed"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "not_started" -> P.Right E'Status'Not_started
  "in_progress" -> P.Right E'Status'In_progress
  "completed" -> P.Right E'Status'Completed
  "failed" -> P.Right E'Status'Failed
  s -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s


-- ** E'WriteAccess

-- | Enum of 'Text' . 
-- Whether the user has full access to the project or has comment-only access.
data E'WriteAccess
  = E'WriteAccess'Full_write -- ^ @"full_write"@
  | E'WriteAccess'Comment_only -- ^ @"comment_only"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'WriteAccess where toJSON = A.toJSON . fromE'WriteAccess
instance A.FromJSON E'WriteAccess where parseJSON o = P.either P.fail (pure . P.id) . toE'WriteAccess =<< A.parseJSON o
instance WH.ToHttpApiData E'WriteAccess where toQueryParam = WH.toQueryParam . fromE'WriteAccess
instance WH.FromHttpApiData E'WriteAccess where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'WriteAccess
instance MimeRender MimeMultipartFormData E'WriteAccess where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'WriteAccess' enum
fromE'WriteAccess :: E'WriteAccess -> Text
fromE'WriteAccess = \case
  E'WriteAccess'Full_write -> "full_write"
  E'WriteAccess'Comment_only -> "comment_only"

-- | parse 'E'WriteAccess' enum
toE'WriteAccess :: Text -> P.Either String E'WriteAccess
toE'WriteAccess = \case
  "full_write" -> P.Right E'WriteAccess'Full_write
  "comment_only" -> P.Right E'WriteAccess'Comment_only
  s -> P.Left $ "toE'WriteAccess: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthOAuthOauth2
data AuthOAuthOauth2 =
  AuthOAuthOauth2 Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthOAuthOauth2 where
  applyAuthMethod _ a@(AuthOAuthOauth2 secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", "Bearer " <> secret) 
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthBasicPersonalAccessToken
data AuthBasicPersonalAccessToken =
  AuthBasicPersonalAccessToken B.ByteString B.ByteString -- ^ username password
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicPersonalAccessToken where
  applyAuthMethod _ a@(AuthBasicPersonalAccessToken user pw) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req
    where cred = BC.append "Basic " (B64.encode $ BC.concat [ user, ":", pw ])


